C++ Core Guidelines

8 декабря 2019 года


Редколлегия:

* [Bjarne Stroustrup](http://www.stroustrup.com)
* [Херб Саттер](http://herbsutter.com/)

Это живой документ, который постоянно совершенствуется.
Если бы это был проект с открытым исходным кодом (код), это был бы релиз 0.8.
Копирование,использование, модификация и создание производных работ из данного проекта осуществляется по лицензии MIT-style.
Для участия в этом проекте требуется согласие с лицензией участника. Дополнительную информацию смотрите в прилагаемом файле [LICENSE](лицензия).
Мы делаем этот проект доступным для "дружественных пользователей", чтобы использовать, копировать, изменять и извлекать из него, надеясь на конструктивный вклад.

Замечания и предложения по улучшению наиболее приветствуются.
Мы планируем изменить и расширить этот документ, поскольку наше понимание улучшается, а язык и набор доступных библиотек улучшаются.
При комментировании, пожалуйста, обратите внимание на [введение] (#s-введение), которое описывает наши цели и общий подход.
Список участников находится [здесь] (#SS-ack).

Проблемы:

* Наборы правил не были полностью проверены на полноту, последовательность или применимость.
* Тройные вопросительные знаки (???) отметить известную недостающую информацию
* Обновление справочных разделов; многие источники pre-C++11 слишком стары.
* Более или менее актуальный список дел см.: [To-do: Unclassified proto-rules](#S-unclassified)

Вы можете [прочитать объяснение объема и структуры этого руководства] (#s-аннотация) или просто перейти прямо в:

* [In: Introduction](#S-introduction)
* [P: Philosophy](#S-philosophy)
* [I: Interfaces](#S-interfaces)
* [F: Functions](#S-functions)
* [C: Classes and class hierarchies](#S-class)
* [Enum: Enumerations](#S-enum)
* [R: Resource management](#S-resource)
* [ES: Expressions and statements](#S-expr)
* [Per: Performance](#S-performance)
* [CP: Concurrency and parallelism](#S-concurrency)
* [E: Error handling](#S-errors)
* [Con: Constants and immutability](#S-const)
* [T: Templates and generic programming](#S-templates)
* [CPL: C-style programming](#S-cpl)
* [SF: Source files](#S-source)
* [SL: The Standard Library](#S-stdlib)

Supporting sections:

* [A: Architectural ideas](#S-A)
* [NR: Non-Rules and myths](#S-not)
* [RF: References](#S-references)
* [Pro: Profiles](#S-profile)
* [GSL: Guidelines support library](#S-gsl)
* [NL: Naming and layout rules](#S-naming)
* [FAQ: Answers to frequently asked questions](#S-faq)
* [Appendix A: Libraries](#S-libraries)
* [Appendix B: Modernizing code](#S-modernizing)
* [Appendix C: Discussion](#S-discussion)
* [Appendix D: Supporting tools](#S-tools)
* [Glossary](#S-glossary)
* [To-do: Unclassified proto-rules](#S-unclassified)

You can sample rules for specific language features:

* assignment:
[regular types](#Rc-regular) --
[prefer initialization](#Rc-initialize) --
[copy](#Rc-copy-semantic) --
[move](#Rc-move-semantic) --
[other operations](#Rc-matched) --
[default](#Rc-eqdefault)
* `class`:
[data](#Rc-org) --
[invariant](#Rc-struct) --
[members](#Rc-member) --
[helpers](#Rc-helper) --
[concrete types](#SS-concrete) --
[ctors, =, and dtors](#S-ctor) --
[hierarchy](#SS-hier) --
[operators](#SS-overload)
* `concept`:
[rules](#SS-concepts) --
[in generic programming](#Rt-raise) --
[template arguments](#Rt-concepts) --
[semantics](#Rt-low)
* constructor:
[invariant](#Rc-struct) --
[establish invariant](#Rc-ctor) --
[`throw`](#Rc-throw) --
[default](#Rc-default0) --
[not needed](#Rc-default) --
[`explicit`](#Rc-explicit) --
[delegating](#Rc-delegating) --
[`virtual`](#Rc-ctor-virtual)
* derived `class`:
[when to use](#Rh-domain) --
[as interface](#Rh-abstract) --
[destructors](#Rh-dtor) --
[copy](#Rh-copy) --
[getters and setters](#Rh-get) --
[multiple inheritance](#Rh-mi-interface) --
[overloading](#Rh-using) --
[slicing](#Rc-copy-virtual) --
[`dynamic_cast`](#Rh-dynamic_cast)
* destructor:
[and constructors](#Rc-matched) --
[when needed?](#Rc-dtor) --
[may not fail](#Rc-dtor-fail)
* exception:
[errors](#S-errors) --
[`throw`](#Re-throw) --
[for errors only](#Re-errors) --
[`noexcept`](#Re-noexcept) --
[minimize `try`](#Re-catch) --
[what if no exceptions?](#Re-no-throw-codes)
* `for`:
[range-for and for](#Res-for-range) --
[for and while](#Res-for-while) --
[for-initializer](#Res-for-init) --
[empty body](#Res-empty) --
[loop variable](#Res-loop-counter) --
[loop variable type ???](#Res-???)
* function:
[naming](#Rf-package) --
[single operation](#Rf-logical) --
[no throw](#Rf-noexcept) --
[arguments](#Rf-smart) --
[argument passing](#Rf-conventional) --
[multiple return values](#Rf-out-multi) --
[pointers](#Rf-return-ptr) --
[lambdas](#Rf-capture-vs-overload)
* `inline`:
[small functions](#Rf-inline) --
[in headers](#Rs-inline)
* initialization:
[always](#Res-always) --
[prefer `{}`](#Res-list) --
[lambdas](#Res-lambda-init) --
[in-class initializers](#Rc-in-class-initializer) --
[class members](#Rc-initialize) --
[factory functions](#Rc-factory)
* lambda expression:
[when to use](#SS-lambdas)
* operator:
[conventional](#Ro-conventional) --
[avoid conversion operators](#Ro-conversion) --
[and lambdas](#Ro-lambda)
* `public`, `private`, and `protected`:
[information hiding](#Rc-private) --
[consistency](#Rh-public) --
[`protected`](#Rh-protected)
* `static_assert`:
[compile-time checking](#Rp-compile-time) --
[and concepts](#Rt-check-class)
* `struct`:
[for organizing data](#Rc-org) --
[use if no invariant](#Rc-struct) --
[no private members](#Rc-class)
* `template`:
[abstraction](#Rt-raise) --
[containers](#Rt-cont) --
[concepts](#Rt-concepts)
* `unsigned`:
[and signed](#Res-mix) --
[bit manipulation](#Res-unsigned)
* `virtual`:
[interfaces](#Ri-abstract) --
[not `virtual`](#Rc-concrete) --
[destructor](#Rc-dtor-virtual) --
[never fail](#Rc-dtor-fail)

You can look at design concepts used to express the rules:

* assertion: ???
* error: ???
* exception: exception guarantee (???)
* failure: ???
* invariant: ???
* leak: ???
* library: ???
* precondition: ???
* postcondition: ???
* resource: ???


# <a name= "S-abstract" ><a name="S-abstract" ></a>Аннотация

Этот документ представляет собой набор рекомендаций по использованию хорошо C++.
Цель этого документа состоит в том, чтобы помочь людям эффективно использовать современный C++.
Под "современным C++" мы подразумеваем эффективное использование стандарта ISO C++ (в настоящее время C++17, но почти все наши рекомендации также применимы к C++14 и C++11).
Другими словами, как бы вы хотели, чтобы ваш код выглядел через 5 лет, учитывая, что вы можете начать сейчас? Через 10 лет?

Руководящие принципы ориентированы на относительно высокоуровневые вопросы, такие как интерфейсы, управление ресурсами, управление памятью и параллелизм.
Такие правила влияют на архитектуру приложений и дизайн библиотек.
Следование правилам приведет к коду, который является статически безопасным типом, не имеет утечек ресурсов и улавливает намного больше логических ошибок программирования, чем это часто встречается в коде сегодня.
И он будет работать быстро - вы можете позволить себе делать все правильно.

Нас меньше волнуют вопросы низкого уровня, такие как Соглашения об именах и стиль отступов.
Тем не менее, ни одна тема, которая может помочь программисту, не выходит за рамки.

Наш первоначальный набор правил подчеркивает безопасность (различных форм) и простоту.
Они вполне могут быть слишком строгими.
Мы ожидаем, что нам придется вводить больше исключений для лучшего удовлетворения реальных потребностей.
Нам также нужно больше правил.

Вы обнаружите, что некоторые правила противоречат вашим ожиданиям или даже противоречат вашему опыту.
Если мы не предложили вам изменить свой стиль кодирования в любом случае, мы потерпели неудачу!
Пожалуйста, попробуйте проверить или опровергнуть правила!
В частности, нам бы очень хотелось, чтобы некоторые из наших правил были подкреплены измерениями или лучшими примерами.

Вы найдете некоторые из правил очевидными или даже тривиальными.
Пожалуйста, помните, что одна из целей руководства состоит в том, чтобы помочь кому-то, кто менее опытен или происходит из другого фона или языка, чтобы войти в курс дела.

Многие правила предназначены для поддержки с помощью инструмента анализа.
Нарушения правил будут помечены ссылками (или ссылками) на соответствующее правило.
Мы не ожидаем, что вы запомните все правила, Прежде чем пытаться написать код.
Один из способов рассмотрения этих руководящих принципов - это спецификация для инструментов, которые могут быть поняты людьми.

Правила предназначены для постепенного внедрения в кодовую базу.
Мы планируем построить инструменты для этого и надеемся, что другие тоже будут.

Замечания и предложения по улучшению наиболее приветствуются.
Мы планируем изменить и расширить этот документ, поскольку наше понимание улучшается, а язык и набор доступных библиотек улучшаются.

# <a name= "s-introduction" ><a name= "S-introduction" ></a>In: введение

Это набор основных руководящих принципов для современного C++ (в настоящее время C++17) с учетом вероятных будущих усовершенствований и технических спецификаций ISO (TSs).
Цель состоит в том, чтобы помочь программистам C++ писать более простой, более эффективный, более поддерживаемый код.

Введение резюме:

* [В.цель: целевая аудитория] (#SS-readers)
* [В.цели: Aims](#SS-aims)
* [В.not: Non-aims] (#SS-non)
* [В.force: принуждение](#SS-force)
* [В.struct: структура этого документа] (#SS-struct)
* [В.sec: основные разделы] (#SS-sec)

## <a name= "SS-readers"><a name="SS-readers" ></a>In.цель: целевая аудитория

Все программисты на C++. Это включает в себя [программисты, которые могли бы рассмотреть C](#S-cpl).

## <a name= "SS-aims"><a name="SS-aims" ></a>In.цели: Aims

Цель этого документа состоит в том, чтобы помочь разработчикам принять современный C++ (в настоящее время C++17) и добиться более единообразного стиля в разных кодовых базах.

Мы не страдаем иллюзией, что каждое из этих правил может быть эффективно применено к любой кодовой базе. Модернизировать старые системы очень сложно. Однако мы считаем, что программа, использующая правило, менее подвержена ошибкам и более поддается сопровождению, чем та, которая этого не делает. Часто правила также приводят к более быстрому/простому первоначальному развитию.
Насколько мы можем судить, эти правила приводят к коду, который работает так же или лучше, чем более старые, более традиционные методы; они предназначены для соблюдения принципа нулевых накладных расходов ("то, что вы не используете, вы не платите за это" или "когда вы используете механизм абстракции надлежащим образом, вы получаете по крайней мере такую же хорошую производительность, как если бы вы сковали наручниками с помощью языковых конструкций более низкого уровня").
Рассмотрим эти правила идеалов для нового кода, возможности для использования при работе с более старым кодом, и попытаться приблизить эти идеалы как можно ближе.
Помнить:

### <a name= "R0"><a name="R0" ></a>In.0: Без паники!

Потратьте время, чтобы понять последствия руководящего правила для вашей программы.

Эти рекомендации разработаны в соответствии с принципом" подмножество суперсетов " ([Stroustrup05](#Stroustrup05)).
Они не просто определяют подмножество C++, которое будет использоваться (для надежности, безопасности, производительности или чего-то еще).
Вместо этого они настоятельно рекомендуют использовать несколько простых "расширений" ([компоненты библиотеки] (#S-gsl))
это делает использование наиболее подверженных ошибкам функций C++ избыточным, так что они могут быть запрещены (в нашем наборе правил).

Правила подчеркивают безопасность статического типа и безопасность ресурсов.
По этой причине они подчеркивают возможности для проверки диапазона, для избежания разыменования `nullptr', для избежания висячих указателей и систематического использования исключений (через RAII).
Частично для достижения этого и частично для минимизации неясного кода как источника ошибок правила также подчеркивают простоту и скрытие необходимой сложности за четко определенными интерфейсами.

Многие правила носят предписывающий характер.
Мы испытываем дискомфорт от правил, которые просто говорят: "Не делай этого!- не предлагая альтернативу.
Одним из следствий этого является то, что некоторые правила могут быть поддержаны только эвристикой, а не точными и механически проверяемыми проверками.
Другие правила формулируют общие принципы. Для этих более общих правил более подробные и конкретные правила обеспечивают частичную проверку.

В этих рекомендациях рассматривается ядро C++ и его использование.
Мы ожидаем, что большинству крупных организаций, конкретным областям применения и даже крупным проектам потребуются дополнительные правила, возможно, дополнительные ограничения и дальнейшая библиотечная поддержка.
Например, программисты hard-real-time обычно не могут свободно использовать free store (динамическую память) и будут ограничены в выборе библиотек.
Мы призываем разработать такие более конкретные правила, как добавления к этим основным руководящим принципам.
Создайте свою идеальную небольшую базовую библиотеку и используйте ее, а не снижайте свой уровень программирования до прославленного ассемблерного кода.

Правила разработаны таким образом, чтобы позволить [постепенное принятие](#s-модернизация).

Некоторые правила направлены на повышение различных форм безопасности, в то время как другие направлены на снижение вероятности несчастных случаев, многие делают и то, и другое.
Руководящие принципы, направленные на предотвращение несчастных случаев, часто запрещают совершенно легальный C++.
Однако, когда есть два способа выражения идеи, и один показал себя общим источником ошибок, а другой нет, мы пытаемся направить программистов к последнему.

## <a name= "SS-non"><a name="SS-non" ></a>In.нет: не имеет цели

Правила не должны быть минимальными или ортогональными.
В частности, общие правила могут быть простыми, но неосуществимыми.
Кроме того, часто бывает трудно понять последствия общего правила.
Более специализированные правила часто легче понять и применять, но без общих правил они были бы просто длинным списком особых случаев.
Мы предоставляем правила, направленные на оказание помощи новичкам, а также правила, поддерживающие использование экспертов.
Некоторые правила могут быть полностью выполнены, но другие основаны на эвристике.

Эти правила не предназначены для последовательного чтения, как в книге.
Вы можете просматривать их, используя ссылки.
Однако их основное предназначение-быть мишенями для инструментов.
То есть инструмент ищет нарушения и возвращает ссылки на нарушенные правила.
Затем в правилах приводятся причины, примеры потенциальных последствий нарушения и предлагаемые средства правовой защиты.

Эти рекомендации не предназначены для замены учебника по обработке C++.
Если вам нужен учебник для некоторого заданного уровня опыта, см. [ссылки] (#s-ссылки).

Это не руководство по преобразованию старого кода C++ в более современный код.
Он предназначен для конкретного формулирования идей для нового кода.
Однако смотрите [раздел модернизация](#S-модернизация) для некоторых возможных подходов к модернизации/омоложению/модернизации.
Важно отметить, что правила поддерживают постепенное принятие: как правило, невозможно полностью преобразовать большую базу кода сразу.

Эти руководящие принципы не должны быть полными или точными на каждом языке-техническая деталь.
Заключительное слово по вопросам определения языка, включая каждое исключение из общих правил и каждую функцию, см. В стандарте ISO C++.

Правила не предназначены для того, чтобы заставить вас писать в обедненном подмножестве C++.
Они * подчеркнуто* не предназначены для определения, скажем, Java-подобного подмножества C++.
Они не предназначены для определения одного " одного истинного языка C++".
Мы ценим выразительность и бескомпромиссность исполнения.

Эти правила не являются нейтральными по отношению к ценности.
Они предназначены для того, чтобы сделать код проще и правильнее/безопаснее, чем большинство существующих C++ кода, без потери производительности.
Они предназначены для подавления идеально корректного кода C++, который коррелирует с ошибками, ложной сложностью и низкой производительностью.

Правила не точны до такой степени, что человек (или машина) может слепо следовать им.
Принудительные части пытаются быть таковыми, но мы предпочли бы оставить правило или определение немного расплывчатыми
и открыты для интерпретации, чем уточнять что-то точно и неправильно.
Иногда точность приходит только со временем и опытом.
Дизайн (пока) не является формой математики.

Эти правила не идеальны.
Правило может принести вред, запрещая что-то полезное в данной ситуации.
Правило может причинить вред, не сумев запретить что-то, что допускает серьезную ошибку в данной ситуации.
Правило может принести много вреда, будучи расплывчатым, двусмысленным, неисполнимым или позволяя каждое решение проблемы.
Невозможно полностью соответствовать критериям "не навреди".
Вместо этого наша цель менее амбициозна: "сделайте самое хорошее для большинства программистов";
если вы не можете жить с правилом, возражайте ему, игнорируйте его, но не разбавляйте его водой, пока оно не станет бессмысленным.
Кроме того, предложите улучшение.

## <a name= "SS-force"><a name="SS-force" ></a>In.сила: принуждение

Правила, не имеющие принудительного применения, неуправляемы для больших кодовых баз.
Принудительное применение всех правил возможно только для небольшого слабого набора правил или для определенного сообщества пользователей.

* Но нам нужно много правил, и мы хотим правила, которые все могут использовать.
* Но у разных людей есть разные потребности.
* Но люди не любят читать много правил.
* Но люди не могут вспомнить много правил.

Таким образом, нам нужно подмножество для удовлетворения различных потребностей.

* Но произвольное подмножество приводит к хаосу.

Нам нужны рекомендации, которые помогут многим людям, сделают код более единообразным и настоятельно рекомендуют людям модернизировать свой код.
Мы хотим поощрять передовую практику, а не оставлять все на индивидуальный выбор и давление со стороны руководства.
Идеал состоит в том, чтобы использовать все правила; это дает наибольшие преимущества.

В результате возникает довольно много дилемм.
Мы пытаемся решить эти проблемы с помощью инструментов.
Каждое правило имеет раздел * * Enforcement**, в котором перечислены идеи для обеспечения соблюдения.
Принудительное применение может быть выполнено с помощью проверки кода, статического анализа, компилятора или проверок во время выполнения.
Там, где это возможно, мы предпочитаем "механическую" проверку (люди медленны, неточны и легко сверлятся) и статическую проверку.
Проверки времени выполнения предложены только редко где никакая альтернатива не существует; мы не хотим вводить "распределенное сало".
Там, где это уместно, мы обозначаем правило (в разделах **Enforcement**) с именем групп связанных правил (называемых "профили").
Правило может входить в состав нескольких профилей или не входить ни в один.
Для начала у нас есть несколько профилей, соответствующих общим потребностям (желаниям, идеалам):

* * * тип**: никаких нарушений типа (переинтерпретация a ' T 'как A' U ' через касты, союзы или varargs)
* * * границы**: никаких нарушений границ (доступ за пределы диапазона массива)
* * * срок службы**: нет утечек (не удается "удалить" или несколько "удалить") и нет доступа к недопустимым объектам (разыменование "nullptr", используя висячую ссылку).

Профили предназначены для использования с помощью инструментов, но также служат в качестве помощи для человека читателя.
Мы не ограничиваем наш комментарий в разделах * * Enforcement* * вещами, которые мы знаем, как применять; некоторые комментарии являются простыми пожеланиями, которые могут вдохновить некоторых разработчиков инструментов.

Инструменты, реализующие эти правила, должны соблюдать следующий синтаксис для явного подавления правила:

 [[gsl:: подавить (тег)]]

где "tag" - это имя привязки элемента, в котором появляется правило принудительного применения (например, для [C. 134] (#Rh-public) это "Rh-public"), то
имя группы правил профиля ("type", "bounds" или " lifetime"),
или определенное правило в профиле ([тип.4] (#Pro-type-cstylecast), или [границы.2] (#Pro-bounds-arrayindex).

## <a name= "SS-struct"><a name="SS-struct" ></a>In.struct: структура этого документа

Каждое правило (руководящее положение, предложение) может иметь несколько частей:

* Само правило -- например, * * нет голого ' нового`**
* Номер ссылки на правило -- например, * * C. 7** (7-е правило, относящееся к классам).
 Поскольку основные разделы по своей сути не упорядочены, мы используем Буквы в качестве первой части ссылки на правило "число".
 Мы оставляем пробелы в нумерации, чтобы свести к минимуму "нарушение", когда мы добавляем или удаляем правила.
* * * Причина* * s (rationales) - потому что программистам трудно следовать правилам, которые они не понимают
* * * Пример* * s -- потому что правила трудно понять абстрактно; может быть положительным или отрицательным
* * * Альтернатива * * s -- Для правил " Не делай этого
* * * Исключение * * s -- мы предпочитаем простые общие правила. Однако многие правила применяются широко, но не универсально, поэтому исключения должны быть перечислены
* * * Правоприменение* * -- идеи о том, как правило может быть проверено "механически"
* * * См. также* * s -- ссылки на соответствующие правила и / или дальнейшее обсуждение (в настоящем документе или в других разделах)
* * * Примечание * * s (комментарии) -- то, что нужно сказать, что не соответствует другим классификациям
* * * Обсуждение * * -- ссылки на более обширное обоснование и / или примеры, помещенные вне основных списков правил

Некоторые правила трудно проверить механически, но все они отвечают минимальным критериям, что эксперт-программист может обнаружить много нарушений без особых проблем.
Мы надеемся, что "механические" инструменты со временем улучшатся, чтобы приблизиться к тому, что замечает такой опытный программист.
Кроме того, мы предполагаем, что правила будут уточнены с течением времени, чтобы сделать их более точными и проверяемыми.

Правило направлено на то, чтобы быть простым, а не тщательно сформулированным, чтобы упомянуть каждый альтернативный и особый случай.
Такая информация содержится в пунктах** Alternative * * и разделах [Обсуждение](#S-обсуждение).
Если вы не понимаете правила или не согласны с ним, пожалуйста, посетите его **обсуждение**.
Если вы чувствуете, что обсуждение отсутствует или неполное, введите [проблема](https://github.com/isocpp/CppCoreGuidelines/issues)
объясняя свои проблемы и, возможно, соответствующий пиар.

Примеры написаны для иллюстрации правил.

* Примеры не предназначены для обеспечения качества производства или охвата всех размеров учебника.
Например, многие примеры являются языковыми техническими и используют такие имена, как "f", "base" и "x".
* Мы стараемся обеспечить, чтобы "хорошие" примеры соответствовали основным руководящим принципам.
* Комментарии часто иллюстрируют правила, где они были бы ненужными и / или отвлекающими в "реальном коде"."
* Мы предполагаем знание стандартной библиотеки. Например, мы используем простой "вектор" вместо "std::vector".

Это не языковое пособие.
Он призван быть полезным, а не полным, полностью точным в технических деталях или руководством к существующему коду.
Рекомендуемые источники информации можно найти в разделе [Ссылки] (#s-ссылки).

## <a name= "SS-sec"><a name="SS-sec" ></a>In.сек: основные разделы

* [In: введение] (#s-введение)
* [P: Philosophy] (#s-philosophy)
* [I: Interfaces] (#s-интерфейсы)
* [F: функции] (#S-функции)
* [C: классы и иерархии классов] (#S-class)
* [Перечисление: перечисления] (#S-enum)
* [R: управление ресурсами] (#s-ресурс)
* [ES: выражения и операторы] (#s-expr)
* [Per: Performance](#S-производительность)
* [CP: параллелизм и параллелизм] (#s-параллелизм)
* [E: обработка ошибок] (#s-ошибки)
* [Кон: константы и неизменность] (#S-const)
* [T: шаблоны и общее Программирование] (#s-шаблоны)
* [CPL: программирование в стиле C-style] (#S-cpl)
* [SF: исходные файлы] (#s-source)
* [SL: стандартная библиотека] (#S-stdlib)

Опорные секции:

* [A: архитектурные идеи] (#S-A)
* [NR: Non-Rules and myths] (#S-not)
* [РФ: ссылки](#s-ссылки)
* [Pro: профили] (#S-профиль)
* [GSL: библиотека поддержки руководящих принципов](#S-gsl)
* [NL: правила именования и компоновки] (#s-именование)
* [FAQ: ответы на часто задаваемые вопросы] (#s-faq)
* [Приложение A: библиотеки] (#s-библиотеки)
* [Приложение B: код модернизации](#S-модернизация)
* [Добавление с: Обсуждение](#S-обсуждение)
* [Приложение D: вспомогательные инструменты] (#s-tools)
* [Глоссарий] (#S-глоссарий)
* [To-do: несекретные протоправила] (#S-несекретный)

Эти участки не являются ортогональными.

Каждый раздел (например, "P" для "философии") и каждый подраздел (например, "C. hier" для "иерархии классов (ООП)") имеют аббревиатуру для облегчения поиска и ссылки.
Основные сокращения разделов также используются в номерах правил (например, "С. 11" для "сделать конкретные типы регулярными").

# <a name= "S-philosophy" ><a name= "S-philosophy" >< / a>P: философия

Правила в этом разделе очень общие.

Философия правила резюме:

* [П. 1: выражайте идеи непосредственно в коде] (#Rp-direct)
* [П. 2: Запись В стандарте ISO C++] (#Rp-Cplusplus)
* [П. 3: выразить намерение] (#РП-что)
* [П. 4: В идеале, программа должна быть статически типобезопасной] (#Rp-typesafe)
* [П. 5: предпочтите проверку времени компиляции проверке времени выполнения] (#Rp-compile-time)
* [П. 6: то, что не может быть проверено во время компиляции, должно быть проверено во время выполнения] (#Rp-run-time)
* [П. 7: раннее обнаружение ошибок во время выполнения] (#Rp-early)
* [P. 8: Don't leak any resources] (#Rp-утечка)
* [П. 9: Не теряйте времени и пространства] (#Rp-waste)
* [П. 10: предпочтение неизменяемых данных изменяемым данным] (#Rp-mutable)
* [П. 11: Инкапсулируйте беспорядочные конструкции, а не распространяйте их через код] (#Rp-library)
* [П. 12: используйте вспомогательные инструменты по мере необходимости] (#Rp-tools)
* [П. 13: используйте библиотеки поддержки по мере необходимости] (#Rp-lib)

Философские правила, как правило, не поддаются механической проверке.
Однако отдельные правила, отражающие эти философские темы, существуют.
Без философской основы более конкретные/конкретные / проверяемые правила не имеют логического обоснования.

### <a name= "Rp-direct" ><a name= "Rp-direct">< / a > P. 1: выражайте идеи непосредственно в коде

##### Причина

Компиляторы не читают комментарии (или проектные документы), как и многие программисты (последовательно).
То, что выражается в коде, имеет определенную семантику и может (в принципе) быть проверено компиляторами и другими инструментами.

##### Образец

 дата занятия {
 Публично:
 Месяц month () const; / / do
 int месяц (); / / не надо
 // ...
 };

Первое объявление 'month' является явным о возврате 'Month `и о том, чтобы не изменять состояние объекта` Date'.
Вторая версия оставляет читателя гадать и открывает больше возможностей для необученных ошибок.

##### Пример, плохо

Этот цикл является ограниченной формой " std:: find`:

 void f (вектор<строка > & v)
 {
 строка val;
 cin > > > val;
 // ...
 int index = -1; / / плохо, плюс следует использовать gsl:: index
 для (int i = 0; i ) {
 если (v[i] = = val) {
 индекс = i;
 ломать;
 }
 }
 // ...
 }

##### Пример, хорошо

Гораздо более ясным выражением намерения было бы::

 void f (вектор<строка > & v)
 {
 строка val;
 cin > > > val;
 // ...
 auto p = найти (начало (v), конец (v), val); / / лучше
 // ...
 }

Хорошо спроектированная библиотека выражает намерение (что должно быть сделано, а не только как что-то делается) гораздо лучше, чем прямое использование языковых функций.

Программист на C++ должен знать основы стандартной библиотеки и использовать ее там, где это необходимо.
Любой программист должен знать основы фундаментальных библиотек разрабатываемого проекта и использовать их соответствующим образом.
Любой программист, использующий эти рекомендации, должен знать библиотеку поддержки [guidelines support library] (#S-gsl) и использовать ее надлежащим образом.

##### Образец

 change_speed (double s); / / bad: что означает s?
 // ...
 change_speed(2.3);

Более лучший подход должен быть явным о значении двойника (новая скорость или дельта на старой скорости?) и используемый блок:

 change_speed(скорость s); / / better: указывается значение s
 // ...
 change_speed(2.3); / / ошибка: нет единицы измерения
 change_speed (23m / 10s); / / метров в секунду

Мы могли бы принять простой (без единицы) "двойник" как дельту, но это было бы подвержено ошибкам.
Если бы мы хотели и абсолютную скорость, и дельты, мы бы определили тип "Дельта".

##### Принуждение

Очень тяжело вообще.

* последовательно используйте 'const' (проверьте, изменяют ли функции-члены свой объект; проверьте, изменяют ли функции аргументы, передаваемые указателем или ссылкой)
* флаг использует слепки (слепки кастрируют тип системы)
* обнаружение кода, который имитирует стандартную библиотеку (жесткий код)

### <a name= "Rp-Cplusplus" ><a name= "Rp-Cplusplus" > < / a>P. 2: Запись В стандарт ISO C++

##### Причина

Это набор рекомендаций для написания стандарта ISO C++.

##### Записка

Существуют среды, в которых необходимы расширения, например, для доступа к системным ресурсам.
В таких случаях локализуйте использование необходимых расширений и контролируйте их использование с помощью непрофильных руководящих принципов кодирования. Если это возможно, создайте интерфейсы, которые инкапсулируют расширения, чтобы их можно было отключить или скомпилировать в системах, которые не поддерживают эти расширения.

Расширения часто не имеют строго определенной семантики. Даже расширения, что
являются общими и реализуются несколькими компиляторами могут иметь несколько отличий
поведение и поведение граничного случая как прямой результат *не * наличия строгого
стандартная четкость. При достаточном использовании любого такого расширения, как ожидается
это скажется на переносимости.

##### Записка

Использование допустимого ISO C++ не гарантирует переносимость (не говоря уже о корректности).
Избегайте зависимости от неопределенного поведения (например, [неопределенный порядок оценки] (#Res-порядок))
и помните о конструкциях с определенным значением реализации (например, ' sizeof (int)').

##### Записка

Существуют среды, в которых необходимы ограничения на использование стандартного языка C++ или библиотечных функций, например, чтобы избежать динамического выделения памяти, как это требуется стандартами программного обеспечения для управления воздушным судном.
В таких случаях контролируйте их (dis)использование с расширением этих руководящих принципов кодирования, настроенных для конкретной среды.

##### Принуждение

Используйте современный компилятор C++ (в настоящее время c++17, C++14 или C++11) с набором параметров, которые не принимают расширения.

### <a name= "Rp-what" ><a name= "Rp-what">< / a > P. 3: выразите намерение

##### Причина

Если не указано намерение какого-либо кода (например, в названиях или комментариях), невозможно сказать, делает ли код то, что он должен делать.

##### Образец

 gsl:: индекс i = 0;
 в то время как (я ()) {
 // ... сделайте что-нибудь с v[i] ...
 }

Намерение" просто "зацикливаться на элементах `v" здесь не выражено. Сведения о реализации индекса раскрываются (так что он может быть неправильно использован), и " я " переживает область действия цикла, который может быть или не быть предназначен. Читатель не может знать только из этого раздела кода.

Лучше:

 for (const auto& x : v) { /* сделайте что-нибудь со значением x */ }

Теперь нет явного упоминания механизма итерации, и цикл работает на ссылке на элементы "const", так что случайное изменение не может произойти. Если требуется модификация, скажите так:

 для (auto& x : v) {/*изменить x */ }

Дополнительные сведения о операторах for-statements см. В разделе [ES.71] (#Res-for-range).
Иногда еще лучше использовать именованный алгоритм. Этот пример использует ' for_each` из диапазонов TS, потому что он непосредственно выражает намерение:

 for_each(v, [] (int x) { /* сделайте что-нибудь со значением x */ });
 for_each(par, v, [] (int x) { /* сделайте что-нибудь со значением x */ });

Последний вариант дает понять, что нас не интересует порядок, в котором обрабатываются элементы `v`.

Программист должен быть хорошо знаком с

* [Библиотека поддержки руководящих принципов] (#S-gsl)
* [Стандартная библиотека ISO C++] (#S-stdlib)
* Какие бы фундаментальные библиотеки не использовались для текущего проекта(ов)

##### Записка

Альтернативная формулировка: скажите, что должно быть сделано, а не просто как это должно быть сделано.

##### Записка

Некоторые языковые конструкции выражают намерение лучше, чем другие.

##### Образец

Если два ' int предназначены для координат 2D-точки, скажем так:

 draw_line(int, int, int, int); / / неясно
 draw_line(точка, точка); / / clearer

##### Принуждение

Ищите общие закономерности, для которых есть лучшие альтернативы

* простой " для "петель против диапазона -" для " петель
*` F (T*, int) 'интерфейсы против` F (span<T>)' интерфейсы
* переменные цикла в слишком большом объеме
* голые ' new ' и ' delete`
* функции с большим количеством параметров встроенных типов

Существует огромный простор для хитрости и полуавтоматического преобразования программ.

### <a name= "Rp-typesafe" ><a name= "Rp-typesafe" >< / a > P. 4: В идеале программа должна быть статически типизирована

##### Причина

В идеале, программа была бы полностью статически (во время компиляции) безопасна для типа.
К сожалению, это невозможно. Проблемные места:

* объединения
* забросы
* распад массива
* ошибка диапазона
* сужающее преобразование

##### Записка

Эти области являются источниками серьезных проблем (например, аварии и нарушения безопасности).
Мы стараемся предоставить альтернативные методы.

##### Принуждение

Мы можем запретить, ограничить или обнаружить отдельные категории проблем отдельно, как это требуется и возможно для отдельных программ.
Всегда предлагайте альтернативу.
Например:

* объединения -- используйте 'variant' (в C++17)
* casts -- минимизировать их использование; шаблоны могут помочь
* распад массива -- используйте 'span' (от GSL)
* ошибки диапазона -- используйте ' span`
* сужающие преобразования-минимизируйте их использование и используйте "узкий" или "узконаправленный" (от GSL), где они необходимы

### <a name= "Rp-время компиляции" ><a name= "Rp-время компиляции" >< / a > P. 5: предпочитайте проверку во время компиляции проверке во время выполнения

##### Причина

Ясность кода и производительность.
Вам не нужно писать обработчики ошибок для ошибок, пойманных во время компиляции.

##### Образец

 // Int-это псевдоним, используемый для целых чисел
 int bits = 0; / / don't: предотвратимый код
 ибо (Int i = 1; i; i <)
 ++биты;
 если (бит )
 cerr <";

Этот пример не может достичь того, что он пытается достичь (потому что переполнение не определено) и должен быть заменен простым ' static_assert`:

 // Int-это псевдоним, используемый для целых чисел
 static_assert(sizeof (Int) >= 4); / / do: проверка времени компиляции

Или еще лучше просто использовать систему типов и заменить `Int " на "int32_t".

##### Образец

 void read (int* p, int n); / / read max n целых чисел в *p

 int a[100];
 читать(a, 1000); / / плохо, с конца

лучше

 void read (span<int> r); / / read into the range of integers r

 int a[100];
 read(a); / / better: пусть компилятор вычисляет количество элементов

** Альтернативная формулировка**: не откладывайте на время выполнения то, что можно хорошо сделать во время компиляции.

##### Принуждение

* Ищите аргументы указателя.
* Ищите проверки времени выполнения для нарушений диапазона.

### <a name= "Rp-run-time" ><a name= "Rp-run-time" ></a>P. 6: то, что не может быть проверено во время компиляции, должно быть проверено во время выполнения

##### Причина

Оставляя труднодоступные для обнаружения ошибки в программе, вы просите сбоев и плохих результатов.

##### Записка

В идеале, мы ловим все ошибки (которые не являются ошибками в логике программиста) либо во время компиляции, либо во время выполнения. Невозможно поймать все ошибки во время компиляции и часто не доступно, чтобы поймать все оставшиеся ошибки во время выполнения. Однако мы должны стремиться писать программы, которые в принципе могут быть проверены при наличии достаточных ресурсов (программы анализа, проверки времени выполнения, машинные ресурсы, время).

##### Пример, плохо

 // отдельно компилируется, возможно динамически загружается
 extern void f(int* p);

 void g(int n)
 {
 // плохо: число элементов не передается в f()
 f (new int[n]);
 }

Здесь критический бит информации (количество элементов) был настолько тщательно "скрыт", что статический анализ, вероятно, становится невозможным, а динамическая проверка может быть очень трудной, когда `f ()` является частью ABI, так что мы не можем "измерять" этот указатель. Мы могли бы встроить полезную информацию в свободное хранилище, но это требует глобальных изменений в системе и, возможно, в компиляторе. То, что мы имеем здесь является дизайн, который делает обнаружение ошибок очень трудно.

##### Пример, плохо

Мы, конечно, можем передать количество элементов вместе с указателем:

 // отдельно компилируется, возможно динамически загружается
 extern void f2(int* p, int n);

 void g2(int n)
 {
 f2 (new int[n], m); / / bad: в f может быть передано неверное число элементов()
 }

Передача количества элементов в качестве аргумента лучше (и гораздо более распространена), чем просто передача указателя и опора на некоторое (неустановленное) Соглашение для знания или обнаружения количества элементов. Однако (как показано), простая опечатка может привести к серьезной ошибке. Связь между двумя аргументами `f2 () ' является скорее условной, чем явной.

Кроме того, подразумевается, что `f2()` должен "удалить" свой аргумент (или вызывающий объект допустил вторую ошибку?).

##### Пример, плохо

Указатели управления ресурсами стандартной библиотеки не могут передать размер, когда они указывают на объект:

 // отдельно компилируется, возможно динамически загружается
 // NB: это предполагает, что вызывающий код является ABI-совместимым, используя a
 // совместимый компилятор C++ и та же реализация stdlib
 extern void f3(unique_ptr<int []>, int n);

 пустота g3(int n)
 {
 f3 (make_unique<int []>(n), m); / / bad: передать права собственности и размер отдельно
 }

##### Образец

Нам нужно передать указатель и количество элементов как единый объект:

 extern void f4 (vector<int>&); // отдельно компилируется, возможно динамически загружается
 extern void f4 (span<int>); / / отдельно компилируется, возможно динамически загружается
 // NB: это предполагает, что вызывающий код является ABI-совместимым, используя a
 // совместимый компилятор C++ и та же реализация stdlib

 пустота g3(int n)
 {
 вектор<int> v(n);
 f4 (v); / / сдать справку, сохранить право собственности
 f4 (span<int > {v}); / / передать вид, сохранить право собственности
 }

Эта конструкция несет в себе количество элементов в качестве неотъемлемой части объекта, так что ошибки маловероятны и динамическая (run-time) проверка всегда возможна, если не всегда доступна.

##### Образец

Как мы передаем право собственности и всю информацию, необходимую для проверки использования?

 вектор<int> f5(int n) / / OK: переместить
 {
 вектор<int> v(n);
 // ... инициализировать v ...
 возврат v;
 }

 unique_ptr<int[]> f6(int n) / / плохо: теряет n
 {
 auto p = make_unique<int[]>(n);
 // ... инициализировать *p ...
 возврат p;
 }

 владелец<int*> f7 (int n) // плохо: теряет n, и мы могли бы забыть удалить
 {
 владелец<int* > p = новый int[n];
 // ... инициализировать *p ...
 возврат p;
 }

##### Образец

* ???
* покажите, как возможные проверки избегаются интерфейсами, которые передают полиморфные базовые классы вокруг, когда они на самом деле знают, что им нужно?
 Или строки в качестве опций "свободного стиля" 

##### Принуждение

* Флаг (указатель, счетчик)-стиль интерфейса (это будет отмечать много примеров, которые не могут быть исправлены по причинам совместимости)
* ???

### <a name= "Rp-early" ><a name= "Rp-early"> < / a>P. 7: раннее обнаружение ошибок во время выполнения

##### Причина

Избегайте "таинственных" аварий.
Избегайте ошибок, приводящих к (возможно, нераспознанным) неверным результатам.

##### Образец

 void increment1 (int* p, int n) / / bad: подвержен ошибкам
 {
 для (int i = 0; i ];
 }

 void use1(int m)
 {
 const int n = 10;
 int a[n] = {};
 // ...
 increment1 (a, m); / / возможно опечатка, возможно m 
 // но предположим, что m = = 20
 // ...
 }

Здесь мы допустили небольшую ошибку в 'use1', которая приведет к повреждению данных или сбою.
Интерфейс в стиле (указатель, счетчик) оставляет `increment1 ()` без какого-либо реалистичного способа защиты от ошибок вне диапазона.
Если бы мы могли проверить индексы для доступа вне диапазона, то ошибка не была бы обнаружена, пока не был получен доступ к `p[10]`.
Мы могли бы проверить раньше и улучшить код:

 void increment2(span<int> p)
 {
 для (int& x : p) ++x;
 }

 void use2(int m)
 {
 const int n = 10;
 int a[n] = {};
 // ...
 increment2 ({a, m}); / / возможно опечатка, возможно m 
 // ...
 }

Сейчас, ' m 
Если бы все, что у нас было, было опечаткой, так что мы намеревались использовать `n ' в качестве привязки, код мог бы быть еще более упрощен (исключая возможность ошибки):

 void use3(int m)
 {
 const int n = 10;
 int a[n] = {};
 // ...
 инкремент2 (a); / / число элементов a не должно повторяться
 // ...
 }

##### Пример, плохо

Не проверяйте повторно одно и то же значение. Не передавайте структурированные данные в виде строк:

 Дата read_date (istream& is); / / чтение даты из istream

 Дата extract_date (const string& s); / / извлечь дату из строки

 void user1 (const string& date) / / манипулировать датой
 {
 auto d = extract_date(дата);
 // ...
 }

 void user2()
 {
 Дата d = read_date(cin);
 // ...
 user1 (d. to_string());
 // ...
 }

Дата проверяется дважды (конструктором "Date") и передается в виде символьной строки (неструктурированные данные).

##### Образец

Лишняя проверка может быть дорогостоящей.
Есть случаи, когда ранняя проверка является тупой, потому что вам может никогда не понадобиться значение, или может потребоваться только часть значения, которое легче проверить, чем целое. Аналогично, не добавляйте проверки валидности, которые изменяют асимптотическое поведение вашего интерфейса(например, не добавляйте проверку "O(n)" к интерфейсу со средней сложностью " O (1)").

 класс Jet {//физика говорит: e * e 
 поплавок x;
 поплавок y;
 поплавок z;
 поплавок e;
 Публично:
 Струя (поплавок x, поплавок y, поплавок z, поплавок e)
 : x(x), y (y), z (z), e(e)
 {
 // Должен ли я проверить здесь, что значения являются физически значимыми?
 }

 поплавок m () const
 {
 / Должен ли я заниматься этим дегенеративным делом здесь?
 возврат sqrt(x * x + y * y + z * z-e * e);
 }

 ???
 };

Физический закон для струи ('e * e 

???

##### Принуждение

* Посмотрите на указатели и массивы: выполняйте раннюю и не многократную проверку диапазона
* Посмотрите на конверсии: устраните или отметьте сужающие конверсии
* Ищите непроверенные значения, поступающие из входных данных
* Поиск структурированных данных (объектов классов с инвариантами), преобразуемых в строки
* ???

### <a name= "Rp-leak" ><a name= "Rp-leak" > < / a>P. 8: Не пропускайте никакие ресурсы

##### Причина

Даже медленный рост объема ресурсов со временем приведет к исчерпанию имеющихся ресурсов.
Это особенно важно для длительно работающих программ, но является важной частью ответственного поведения программирования.

##### Пример, плохо

 void f(char* name)
 {
 FILE * input = fopen(имя, "r");
 // ...
 if (something) return; / / bad: if something == true, происходит утечка дескриптора файла
 // ...
 fclose(input);
 }

Предпочитаю [RAII] (#Rr-raii):

 void f(char* name)
 {
 ifstream input {name};
 // ...
 если (что-то) возвращается; / / OK: нет утечки
 // ...
 }

**Смотрите также**: [раздел Управление ресурсами](#s-resource)

##### Записка

Утечка-это в разговорном языке " все, что не очищается."
Более важная классификация - это " все, что больше не может быть очищено."
Например, выделение объекта в куче и последующая потеря последнего указателя, указывающего на это выделение.
Это правило не должно восприниматься как требующее, чтобы при завершении работы программы были возвращены выделенные ресурсы в пределах долгоживущих объектов.
Например, полагаясь на гарантированную очистку системы, такую как закрытие файла и освобождение памяти при завершении процесса, можно упростить код.
Однако полагаться на абстракции, которые неявно очищают, может быть так же просто, а часто и безопаснее.

##### Записка

Применение [профиль пожизненной безопасности] (#SS-lifetime) устраняет утечки.
В сочетании с безопасностью ресурсов, обеспечиваемой [RAII] (#Rr-raii), он устраняет необходимость в "сборке мусора" (путем создания без мусора).
Объедините это с принудительным применением [профилей типа и границ] (#SS-force), и вы получите полную типовую и ресурсную безопасность, гарантированную инструментами.

##### Принуждение

* Посмотрите на указатели: классифицируйте их на не-владельцев (по умолчанию) и владельцев.
 По возможности замените владельцев дескрипторами ресурсов стандартной библиотеки (как в приведенном выше примере).
 Кроме того, отметьте владельца как такового, используя "владелец" из [GSL](#S-gsl).
* Ищите голый 'новый' и ' удалить`
* Ищите известные функции распределения ресурсов, возвращающие необработанные указатели (такие как 'fopen', 'malloc' и ' strdup`)

### <a name= "Rp-waste" ><a name= "Rp-waste" >< / a > P. 9: Не тратьте время или пространство

##### Причина

Это C++.

##### Записка

Время и пространство, которые вы хорошо тратите для достижения цели (например, скорость разработки, безопасность ресурсов или упрощение тестирования), не тратятся впустую.
"Еще одно преимущество стремления к эффективности заключается в том, что этот процесс заставляет вас глубже понять проблему."- Алексей Степанов

##### Пример, плохо

 структура X {
 char ch;
 int i;
 строка s;
 char ch2;

 Оператор X&=(const X& a);
 X (const X&);
 };

 X отходы(const char* p)
 {
 если (!p) выбросить Nullptr_error{};
 int n = strlen(p);
 auto buf = новый символ[n];
 если (!buf) throw Allocation_error{};
 для (int i = 0; i ];
 // ... манипулируйте буфером ...
 X x;
 x.ch = 'a';
 x. s = string (n); / / дайте X. S пространство для *p
 для (gsl:: индекс i = 0; i 
 исключить [] buf;
 возврат x;
 }

 пустотообразователь()
 {
 X x = отходы ("типичный аргумент");
 // ...
 }

Да, это карикатура, но мы видели каждую отдельную ошибку в производственном коде, и даже хуже.
Обратите внимание, что расположение `X` гарантирует, что по крайней мере 6 байт (и, скорее всего, больше) будут потрачены впустую.
Ложное определение операций копирования отключает семантику перемещения, поэтому операция возврата выполняется медленно
(обратите внимание, что оптимизация возвращаемого значения, RVO, здесь не гарантируется).
Использование `new " и "delete" для " buf " является избыточным; если нам действительно нужна локальная строка, мы должны использовать локальную строку.
Есть еще несколько ошибок производительности и безвозмездное усложнение.

##### Пример, плохо

 пустое место ниже(zstring s)
 {
 для (int i = 0; i ]);
 }

Это фактически пример из производственного кода.
Мы видим, что в нашем состоянии у нас есть `я  Это выражение будет вычисляться на каждой итерации цикла, что означает, что` strlen ' должен пройти через строку каждого цикла, чтобы обнаружить его длину. В то время как содержимое строки изменяется, предполагается, что `toLower` не повлияет на длину строки, поэтому лучше кэшировать длину вне цикла и не нести эту стоимость каждой итерации.

##### Записка

Отдельный пример отходов редко бывает значимым, а там, где он значителен, он, как правило, легко устраняется экспертом.
Тем не менее, отходы, щедро распространяемые по кодовой базе, могут легко быть значительными, и эксперты не всегда доступны, как нам хотелось бы.
Цель этого правила (и более конкретных правил, которые его поддерживают) состоит в том, чтобы устранить большинство отходов, связанных с использованием C++, прежде чем это произойдет.
После этого мы можем посмотреть на отходы, связанные с алгоритмами и требованиями, но это выходит за рамки настоящих руководящих принципов.

##### Принуждение

Многие более конкретные правила направлены на достижение общих целей упрощения и ликвидации безвозмездных отходов.

* Пометить неиспользуемое возвращаемое значение из определяемой пользователем постфиксной функции `operator++` или `operator--` без дефолта. Вместо этого предпочтите использовать префиксную форму. (Примечание:" определенный пользователем без дефолта " предназначен для снижения уровня шума. Просмотрите это исполнение, если оно все еще слишком шумно на практике.)


### <a name= "Rp-mutable" ><a name= "Rp-mutable">< / a > P. 10: предпочтение неизменяемых данных изменяемым данным

##### Причина

Рассуждать о константах легче, чем о переменных.
Что-то неизменное не может неожиданно измениться.
Иногда неизменность обеспечивает лучшую оптимизацию.
У вас не может быть гонки данных на константе.

Смотрите [Con: константы и неизменность](#S-const)

### <a name= "Rp-library" ><a name="Rp-library" >< / a > P. 11: Инкапсулируйте беспорядочные конструкции, а не распространяйте их по коду

##### Причина

Беспорядочный код, скорее всего, скрывает ошибки и сложнее писать.
Хороший интерфейс проще и безопаснее в использовании.
Беспорядочный, низкоуровневый код порождает еще больше такого кода.

##### Образец

 int sz = 100;
 int * p = (int*) malloc (sizeof(int) * sz);
 int count = 0;
 // ...
 для (;;) {
 // ... прочитайте int в x, выходите из цикла, если конец файла достигнут ...
 // ... проверьте, что x является допустимым ...
 если (count == sz)
 p = (int*) realloc(p, sizeof(int) * sz * 2);
 p [count++] = x;
 // ...
 }

Это низкий уровень, многословный и подверженный ошибкам.
Например, мы "забыли" провести тест на истощение памяти.
Вместо этого мы могли бы использовать " вектор`:

 вектор<int > v;
 v. резерв(100);
 // ...
 для (int x; cin >>> x; ) {
 // ... проверьте, что x является допустимым ...
 v. push_back(x);
 }

##### Записка

Библиотека стандартов и GSL являются примерами этой философии.
Например, вместо того, чтобы возиться с массивами, объединениями, приведением, сложными вопросами жизни, "gsl:: owner"и т. д.,
которые необходимы для реализации ключевых абстракций, таких как "вектор", "span", "lock_guard" и "future", мы используем библиотеки
разработанный и реализованный людьми с большим количеством времени и опыта, чем у нас обычно есть.
Аналогичным образом, мы можем и должны разрабатывать и внедрять более специализированные библиотеки, а не оставлять пользователей (часто самих себя)
с проблемой многократного получения кода низкого уровня хорошо.
Это вариант [подмножество принципа надмножества] (#R0), который лежит в основе этих руководящих принципов.

##### Принуждение

* Ищите "беспорядочный код", такой как сложные манипуляции с указателем и приведение вне реализации абстракций.


### <a name= "Rp-tools" ><a name= "Rp-tools" >< / a > P. 12: используйте вспомогательные инструменты по мере необходимости

##### Причина

Есть много вещей, которые делаются лучше "машиной".
Компьютеры не устают и не скучают от повторяющихся задач.
Как правило, у нас есть более важные дела, чем многократное выполнение рутинных задач.

##### Образец

Запустите статический анализатор, чтобы убедиться, что ваш код следует рекомендациям, которые вы хотите, чтобы он следовал.

##### Записка

Видеть

* [Инструменты статического анализа](???)
* [Инструменты параллелизма] (#Rconc-tools)
* [Инструменты тестирования](???)

Существует множество других видов инструментов, таких как репозитории исходного кода, инструменты сборки и т. д.,
но это выходит за рамки настоящих руководящих принципов.

##### Записка

Будьте осторожны, чтобы не попасть в зависимость от чрезмерно сложных или чрезмерно специализированных цепочек инструментов.
Они могут сделать ваш в противном случае портативный код непереносимым.


### <a name= "Rp-lib" ><a name= "Rp-lib" >< / a > P. 13: используйте соответствующие библиотеки поддержки

##### Причина

Использование хорошо разработанной, хорошо документированной и хорошо поддерживаемой библиотеки экономит время и усилия;
его качество и документация, вероятно, будет больше, чем то, что вы могли бы сделать
если большая часть вашего времени должна быть потрачена на реализацию.
Стоимость (время, усилия, деньги и т.д.) библиотеки могут быть совместно использованы для многих пользователей.
Широко используемая библиотека с большей вероятностью будет обновляться и переноситься на новые системы, чем отдельное приложение.
Знание широко используемой библиотеки может сэкономить время на других / будущих проектах.
Поэтому, если подходящая библиотека существует для вашего домена приложения, используйте ее.

##### Образец

 std:: сортировка (начало (v), конец (v), std:: больше<>());

Если только вы не являетесь экспертом в алгоритмах сортировки и у вас есть много времени,
это, скорее всего, будет правильно и работать быстрее, чем все, что вы пишете для конкретного приложения.
Вам нужна причина, чтобы не использовать стандартную библиотеку (или любые другие базовые библиотеки, используемые вашим приложением), а не причина, чтобы использовать его.

##### Записка

По умолчанию используется

* Стандартная библиотека [ISO C++] (#S-stdlib)
* [Библиотека поддержки руководящих принципов] (#S-gsl)

##### Записка

Если для важного домена не существует хорошо разработанной, хорошо документированной и хорошо поддерживаемой библиотеки,
может быть, вы должны разработать и реализовать его, а затем использовать его.


# <a name= "S-interfaces" ><a name= "S-interfaces" >< / a>I: интерфейсы

Интерфейс-это контракт между двумя частями программы. Очень важно точно указать, что ожидается от поставщика услуги и пользователя этой услуги.
Имея хорошее (легкое для понимания, поощряющее эффективное использование, не подверженное ошибкам, поддерживающее тестирование и т. д.) интерфейсы, вероятно, самый важный отдельный аспект организации кода.

Сводка правил интерфейса:

* [I. 1: сделать интерфейсы явными] (#Ri-явный)
* [I. 2: Избегайте не - 'const' глобальных переменных] (#Ri-global)
* [I. 3: Избегайте синглетов] (#Ri-singleton)
* [I. 4: точно и строго типизируйте интерфейсы] (#Ri-typed)
* [I. 5: предварительные условия для государств (если таковые имеются)] (#Ri-pre)
* [I. 6: Prefer 'Expects ()' для выражения предварительных условий] (#Ri-expects)
* [I. 7: состояние постусловий] (#Ri-post)
* [I. 8: Prefer 'Ensures ()' для выражения постусловий] (#Ri-обеспечивает)
* [I. 9: если интерфейс является шаблоном, документируйте его параметры, используя понятия] (#Ri-понятия)
* [I. 10: используйте исключения, чтобы сигнализировать о невыполнении требуемой задачи] (#Ri-except)
* [I. 11: никогда не передавайте права собственности с помощью необработанного указателя ('T*') или ссылки (`T&`)] (#Ri-raw)
* [I. 12: объявите указатель, который не должен быть null как 'not_null'] (#Ri-nullptr)
* [I. 13: не передавайте массив в виде одного указателя] (#Ri-array)
* [I. 22: избегайте сложной инициализации глобальных объектов] (#Ri-global-init)
* [I. 23: держите число аргументов функции низким] (#Ri-nargs)
* [I. 24: избегайте соседних несвязанных параметров одного и того же типа] (#Ri-несвязанные)
* [I. 25: предпочтение абстрактных классов в качестве интерфейсов к иерархиям классов] (#Ri-abstract)
* [I. 26: Если вам нужен кросс-компилятор ABI, используйте подмножество C-style] (#Ri-abi)
* [I. 27: для стабильной библиотеки ABI рассмотрим идиому Pimpl] (#Ri-pimpl)
* [I. 30: инкапсулировать нарушения правил] (#Ri-инкапсулировать)

**Смотреть также**:

* [F: функции] (#S-функции)
* [C. бетон: типы бетона] (#SS-бетон)
* [C. hier: иерархии классов] (#SS-hier)
* [C. over: перегрузка и перегруженные операторы] (#SS-перегрузка)
* [C. con: контейнеры и другие дескрипторы ресурсов] (#SS-containers)
* [E: обработка ошибок] (#s-ошибки)
* [T: шаблоны и общее Программирование] (#s-шаблоны)

### <a name= "Ri-explicit" ><a name= "Ri-explicit">< / a > I. 1: Сделайте интерфейсы явными

##### Причина

Корректность. Предположения, не изложенные в интерфейсе, легко упускаются из виду и трудно проверяются.

##### Пример, плохо

Управление поведением функции через глобальную переменную (область действия пространства имен) (режим вызова) является неявным и потенциально запутанным. Например:

 int круглый (двойной d)
 {
 возвращение (round_up)? ceil (d): d; / / don't:" невидимая " зависимость
 }

Это не будет очевидно для вызывающего абонента, что значение двух вызовов ' round (7.2)` может дать разные результаты.

##### Исключение

Иногда мы контролируем детали набора операций с помощью переменной среды, например, normal vs verbose output или debug vs optimized.
Использование нелокального элемента управления потенциально приводит к путанице, но управляет только деталями реализации в противном случае фиксированной семантики.

##### Пример, плохо

Отчеты с помощью нелокальных переменных (например, "errno") легко игнорируются. Например:

 // don't: нет проверки возвращаемого значения printf
 fprintf (соединение, "ведение журнала: %d %d %d\n", x, y, s);

Что делать, если соединение выходит из строя, так что никакой выход журнала не производится? Видишь Меня???.

** Альтернатива**: бросьте исключение. Исключение нельзя игнорировать.

** Альтернативная формулировка**: избегайте передачи информации через интерфейс через нелокальное или неявное состояние.
Обратите внимание, что не-`const` функции-члены передают информацию другим функциям-членам через состояние их объекта.

** Альтернативная формулировка**: интерфейс должен быть функцией или набором функций.
Функции могут быть шаблонными функциями, а наборы функций-классами или шаблонами классов.

##### Принуждение

* (Простой) функция не должна принимать решения потока управления, основанные на значениях переменных, объявленных в области пространства имен.
* (Простой) функция не должна выполнять запись в переменные, объявленные в области пространства имен.

### <a name= "Ri-global" ><a name= "Ri-global" >< / a > I. 2: Избегайте не - ` const ' глобальных переменных

##### Причина

Не - 'const' глобальные переменные скрывают зависимости и делают зависимости подверженными непредсказуемым изменениям.

##### Образец

 данные по структуры {
 // ... много чего еще ...
 } данные; / / неконст-данные

 void compute() // не надо
 {
 // ... использовать данные. ..
 }

 вывод void() // не надо
 {
 // ... использовать данные. ..
 }

Кто еще может изменить `данные"?

** Предупреждение**: инициализация глобальных объектов не является полностью упорядоченной.
Если вы используете глобальный объект, инициализируйте его с константой.
Обратите внимание, что можно получить неопределенный порядок инициализации даже для объектов `const`.

##### Исключение

Глобальный объект часто лучше, чем синглет.

##### Записка

Глобальные константы полезны.

##### Записка

Правило для глобальных переменных применяется также к переменным области пространства имен.

** Альтернатива**: если вы используете глобальные (более общая область пространства имен) данные, чтобы избежать копирования, рассмотрите возможность передачи данных в качестве объекта по ссылке на 'const'.
Другим решением является определение данных как состояния некоторого объекта и операций как функций-членов.

** Предупреждение**: остерегайтесь гонки данных: если один поток может получить доступ к нелокальным данным (или данные, передаваемые по ссылке) в то время как другой поток выполняет вызываемый объект, мы можем иметь гонку данных.
Каждый указатель или ссылка на изменяемые данные-это потенциальная гонка данных.

Использование глобальных указателей или ссылок для доступа и изменения non-const, а также в противном случае не глобальных,
данные не являются лучшей альтернативой неконстентным глобальным переменным, поскольку это не решает проблемы скрытых зависимостей или потенциальных условий гонки.

##### Записка

Вы не можете иметь условие расы на неизменяемых данных.

** Ссылки**: смотрите раздел [Правила для вызова функций] (#SS-call).

##### Записка

Правило - "избегайте", а не " не используйте."Конечно, будут (редкие) исключения, такие как "cin", "cout" и "cerr".

##### Принуждение

(Простой) отчет обо всех не-` const ' переменных, объявленных в области пространства имен и глобальных указателях/ссылках на не-const данные.


### <a name= "Ri-singleton" ><a name= "Ri-singleton">< / a > I. 3: Избегайте синглетов

##### Причина

Синглеты-это в основном сложные замаскированные глобальные объекты.

##### Образец

 класс Singleton {
 // ... много вещей, чтобы гарантировать, что только один одноэлементный объект создается,
 // что он правильно инициализирован и т.д.
 };

Существует много вариантов идеи синглтона.
Это тоже часть проблемы.

##### Записка

Если вы не хотите изменять глобальный объект, объявите его 'const`или 'constexpr'.

##### Исключение

Вы можете использовать самый простой "синглтон" (настолько простой, что он часто не считается синглтоном), чтобы получить инициализацию при первом использовании, если таковые имеются:

 X & myX()
 {
 статический X my_x {3};
 вернуть my_x;
 }

Это одно из наиболее эффективных решений проблем, связанных с порядком инициализации.
В многопоточной среде инициализация статического объекта не вводит условие гонки
(если только вы случайно не получаете доступ к общему объекту из его конструктора).

Обратите внимание, что инициализация локального "статического" не подразумевает условия гонки.
Однако, если разрушение `X ' включает операцию, которая должна быть синхронизирована, мы должны использовать менее простое решение.
Например:

 X & myX()
 {
 статическое авто p = new X {3};
 возврат *p; / / потенциальная утечка
 }

Теперь кто-то должен "удалить" этот объект каким-то подходящим потокобезопасным способом.
Это подвержено ошибкам, поэтому мы не используем эту технику, если только

* 'myX' - это многопоточный код,
* этот объект` X ' должен быть уничтожен (например, потому что он освобождает ресурс), и
* Код деструктора ' X ' должен быть синхронизирован.

Если вы, как и многие другие, определяете синглетон как класс, для которого создается только один объект, функции, такие как "myX", не являются синглетами, и этот полезный метод не является исключением из правила no-singleton.

##### Принуждение

Очень тяжело вообще.

* Ищите классы с именами, включающими 'singleton'.
* Ищите классы, для которых создается только один объект (подсчет объектов или проверка конструкторов).
* Если класс X имеет открытую статическую функцию, которая содержит функцию-локальную статику типа класса X и возвращает указатель или ссылку на него, запретить это.

### <a name= "Ri-typed" ><a name= "Ri-typed">< / a > I. 4: Сделайте интерфейсы точно и строго типизированными

##### Причина

Типы-это самая простая и лучшая документация, улучшающая удобочитаемость из-за их четко определенного значения и проверяемая во время компиляции.
Кроме того, точно набранный код часто оптимизируется лучше.

##### Например, не надо

Считать:

 void pass(void * data); / / слабый и недостаточно квалифицированный тип void * вызывает подозрения

Абоненты не уверены, какие типы разрешены и если данные могут
быть мутированным как 'const' не указано. Примечание все типы указателей
неявно преобразуйте в void*, поэтому вызывающим объектам легко предоставить это значение.

Вызываемый объект должен передать данные static_cast в непроверенный тип для их использования.
Это склонно к ошибкам и многословно.

Используйте только 'const void*' для передачи данных в конструкциях, которые не поддаются описанию в C++. Вместо этого рассмотрите возможность использования "варианта" или указателя на базу.

** Альтернатива**: часто параметр шаблона может устранить ' void*', превратив его в `T*` или `T&`.
Для универсального кода эти ' T могут быть общими или концептуально ограниченными параметрами шаблона.

##### Пример, плохо

Считать:

 draw_rect(100, 200, 100, 500); // что же указывают эти цифры?

 draw_rect(p. x, p. y, 10, 20); // в каких единицах находятся 10 и 20?

Ясно, что вызывающий объект описывает прямоугольник, но неясно, к каким частям они относятся. Кроме того, ' int 'может нести произвольные формы информации, в том числе значения многих единиц, поэтому мы должны догадаться о значении четырех `int`. скорее всего, первые два являются координатной парой "x", "y", но каковы последние два?

Комментарии и имена параметров могут помочь, но мы можем быть явными:

 void draw_rectangle(точка top_left, точка bottom_right);
 void draw_rectangle(точка top_left, размер height_width);

 draw_rectangle(p, точка{10, 20}); / / два угла
 draw_rectangle(p, Size{10, 20}); / / один угол и пара (высота, ширина) 

Очевидно, что мы не можем поймать все ошибки через систему статического типа
(например, тот факт, что первый аргумент должен быть верхней левой точкой, оставлен для соглашения (именование и комментарии)).

##### Пример, плохо

Считать:

 set_settings(true, false, 42); / / что задают числа?

Типы параметров и их значения не сообщают, какие параметры задаются или что означают эти значения.

Этот дизайн является более четким, безопасным и разборчивым:

 alarm_settings s{};
 s. enabled = true;
 s. displayMode = alarm_settings:: mode:: spinning_light;
 s. frequency = alarm_settings:: every_10_seconds;
 set_settings(s);

Для случая набора булевых значений рассмотрим использование перечисления flags; шаблон, который выражает набор булевых значений.

 enable_lamp_options(lamp_option:: on | lamp_option:: animate_state_transitions);

##### Пример, плохо

В следующем примере не ясно из интерфейса, что означает 'time_to_blink': секунды? Миллисекунды?

 void blink_led(int time_to_blink) / / bad -- объект неоднозначен
 {
 // ...
 // сделайте что-нибудь с time_to_blink
 // ...
 }

 пустое использование()
 {
 blink_led(2);
 }

##### Пример, хорошо

типы "std:: chrono:: duration" (C++11) помогают сделать единицу длительности времени явной.

 void blink_led(миллисекунды time_to_blink) / / хорошо -- единица является явной
 {
 // ...
 // сделайте что-нибудь с time_to_blink
 // ...
 }

 пустое использование()
 {
 blink_led(1500ms);
 }

Функция также может быть записана таким образом, что она будет принимать любую единицу длительности времени.

 шаблон<класс rep, период класса>
 void blink_led(длительность<rep, период> time_to_blink) / / хорошо -- принимает любую единицу измерения
 {
 // предполагая, что миллисекунда является наименьшей соответствующей единицей измерения
 auto milliseconds_to_blink = duration_cast<миллисекунды>(time_to_blink);
 // ...
 // сделайте что-нибудь с milliseconds_to_blink
 // ...
 }

 пустое использование()
 {
 blink_led(2s);
 blink_led(1500ms);
 }

##### Принуждение

* (Простой) сообщить об использовании " void*"в качестве параметра или возвращаемого типа.
* (Простой) отчет об использовании более одного параметра` bool'.
* (Трудно сделать хорошо) ищите функции, которые используют слишком много примитивных аргументов типа.

### <a name= "Ri-pre" ><a name= "Ri-pre" ></a>I. 5: предварительные условия состояния (если таковые имеются)

##### Причина

Аргументы имеют значение, которое может ограничить их правильное использование в вызываемом абоненте.

##### Образец

Считать:

 двойной sqrt(double x);

Здесь `x " должно быть неотрицательным. Система типов не может (легко и естественно) выразить это, поэтому мы должны использовать другие средства. Например:

 double sqrt(double x); / / x должен быть неотрицательным

Некоторые предварительные условия могут быть выражены в виде утверждений. Например:

 double sqrt(double x) { ожидает (x >= 0); /* ... */ }

В идеале, это ' Expects (x >= 0)` должно быть частью интерфейса `sqrt ()`, но это не так просто сделать. На данный момент мы помещаем его в определение (тело функции).

** Ссылки**: 'Expects ()' описано в разделе [GSL] (#S-gsl).

##### Записка

Отдавать предпочтение формальной спецификации требований, такой как`Expects(p);'.
Если это невозможно, используйте английский текст в комментариях, например ' / / последовательность [p:q) упорядочена с помощью 

##### Записка

Большинство функций-членов имеют в качестве предварительного условия, что некоторый инвариант класса имеет место.
Этот инвариант устанавливается конструктором и должен быть восстановлен при выходе каждой функции-члена, вызванной из-за пределов класса.
Нам не нужно упоминать об этом для каждой функции-члена.

##### Принуждение

(Не подлежит исполнению)

** Смотрите также**: правила передачи указателей. ???

### <a name= "Ri-expects" ><a name= "Ri-expects">< / a > I. 6: предпочтите 'Expects ()' для выражения предварительных условий

##### Причина

Чтобы сделать его ясно, что условие является предварительным условием и включить использование инструмента.

##### Образец

 int площадь (int высота, int ширина)
 {
 Ожидает(высота > 0 & & ширина > > 0); / / хорошо
 если (высота <= 0 / / ширина 
 // ...
 }

##### Записка

Предварительные условия могут быть сформулированы многими способами, включая комментарии, "если" -утверждения и " assert ()".
Это может сделать их трудно отличить от обычного кода, трудно обновить, трудно манипулировать средствами и может иметь неправильную семантику (вы всегда хотите прервать в режиме отладки и ничего не проверять в производственных запусках?).

##### Записка

Предварительные условия должны быть частью интерфейса, а не частью реализации,
но у нас пока нет языковых средств для этого.
Как только языковая поддержка станет доступной (например, см. [предложение по контракту](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf)) мы примем стандартную версию предварительных условий, постусловий и утверждений.

##### Записка

'Expects ()' также может использоваться для проверки условия в середине алгоритма.

##### Записка

Нет, использование `unsigned ' не является хорошим способом обойти проблему [обеспечения неотрицательности значения](#Res-неотрицательность).

##### Принуждение

(Не подлежит исполнению) поиск различных способов утверждения предварительных условий не представляется возможным. Предупреждение о тех, которые могут быть легко идентифицированы (`assert ()`), имеет сомнительное значение в отсутствие языкового средства.

### <a name= "Ri-post" ><a name= "Ri-post">< / a > I. 7: состояние постусловий

##### Причина

Для обнаружения недоразумений о результате и, возможно, поймать ошибочные реализации.

##### Пример, плохо

Считать:

 int area (int height, int width) { возвратная высота * ширина;} / / плохо

Здесь мы (неосторожно) пропустили спецификацию предварительного условия, поэтому не ясно, что высота и ширина должны быть положительными.
Мы также пропустили спецификацию постусловия, поэтому не очевидно, что алгоритм (`height * width`) неверен для областей, больших, чем самое большое целое число.
Переполнение может произойти.
Рассмотрите возможность использования:

 int площадь (int высота, int ширина)
 {
 auto res = высота * ширина;
 Обеспечивает(res > 0);
 возврат res;
 }

##### Пример, плохо

Рассмотрим известный баг безопасности:

 пустота f () / / проблематично
 {
 буфер символов[MAX];
 // ...
 memset (buffer, 0, sizeof(buffer));
 }

Не было никакого постусловия о том, что буфер должен быть очищен, и оптимизатор устранил явно избыточный вызов " memset ():

 пустота f () / / лучше
 {
 буфер символов[MAX];
 // ...
 memset (buffer, 0, sizeof(buffer));
 Обеспечивает (буфер[0] == 0);
 }

##### Записка

Постусловия часто неофициально излагаются в комментарии, в котором указывается цель функции; "обеспечивает ()" может использоваться для того, чтобы сделать это более систематичным, видимым и проверяемым.

##### Записка

Постусловия особенно важны, когда они относятся к чему-то, что не отражается непосредственно в возвращаемом результате, например к состоянию используемой структуры данных.

##### Образец

Рассмотрим функцию, которая управляет "записью", используя "мьютекс", чтобы избежать условий гонки:

 мьютекс m;

 void манипулировать(запись& r) // не надо
 {
 m. замок();
 // ... no m. unlock ()...
 }

Здесь мы "забыли" заявить, что "мьютекс" должен быть выпущен, поэтому мы не знаем, была ли неспособность обеспечить выпуск "мьютекса" ошибкой или функцией.
Заявив, что постусловие было бы ясно:

 void Manufacture(Record& r) / / postcondition: m открывается при выходе
 {
 m. замок();
 // ... no m. unlock ()...
 }

Ошибка теперь очевидна (но только для человека, читающего комментарии).

Еще лучше, используйте [RAII] (#Rr-raii), чтобы гарантировать, что постусловие ("блокировка должна быть освобождена") применяется в коде:

 void Manufacture (Record& r) / / best
 {
 lock_guard<мьютекс > _ {m};
 // ...
 }

##### Записка

В идеале, постусловия указываются в интерфейсе / объявлении, чтобы пользователи могли легко их видеть.
В интерфейсе могут быть указаны только постусловия, связанные с пользователями.
Постусловия, относящиеся только к внутреннему состоянию, входят в определение/реализацию.

##### Принуждение

(Не подлежит исполнению) это философское руководство, которое невозможно проверить
непосредственно в общем случае. Специфичные для домена шашки (например, lock-holding
шашки) существуют для многих цепей инструментов.

### <a name= "Ri-proposes" ><a name="Ri-proposes" >< / a > I. 8: предпочитайте 'proposes ()' для выражения постусловий

##### Причина

Чтобы сделать его ясно, что условие является постусловием и включить использование инструмента.

##### Образец

 пустота f()
 {
 буфер символов[MAX];
 // ...
 memset (буфер, 0, MAX);
 Обеспечивает (буфер[0] == 0);
 }

##### Записка

Постусловия могут быть сформулированы многими способами, включая комментарии, `if`-операторы и `assert()`.
Это может сделать их трудно отличить от обычного кода, трудно обновить, трудно манипулировать инструментами и может иметь неправильную семантику.

** Альтернатива**: постусловия вида "этот ресурс должен быть освобожден" лучше всего выражаются через [RAII](#Rr-raii).

##### Записка

В идеале, это "гарантирует" должно быть частью интерфейса, но это не так просто сделать.
На данный момент мы помещаем его в определение (тело функции).
Как только языковая поддержка станет доступной (например, см. [предложение по контракту](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf)) мы примем стандартную версию предварительных условий, постусловий и утверждений.

##### Принуждение

(Не подлежит исполнению) поиск различных способов утверждения постусловий не представляется возможным. Предупреждение о тех, которые могут быть легко идентифицированы (`assert ()`), имеет сомнительное значение в отсутствие языкового средства.

### <a name= "Ri-concepts" ><a name= "Ri-concepts" ></a>I. 9: если интерфейс является шаблоном, документируйте его параметры с помощью понятий

##### Причина

Сделайте интерфейс точно заданным и проверяемым во время компиляции в будущем (не столь отдаленном).

##### Образец

Используйте стиль ISO Concepts TS спецификации требований. Например:

 шаблон<typename Iter, typename Val>
 // требуется InputIterator<Iter> & & EqualityComparable<Iter><ValueType<Iter > <Iter>>, Val<Iter>>>
 Iter find(Iter first, ITER last, Val v)
 {
 // ...
 }

##### Записка

Вскоре (возможно, в 2018 году) большинство компиляторов смогут проверять пункты "требуется" после удаления`//`.
Концепции поддерживаются в GCC 6.1 и более поздних версиях.

**Смотрите также**: [Generic programming] (#SS-GP) и [concepts](#SS-concepts).

##### Принуждение

(Еще не вступивший в законную силу) языковой объект находится в стадии спецификации. Когда языковая функция доступна, предупредите, если какой-либо не-вариадический параметр шаблона не ограничен понятием (в его объявлении или упоминается в предложении "require").

### <a name= "Ri-except" ><a name= "Ri-except" ></a>I. 10: используйте исключения, чтобы сигнализировать о невыполнении требуемой задачи

##### Причина

Невозможно игнорировать ошибку, так как это может привести систему или вычисление в неопределенное (или неожиданное) состояние.
Это является главным источником ошибок.

##### Образец

 int printf(const char* ...); / / bad: возврат отрицательного числа при сбое вывода

 шаблон ..Параметр args>
 // хорошо: бросьте system_error, если не удается запустить новый поток
 явный поток (F&& f, Args&&... параметр args);

##### Записка

Что такое ошибка?

Ошибка означает, что функция не может достичь своей объявленной цели (включая создание постусловий).
Вызов кода, который игнорирует ошибку, может привести к неверным результатам или неопределенному состоянию системы.
Например, невозможность подключиться к удаленному серверу сама по себе не является ошибкой:
сервер может отказать в подключении по самым разным причинам, поэтому естественным является возврат результата, который абонент должен всегда проверять.
Однако если не удается установить соединение считается ошибкой, то сбой должен вызвать исключение.

##### Исключение

Многие традиционные интерфейсные функции (например, обработчики сигналов UNIX) используют коды ошибок (например, "errno") для сообщения о том, что на самом деле является кодами состояния, а не ошибками. У вас нет хорошей альтернативы использованию таких, поэтому вызов этих не нарушает правило.

##### Альтернатива

Если вы не можете использовать исключения (например, потому, что ваш код полон старого стиля использования необработанных указателей или потому, что есть жесткие ограничения в режиме реального времени), рассмотрите возможность использования стиля, который возвращает пару значений:

 int val;
 int error_code;
 tie(val, error_code) = do_something();
 если (error_code) {
 // ... обработайте ошибку или выход ...
 }
 // ... используй Вэл ...

Этот стиль, к сожалению, приводит к неинициализированным переменным.
Начиная с C++17 функция "структурированные привязки" может использоваться для инициализации переменных непосредственно из возвращаемого значения:

 auto [val, error_code] = do_something();
 если (error_code) {
 // ... обработайте ошибку или выход ...
 }
 // ... используй Вэл ...

##### Записка

Мы не считаем "производительность" веской причиной не использовать исключения.

* Зачастую явная проверка и обработка ошибок занимают столько же времени и места, сколько и обработка исключений.
* Часто более чистый код дает лучшую производительность с исключениями (упрощая трассировку путей через программу и их оптимизацию).
* Хорошим правилом для критического кода производительности является перемещение проверки за пределы критической части кода ([проверка] (#Rper-проверка)).
* В долгосрочной перспективе более регулярный код будет лучше оптимизирован.
* Всегда тщательно [измеряйте] (#Rper-measure), прежде чем делать утверждения о производительности.

**См. также**: [I. 5] (#Ri-pre) и [I. 7] (#Ri-post) для сообщения о нарушениях предварительных условий и постусловий.

##### Принуждение

* (Не подлежит исполнению)это философское руководство, которое невозможно проверить непосредственно.
* Ищите `errno'.

### <a name= "Ri-raw" ><a name= "Ri-raw">< / a > I. 11: никогда не передавайте права собственности с помощью необработанного указателя (`T*') или ссылки ('T&`)

##### Причина

Если есть какие-либо сомнения, является ли вызывающий или вызываемый объект владельцем объекта, произойдет утечка или преждевременное разрушение.

##### Образец

Считать:

 X * вычислить(args) // не надо
 {
 X * res = новый X{};
 // ...
 возврат res;
 }

Кто удаляет возвращенный 'X'? Проблема будет сложнее обнаружить, если "вычислить" вернет ссылку.
Рассмотрите возможность возврата результата по значению (используйте семантику перемещения, если результат большой):

 vector<double > compute(args) / / хорошо
 {
 vector<double > res(10000);
 // ...
 возврат res;
 }

** Альтернатива**: [Pass ownership] (#Rr-smartptrparam) с использованием "интеллектуального указателя", такого как `unique_ptr` (для исключительного владения) и `shared_ptr` (для общего владения).
Однако это менее элегантно и часто менее эффективно, чем возвращение самого объекта,
поэтому используйте интеллектуальные указатели только в том случае, если необходима ссылочная семантика.

** Альтернатива**: иногда более старый код нельзя изменить из-за требований к совместимости ABI или отсутствия ресурсов.
В этом случае отметьте владение указателями, используя ' владельца` из [библиотека поддержки руководящих принципов] (#S-gsl):

 owner<X* > compute (args) // теперь ясно, что право собственности передается
 {
 владелец < X*> res = new X{};
 // ...
 возврат res;
 }

Это говорит инструментам анализа, что` res ' является владельцем.
То есть его значение должно быть "удалено" или передано другому владельцу, как это делается здесь с помощью "возврата".

'владелец' используется аналогичным образом при реализации дескрипторов ресурсов.

##### Записка

Предполагается, что каждый объект, передаваемый в качестве необработанного указателя (или итератора), принадлежит объекту
вызывающий объект, так что его время жизни обрабатывается вызывающим объектом. Смотрели по-другому:
API передачи прав собственности относительно редки по сравнению с API передачи указателей,
поэтому значение по умолчанию - " нет передачи права собственности."

**Смотрите также**: [передача аргументов] (#Rf-обычный), [использование аргументов интеллектуального указателя] (#Rr-smartptrparam) и [возврат значения] (#Rf-value-return).

##### Принуждение

* (Простой) предупреждает об удалении необработанного указателя, который не является владельцем<T>. Предложите использовать дескриптор ресурсов стандартной библиотеки или использовать `owner<T>`.
* (Простой) предупредите о невозможности либо "сбросить", либо явно "удалить" указатель "владелец" на каждом пути кода.
* (Simple) предупреждает, если возвращаемое значение `new` или вызов функции с возвращаемым значением `owner` присваивается необработанному указателю или ссылке, не являющейся ссылкой`owner`.

### <a name= "Ri-nullptr" ><a name= "Ri-nullptr"></a>I. 12: объявите указатель, который не должен иметь значение null как `not_null`

##### Причина

Чтобы избежать разыменования ошибок 'nullptr'.
Чтобы повысить производительность, избегая избыточных проверок для 'nullptr'.

##### Образец

 int length (const char* p); / / не ясно, допустима ли длина(nullptr) 

 длина(nullptr); / / OK?

 int length (not_null<const char*> p); / / better: можно предположить, что p не может быть nullptr

 int length(const char* p); // мы должны считать, что p может быть nullptr

Заявив намерение в исходном коде, исполнители и инструменты могут улучшить диагностику, например, найти некоторые классы ошибок с помощью статического анализа, и выполнить оптимизацию, например, удалить ветви и пустые тесты.

##### Записка

'not_null' определяется в [Библиотека поддержки руководящих принципов] (#S-gsl).

##### Записка

Предположение о том, что указатель на `char` указывает на строку C-стиля (строку символов с нулевым завершением), все еще было неявным и потенциальным источником путаницы и ошибок. Используйте ' czstring `вместо`const char*'.

 // мы можем предположить, что p не может быть nullptr
 // мы можем предположить, что p указывает на нулевой массив символов
 int длина(not_null<zstring> p);

Примечание: 'length ()' - это, конечно, `std::strlen()` в маскировке.

##### Принуждение

* (Simple) ((Foundation)) если функция проверяет параметр указателя на `nullptr` перед доступом на всех путях потока управления, то предупредите, что он должен быть объявлен `not_null`.
* (Комплекс) если функция с возвращаемым значением указателя гарантирует, что это не `nullptr` на всех путях возврата, то предупредите, что тип возврата должен быть объявлен `not_null`.

### <a name= "ri-array" ><a name= "Ri-array" >< / a > I. 13: не передавайте массив в виде одного указателя

##### Причина

 (указатель, размер)-интерфейсы стиля подвержены ошибкам. Кроме того, простой указатель (к массиву) должен полагаться на некоторое соглашение, чтобы позволить вызываемому объекту определить размер.

##### Образец

Считать:

 void copy_n(const T* p, T * q, int n); / / копировать из [p:p+n) в [q:q+n)

Что делать, если в массиве меньше, чем` n `элементов, на которые указывает`q'? Затем мы перезаписываем некоторые, вероятно, несвязанные воспоминания.
Что делать, если в массиве, на который указывает `p`, элементов меньше, чем `n`? Затем мы прочитали некоторые, вероятно, не связанные воспоминания.
Либо это неопределенное поведение и потенциально очень неприятная ошибка.

##### Альтернатива

Рассмотрите возможность использования явных промежутков:

 пустое копирование (span<const T> r, span<const T > <T > r2); / / copy r to r2

##### Пример, плохо

Считать:

 void draw(Shape* p, int n); / / плохой интерфейс; плохой код
 Круг arr[10];
 // ...
 ничья(Арр, 10);

Передача `10 "в качестве аргумента" n "может быть ошибкой: наиболее распространенная конвенция заключается в предположении" [0:n)", но это нигде не указано. Хуже всего то, что вызов "draw ()" вообще скомпилирован: было неявное преобразование из массива в указатель (распад массива), а затем еще одно неявное преобразование из "круга" в "форму". Нет никакого способа, которым "draw ()" может безопасно перебирать этот массив: он не имеет никакого способа узнать размер элементов.

** Альтернатива**: используйте класс поддержки, который гарантирует, что число элементов является правильным и предотвращает опасные неявные преобразования. Например:

 void draw2(span<круг>);
 Круг arr[10];
 // ...
 draw2 (span<Circle>(arr)); / / выведите количество элементов
 draw2(arr); / / выведите тип элемента и размер массива

 void draw3(span<Shape>);
 draw3(arr); / / ошибка: не удается преобразовать круг[10] в span<Shape>

Этот "draw2 ()" передает то же самое количество информации в " draw ()", но делает тот факт, что он должен быть диапазоном "явного круга". - Вот видишь.??.

##### Исключение

Используйте `zstring ' и 'czstring' для представления строк в стиле C, заканчивающихся нулем.
Но при этом используйте 'std:: string_view `или` string_span' из [GSL](#GSL), чтобы предотвратить ошибки диапазона.

##### Принуждение

* (Simple) ((Bounds)) предупреждает для любого выражения, которое будет зависеть от неявного преобразования типа массива в тип указателя. Разрешить исключение для типов указателей zstring/czstring.
* (Simple) ((Bounds)) предупреждение для любой арифметической операции над выражением типа указателя, которое приводит к значению типа указателя. Разрешить исключение для типов указателей zstring/czstring.

### <a name= "Ri-global-init" ><a name= "Ri-global-init">< / a > I. 22: избегайте сложной инициализации глобальных объектов

##### Причина

Сложная инициализация может привести к неопределенному порядку выполнения.

##### Образец

 // file1.с

 extern const X x;

 const Y y = f (x); / / чтение x; запись y

 // file2.с

 extern const Y y;

 const X x = g (y); / / чтение y; запись x

Поскольку `x ' и ' y 'находятся в разных единицах перевода, порядок вызовов' f () 'и` g ()' не определен;
вы получите доступ к неинициализированному "const".
Это показывает, что проблема порядка инициализации для глобальных объектов (область пространства имен) не ограничивается глобальными *переменными*.

##### Записка

Проблемы с порядком инициализации становятся особенно трудными для обработки в параллельном коде.
Обычно лучше всего избегать глобальных (область пространства имен) объектов вообще.

##### Принуждение

* Инициализаторы флагов глобалов, вызывающих не - 'constexpr' функции
* Инициализаторы флагов глобалов, которые обращаются к объектам ' extern` 

### <a name= "Ri-nargs" ><a name= "Ri-nargs" >< / a > I. 23: держите количество аргументов функции низким

##### Причина

Наличие большого количества аргументов открывает возможности для путаницы. Передача большого количества аргументов часто стоит дорого по сравнению с альтернативами.

##### Обсуждение

Две наиболее распространенные причины, по которым функции имеют слишком много параметров являются:

1. * Отсутствует абстракция.*
 Там отсутствует абстракция, так что составное значение находится
 передается как отдельные элементы, а не как один объект, который применяет инвариант.
 Это не только расширяет список параметров, но и приводит к ошибкам из-за значений компонентов
 они больше не защищены принудительным инвариантом.

2. * Нарушение " одной функции, одной ответственности."*
 Эта функция пытается выполнить более одной работы и, вероятно, должна быть рефакторизована.

##### Образец

Стандартная библиотека 'merge ()' находится на пределе того, что мы можем удобно обрабатывать:

 шаблон<класс InputIterator1, класс InputIterator2, класс OutputIterator, класс Compare>
 OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
 InputIterator2 first2, inputiterator2 last2,
 OutputIterator результат, сравнить комп);

Обратите внимание, что это происходит из-за проблемы 1 выше -- отсутствует абстракция. Вместо передачи диапазона (абстракции) STL передавал пары итераторов (неинкапсулированные значения компонентов).

Здесь у нас есть четыре аргумента шаблона и шесть аргументов функции.
Чтобы упростить наиболее частое и простое использование, аргумент сравнения можно использовать по умолчанию для `:

 шаблон<класс InputIterator1, класс InputIterator2, класс OutputIterator>
 OutputIterator merge(InputIterator1 first1, InputIterator1 last1,
 InputIterator2 first2, inputiterator2 last2,
 Результат OutputIterator);

Это не уменьшает общую сложность, но уменьшает поверхностную сложность, представленную многим пользователям.
Чтобы действительно уменьшить количество аргументов, нам нужно объединить их в абстракции более высокого уровня:

 шаблон<класс InputRange1, класс InputRange2, класс OutputIterator>
 Слияние OutputIterator (InputRange1 r1, InputRange2 r2, OutputIterator результат);

Группировка аргументов в "связки" является общей методикой для уменьшения количества аргументов и увеличения возможностей для проверки.

Кроме того, мы могли бы использовать понятия (как определено в ISO TS) для определения понятия трех типов, которые должны использоваться для слияния:

 Mergeable{In1, In2, Out}
 Слияние OutputIterator (In1 r1, In2 r2, Out результат);

##### Образец

Профили безопасности рекомендуют заменить

 void f(int * some_ints, int some_ints_length); / / плохо: стиль C, небезопасно

с

 void f(gsl:: span<int > some_ints); / / GOOD: safe, bounds-checked

Здесь, используя абстракцию имеет преимущества безопасности и робастности, и естественно также уменьшает число параметров.

##### Записка

Сколько параметров слишком много? Попробуйте использовать менее четырех (4) параметров.
Есть функции, которые лучше всего выражаются с помощью четырех отдельных параметров, но не так много.

** Альтернатива**: используйте лучшую абстракцию: группируйте аргументы в значимые объекты и передавайте объекты (по значению или по ссылке).

** Альтернатива**: используйте аргументы по умолчанию или перегрузки, чтобы разрешить выполнение наиболее распространенных форм вызовов с меньшим количеством аргументов.

##### Принуждение

* Предупреждать, когда функция объявляет два итератора (включая указатели) одного и того же типа вместо диапазона или представления.
* (Не подлежит исполнению)это философское руководство, которое невозможно проверить непосредственно.

### <a name= "Ri-несвязанный"><a name="Ri-несвязанный" ></a>I. 24: избегайте соседних несвязанных параметров одного и того же типа

##### Причина

Соседние аргументы того же типа легко меняются местами по ошибке.

##### Пример, плохо

Считать:

 void copy_n(T* p, T * q, int n); / / копировать из [p:p + n) в [q:q + n)

Это неприятный вариант интерфейса K&R C-style. Легко поменять местами аргументы "к" и "от".

Используйте 'const` для аргумента" from:

 void copy_n(const T* p, T * q, int n); / / копировать из [p:p + n) в [q:q + n)

##### Исключение

Если порядок следования параметров не важен, то нет никаких проблем:

 int max(int a, int b);

##### Альтернатива

Не передавайте массивы в качестве указателей, передайте объект, представляющий диапазон (например, " span`):

 void copy_n(span<const T> p, span<const T > <T > q); / / копировать из p в q

##### Альтернатива

Определите 'struct' как тип параметра и назовите поля для этих параметров соответственно:

 структура SystemParams {
 строка config_file;
 строка output_path;
 секундный тайм-аут;
 };
 void initialize(SystemParams p);

Это имеет тенденцию делать призывы этого ясными для будущих читателей, поскольку параметры
часто заполняются поименно на сайте вызова.

##### Принуждение

(Простой) предупреждает, если два последовательных параметра имеют один и тот же тип.

### <a name= "Ri-abstract" ><a name= "Ri-abstract">< / a > I. 25: предпочтение абстрактных классов в качестве интерфейсов к иерархиям классов

##### Причина

Абстрактные классы с большей вероятностью будут стабильными, чем базовые классы с состоянием.

##### Пример, плохо

Вы просто знали, что "форма" где-то появится :-)

 class Shape {//bad: класс интерфейса, загруженный данными
 Публично:
 Point center () const { return c; }
 virtual void draw () const;
 virtual void rotate(int);
 // ...
 Частное:
 Пункт с;
 вектор < точка> контур;
 Цвет col;
 };

Это заставит каждый производный класс вычислить центр - даже если это нетривиально, и центр никогда не используется. Аналогично, не каждая "фигура" имеет "цвет", и многие "фигуры" лучше всего представлены без контура, определенного как последовательность "точек". абстрактные классы были изобретены, чтобы отговорить пользователей от написания таких классов:

 класс Shape {//better: Shape-это чистый интерфейс
 Публично:
 virtual Point center () const = 0; / / чисто виртуальные функции
 virtual void draw () const = 0;
 virtual void rotate (int) = 0;
 // ...
 // ... нет элементов данных ...
 // ...
 virtual ~Shape () = по умолчанию;
 };

##### Принуждение

(Простой) предупреждает, если указатель/ссылка на класс `C` назначается указателю / ссылке на базу `C ' и базовый класс содержит элементы данных.

### <a name= "Ri-abi" ><a name= "Ri-abi" >< / a > I. 26: Если вам нужен кросс-компилятор ABI, используйте подмножество C-style

##### Причина

Различные компиляторы реализуют различные бинарные макеты для классов, обработки исключений, имен функций и других деталей реализации.

##### Исключение

Общие ABIs появляются на некоторых платформах, освобождая вас от более драконовских ограничений.

##### Записка

Если вы используете один компилятор, вы можете использовать полный C++ в интерфейсах. Это может потребовать повторной компиляции после обновления до новой версии компилятора.

##### Принуждение

(Не подлежит исполнению) трудно достоверно определить, где интерфейс является частью ABI.

### <a name= "Ri-pimpl"><a name="Ri-pimpl">< / a > I. 27: для стабильной библиотеки ABI рассмотрим идиому Pimpl

##### Причина

Поскольку частные члены данных участвуют в макете класса и частные функции-члены участвуют в разрешении перегрузки, изменения к ним
сведения о реализации требуют перекомпиляции всех пользователей класса, который их использует. Неполиморфный класс интерфейса, содержащий указатель на
реализация (Pimpl) может изолировать пользователей класса от изменений в его реализации за счет косвенного воздействия.

##### Образец

интерфейс (виджет.х)

 виджет класса {
 класс impl;
 std:: unique_ptr<impl> pimpl;
 Публично:
 void draw (); / / public API, который будет перенаправлен на реализацию
 виджет (int); / / определен в файле реализации
 ~widget (); / / определяется в файле реализации, где impl-это полный тип
 виджет (widget&&); / / определенный в файле реализации
 виджет (const widget&) = удалить;
 widget & operator=(widget&&); // определено в файле реализации
 виджет & оператор=(const widget&) = удалить;
 };


реализация (виджет.СРР)

 виджет класса:: impl {
 int n; / / личные данные
 Публично:
 void draw (const widget& w) { /* ... */ }
 impl(int n) : n(n) {}
 };
 void widget:: draw () { pimpl- > draw(*this); }
 widget:: widget(int n): pimpl{std:: make_unique<impl>(n)} {}
 widget:: widget(widget&&) = по умолчанию;
 widget::~widget () = по умолчанию;
 widget & widget:: operator=(widget&&) = по умолчанию;

##### Примечания

Смотрите [GOTW #100](https://herbsutter.com/gotw/_100/) и [cppreference](http://en.cppreference.com/w/cpp/language/pimpl) для компромиссов и дополнительных деталей реализации, связанных с этой идиомой.

##### Принуждение

(Не подлежит исполнению) трудно достоверно определить, где интерфейс является частью ABI.

### <a name= "Ri-encapsulate" ><a name= "Ri-encapsulate">< / a > I. 30: инкапсуляция нарушений правил

##### Причина

Чтобы сохранить код простым и безопасным.
Иногда некрасивые, небезопасные или подверженные ошибкам методы необходимы по логическим или производительным причинам.
Если это так, держите их локальными, а не "заражающими" интерфейсы, чтобы более крупные группы программистов должны были знать о том, что
премудрости.
Сложность реализации должна, если это вообще возможно, не просачиваться через интерфейсы в пользовательский код.

##### Образец

Рассмотрим программу, которая, в зависимости от некоторой формы ввода (например, аргументы для `main`), должна потреблять вводимые данные
из файла, из командной строки или из стандартного ввода.
Мы могли бы написать:

 бул принадлежит;
 владелец<istream* > inp;
 переключатель (источник) {
 case std_in: owned = false; inp = & cin; break;
 case command_line: owned = true; inp = new istringstream{argv[2]}; break;
 файл обращения: owned = true; inp = new ifstream{argv[2]}; break;
 }
 istream& in = * inp;

Это нарушило правило [для неинициализированных переменных] (#Res-всегда),
правило против [игнорирования владения] (#Ri-raw),
и правило [против магических констант] (#Res-magic).
В частности, кто-то должен помнить, чтобы где-то писать

 если (принадлежит) удалить inp;

Мы могли бы обработать этот конкретный пример, используя 'unique_ptr' со специальным удалителем, который ничего не делает для `cin`,
но это сложно для новичков (которые могут легко столкнуться с этой проблемой), и пример является примером более общего
проблема, когда свойство, которое мы хотели бы считать статическим (здесь, владение) , нечасто нуждается в решении
во время выполнения.
Общие, наиболее частые и безопасные примеры могут обрабатываться статически, поэтому мы не хотим добавлять к ним стоимость и сложность.
Но мы также должны справиться с необычными, менее безопасными и обязательно более дорогими случаями.
Такие примеры обсуждаются в [[Str15]](http://www.stroustrup.com/resource-model.pdf).

Итак, мы пишем класс

 класс Istream { [[gsl:: suppress(lifetime)]]
 Публично:
 enum Opt { from_line = 1 };
 интерфейс IStream() { }
 Istream(zstring p): owned{true}, inp{new ifstream{p}} {} / / чтение из файла
 Istream(zstring p, Opt): owned{true}, inp{new istringstream{p}} {} / / чтение из командной строки
 ~Istream () {if (owned) delete inp; }
 оператор istream& () { return *inp; }
 Частное:
 bool owned = false;
 istream* inp = &cin;
 };

Теперь динамическая природа владения "istream" была инкапсулирована.
Предположительно, в реальном коде будет добавлена небольшая проверка на возможные ошибки.

##### Принуждение

* Трудно, трудно решить, какой код нарушения правил является существенным
* Подавление правил флага, которые позволяют нарушителям правил пересекать интерфейсы

# <a name= "S-функции" ><a name= "S-функции" >< / a>F: функции

Функция задает действие или вычисление, которое переводит систему из одного согласованного состояния в другое. Это фундаментальный строительный блок программ.

Следует иметь возможность многозначительно назвать функцию, указать требования к ее аргументу и четко сформулировать связь между аргументами и результатом. Реализация не является спецификацией. Попробуйте подумать о том, что делает функция, а также о том, как она это делает.
Функции являются наиболее важной частью в большинстве интерфейсов, поэтому смотрите правила интерфейса.

Сводка правила функции:

Правила определения функций:

* [F. 1: "пакет" значимые операции как тщательно названные функции] (#Rf-package)
* [F. 2: функция должна выполнять одну логическую операцию] (#Rf-logical)
* [F. 3: Держите функции короткими и простыми](#Rf-single)
* [F. 4: Если функция может быть оценена во время компиляции, объявите ее 'constexpr'] (#Rf-constexpr)
* [F. 5: если функция очень мала и критична по времени, объявите ее встроенной] (#Rf-inline)
* [F. 6: Если ваша функция не может бросить, объявите его 'noexcept'] (#Rf-noexcept)
* [F. 7: для общего использования возьмите аргументы` T* `или` T& ' вместо интеллектуальных указателей] (#Rf-smart)
* [F. 8: предпочитайте чистые функции](#Rf-pure)
* [F. 9: неиспользуемые параметры должны быть безымянными] (#Rf-unused)

Правила выражения для передачи параметров:

* [F. 15: предпочитайте простые и обычные способы передачи информации] (#Rf-conventional)
* [F. 16: для параметров " in "передайте дешево скопированные типы по значению и другие по ссылке на 'const'] (#Rf-in)
* [F. 17: для параметров "in-out" передайте ссылку на не - 'const'] (#Rf-inout)
* [F. 18: для параметров "will-move-from", пройдите мимо` X&& `и` std::move ' параметр] (#Rf-consume)
* [F. 19: для параметров "вперед", пройдите мимо 'TP&&' и только 'std:: forward' параметр](#Rf-forward)
* [F. 20: для выходных значений" out " предпочтите возвращаемые значения выходным параметрам] (#Rf-out)
* [F. 21: чтобы вернуть несколько значений "out", предпочтите вернуть структуру или кортеж] (#Rf-out-multi)
* [F. 60: предпочесть `T* ' над ' T&', когда" без аргумента " является допустимым вариантом] (#Rf-ptr-ref)

Параметр, передающий семантические правила:

* [F. 22: используйте `T* ' или 'owner<T*>' для обозначения одного объекта] (#Rf-ptr)
* [F. 23: используйте ' not_null<T>', чтобы указать, что" null " не является допустимым значением] (#Rf-nullptr)
* [F. 24: используйте 'span<T>' или 'span_p<T > <T>' для обозначения полуоткрытой последовательности] (#Rf-диапазон)
* [F. 25: используйте `zstring ' или 'not_null<zstring>' для обозначения строки в стиле C] (#Rf-zstring)
* [F. 26: используйте 'unique_ptr<T>' для передачи права собственности, где требуется указатель] (#Rf-unique_ptr)
* [F. 27: используйте 'shared_ptr<T>' для совместного владения] (#Rf-shared_ptr)

<a name= "Rf-value-return" ><a name= "Rf-value-return">< / a > семантические правила возврата значения:

* [F. 42: возврат A 'T*' для указания позиции (только)] (#Rf-return-ptr)
* [F. 43: никогда (прямо или косвенно) не возвращайте указатель или ссылку на локальный объект] (#Rf-dangle)
* [F. 44: возврат `T&', когда копирование нежелательно и "возврат без объекта" не требуется] (#Rf-return-ref)
* [F. 45: не возвращайте `T&&'] (#Rf-return-ref-ref)
* [F. 46: 'int' - это тип возврата для ' main ()`] (#Rf-main)
* [F. 47: возврат `T& ' от операторов присваивания] (#Rf-присваивание-op)
* [F. 48: не ' return std:: move (local)`] (#Rf-return-move-local)

Другие правила функции:

* [F. 50: используйте лямбду, когда функция не работает (для захвата локальных переменных или для записи локальной функции)] (#Rf-capture-vs-overload)
* [F. 51: где есть выбор, предпочтите аргументы по умолчанию над перегрузкой] (#Rf-default-args)
* [F. 52: предпочитайте захват по ссылке в lambdas, которые будут использоваться локально, включая передаваемые алгоритмам] (#Rf-reference-capture)
* [F. 53: избегайте захвата по ссылке в lambdas, которые будут использоваться нелокально, включая возвращенные, сохраненные в куче или переданные в другой поток] (#Rf-value-capture)
* [F. 54: Если вы захватите "это", захватите все переменные явно (без захвата по умолчанию)] (#Rf-this-capture)
* [F. 55: Не используйте аргументы `va_arg`] (#F-varargs)

Функции имеют сильное сходство с объектами lambdas и function.

**Смотрите также**: [C. лямбды: функциональные объекты и лямбды](#SS-лямбды)

## <a name= "SS-fct-def" ><a name= "SS-fct-def" >< / a>F. def: определения функций

Определение функции-это объявление функции, которое также определяет реализацию функции, тело функции.

### <a name= "Rf-package" ><a name= "Rf-package" >< / a > F. 1:" Package " значимые операции как тщательно названные функции

##### Причина

Разложение общего кода делает код более читаемым, более вероятным для повторного использования и ограничивает количество ошибок в сложном коде.
Если что-то является четко определенным действием, отделите его от окружающего кода и дайте ему имя.

##### Например, не надо

 void read_and_print(istream& is) / / чтение и печать int
 {
 int x;
 если (is > > > x)
 cout < < "the int is" < < x <;
 еще
 cerr <";
 }

Почти все неправильно с 'read_and_print'.
Он читает, он пишет (в фиксированный 'ostream`), он пишет сообщения об ошибках (в фиксированный` ostream`), он обрабатывает только 'int'.
Там нет ничего, чтобы повторно использовать, логически отдельные операции смешиваются и локальные переменные находятся в области действия после окончания их логического использования.
Для крошечного примера это выглядит нормально, но если операция ввода, операция вывода и обработка ошибок были более сложными, запутанные
беспорядок может стать трудно понять.

##### Записка

Если вы пишете нетривиальную лямбду, которую потенциально можно использовать более чем в одном месте, дайте ей имя, назначив ее переменной (обычно нелокальной).

##### Образец

 sort(A, b, [] (T x, T y) { return x. rank () < y. rank() && x. value() (); });

Называние этой лямбды разбивает выражение на его логические части и дает сильный намек на значение лямбды.

 auto lessT = [] (T x, T y) { return x. rank () < y. rank() && x. value() (); };

 сортировка(a, b, lessT);
 find_if(a, b, lessT);

Самый короткий код не всегда является лучшим по производительности или ремонтопригодности.

##### Исключение

Тела циклов, включая лямбды, используемые в качестве тел циклов, редко нуждаются в именовании.
Однако большие тела цикла (например, десятки строк или десятки страниц) могут быть проблемой.
Правило [Keep functions short and simple] (#Rf-single) подразумевает "держать тела цикла короткими."
Аналогичным образом, лямбды, используемые в качестве аргументов обратного вызова, иногда нетривиальны, но вряд ли могут быть повторно использованы.

##### Принуждение

* Смотрите раздел [сохранять функции короткими и простыми](#Rf-single)
* Флаг идентичных и очень похожих лямбд, используемых в разных местах.

### <a name= "Rf-logical" ><a name= "Rf-logical">< / a > F. 2: функция должна выполнять одну логическую операцию

##### Причина

Функция, выполняющая одну операцию, проще для понимания, тестирования и повторного использования.

##### Образец

Считать:

 void read_and_print () / / плохо
 {
 int x;
 cin > > > x;
 // проверьте наличие ошибок
 cout << x <";
 }

Это монолит, который привязан к определенному входу и никогда не найдет другого (иного) применения. Вместо этого разбейте функции на соответствующие логические части и параметризуйте:

 int read(istream& is) / / лучше
 {
 int x;
 is > > > x;
 // проверьте наличие ошибок
 возврат x;
 }

 void print(ostream & os, int x)
 {
 os < < x <";
 }

Теперь их можно комбинировать там, где это необходимо:

 void read_and_print()
 {
 auto x = read(cin);
 печать(cout, x);
 }

При необходимости мы могли бы дополнительно шаблонизировать `read ()` и 'print ()' по типу данных, механизму ввода-вывода, реакции на ошибки и т. д. Пример:

 auto read = [] (auto& input, auto& value) // лучше
 {
 входное значение;
 // проверьте наличие ошибок
 };

 автоматическая печать(auto & output, const auto & value)
 {
 вывод < < значение <";
 }

##### Принуждение

* Считайте подозрительными функции с более чем одним параметром "out". Вместо этого используйте возвращаемые значения, включая "Кортеж" для нескольких возвращаемых значений.
* Считайте подозрительными "большие" функции, которые не помещаются на одном экране редактора. Рассмотрите возможность разложения такой функции на более мелкие хорошо названные подоперации.
* Считайте подозрительными функции с 7 и более параметрами.

### <a name= "Rf-single" ><a name= "Rf-single">< / a > F. 3: Держите функции короткими и простыми

##### Причина

Большие функции трудно читаются, с большей вероятностью содержат сложный код и с большей вероятностью имеют переменные в больших, чем минимальные области видимости.
Функции со сложными структурами управления, скорее всего, будут длительными и с большей вероятностью скроют логические ошибки

##### Образец

Считать:

 double simple_func(double val, int flag1, int flag2)
 // simple_func: принимает значение и вычисляет ожидаемые выходные данные ASIC,
 // учитывая два флага режима.
 {
 двойное промежуточное звено;
 если (Флаг1 > 0) {
 intermediate = func1 (val);
 если (флаг2 % 2)
 промежуточный = sqrt(intermediate);
 }
 иначе если (flag1 = = -1) {
 промежуточное звено = func1 (- val);
 если (флаг2 % 2)
 intermediate = sqrt (- intermediate);
 flag1 = - flag1;
 }
 если (abs (flag2) > 10) {
 intermediate = func2(intermediate);
 }
 переключатель (flag2 / 10) {
 случай 1: Если (flag1 == -1) возврат finalize (intermediate, 1.171);
 ломать;
 случай 2: возврат finalize(intermediate, 13.1);
 по умолчанию: перерыв;
 }
 возврат finalize(intermediate, 0.);
 }

Это слишком сложно.
Как бы вы узнали, если все возможные альтернативы были правильно обработаны?
Да, это нарушает и другие правила.

Мы можем рефактор:

 double func1_muon(двойной вал, флаг int)
 {
 // ???
 }

 double func1_tau(double val, int flag1, int flag2)
 {
 // ???
 }

 double simple_func(double val, int flag1, int flag2)
 // simple_func: принимает значение и вычисляет ожидаемые выходные данные ASIC,
 // учитывая два флага режима.
 {
 если (Флаг1 > 0)
 возврат func1_muon(val, flag2);
 если (Флаг1 = = -1)
 // обрабатывается func1_tau: flag1 = - flag1;
 возврат func1_tau(-val, flag1, flag2);
 возврат 0.;
 }

##### Записка

"Он не помещается на экране" часто является хорошим практическим определением "слишком большого размера."
Функции от одной до пяти строк следует считать нормальными.

##### Записка

Разбейте большие функции на более мелкие связные и именованные функции.
Небольшие простые функции легко встроены там, где стоимость вызова функции значительна.

##### Принуждение

* Флаговые функции, которые не " помещаются на экране."
 Насколько велик экран? Попробуйте 60 строк по 140 символов; это примерно максимум, который удобен для страницы книги.
* Флаговые функции, которые слишком сложны. Насколько сложен этот слишком сложный процесс?
 Вы можете использовать цикломатическую сложность. Попробуйте "более 10 логических путей до конца.- Считайте, что простой переключатель-это один путь.

### <a name= "Rf-constexpr" ><a name= "Rf-constexpr" >< / a > F. 4: Если функция может быть оценена во время компиляции, объявите ее ' constexpr`

##### Причина

 'constexpr' необходимо сообщить компилятору, чтобы разрешить оценку времени компиляции.

##### Образец

Знаменитый факториал (in:

 constexpr int fac(int n)
 {
 constexpr int max_exp = 17; / / constexpr позволяет использовать max_exp в Expects
 Ожидает(0 <= n && n 
 int x = 1;
 ибо (int i = 2; i ;
 возврат x;
 }

Это C++14.
Для C++11 используйте рекурсивную формулировку ' fac ()'.

##### Записка

'constexpr' не гарантирует оценку времени компиляции;
это просто гарантирует, что функция может быть оценена во время компиляции для Аргументов постоянного выражения, если программист требует этого или компилятор решает сделать это для оптимизации.

 constexpr int min (int x, int y) { return x  x : y; }

 испытание на пустоту(int v)
 {
 int m1 = min(-1, 2); / / вероятно оценка времени компиляции
 constexpr int m2 = min(-1, 2); / / оценка времени компиляции
 int m3 = min(-1, v); / / оценка времени выполнения
 constexpr int m4 = min (-1, v); / / ошибка: не удается выполнить оценку во время компиляции
 }

##### Записка

Не пытайтесь сделать все функции `constexpr'.
Большинство вычислений лучше всего выполнять во время выполнения.

##### Записка

Любой API, который может в конечном итоге зависеть от конфигурации времени выполнения высокого уровня или
бизнес-логика не должна быть сделана 'constexpr'. Такой кастомизации быть не может
вычисляется компилятором, и любые функции 'constexpr', которые зависели от
этот API должен был бы быть рефакторизован или отбросить `constexpr`.

##### Принуждение

Невозможное и ненужное.
Компилятор выдает ошибку, если не-`constexpr` функция вызывается там, где требуется константа.

### <a name= "Rf-inline" ><a name= "Rf-inline" ></a>F. 5: если функция очень мала и критична по времени, объявите ее `inline`

##### Причина

Некоторые оптимизаторы хороши в инлайнинге без подсказок от программиста, но не полагаются на него.
Мера! За последние 40 лет или около того, нам были обещаны компиляторы, которые могут встроить лучше, чем люди без намеков от людей.
Мы все еще ждем.
Указание 'inline' побуждает компилятор выполнять лучшую работу.

##### Образец

 встроенная строка cat (const string& s, const string& s2) { return s + s2; }

##### Исключение

Не помещайте "встроенную" функцию в то, что должно быть стабильным интерфейсом, если вы не уверены, что она не изменится.
Встроенная функция является частью ABI.

##### Записка

'constexpr' подразумевает 'встроенный'.

##### Записка

Функции-члены, определенные в классе, по умолчанию являются встроенными.

##### Исключение

Функции шаблона (ВКЛ. функции-члены шаблона) обычно определяются в заголовках и поэтому встроены.

##### Принуждение

Флаг 'встроенные' функции, которые являются более чем тремя операторами и могут быть объявлены вне строки (например, функции-члены класса).

### <a name= "Rf-noexcept" ><a name= "Rf-noexcept" >< / a > F. 6: Если ваша функция не может бросить, объявите ее ' noexcept`

##### Причина

Если исключение не предполагается выдавать, программа не может считаться справившейся с ошибкой и должна быть прекращена как можно скорее. Объявление функции "noexcept" помогает оптимизаторам сократить число альтернативных путей выполнения. Он также ускоряет выход после сбоя.

##### Образец

Поместите `noexcept ' на каждую функцию, написанную полностью на C или на любом другом языке без исключений.
Стандартная библиотека C++ делает это неявно для всех функций в стандартной библиотеке C.

##### Записка

функции 'constexpr' могут бросать при вычислении во время выполнения, поэтому вам может понадобиться `noexcept` для некоторых из них.

##### Образец

Вы можете использовать 'noexcept' даже на функции, которые могут бросить:

 vector<string > collect (istream& is) noexcept
 {
 вектор < строка> res;
 для (строка s; is >>> s;)
 рез. push_back(s);
 возврат res;
 }

Если 'collect ()' работает без памяти, программа аварийно завершает работу.
Если программа не создана, чтобы пережить истощение памяти, это может быть просто правильно сделать;
'terminate ()' может генерировать подходящую информацию журнала ошибок (но после исчерпания памяти трудно сделать что-либо умное).

##### Записка

Вы должны знать о среде выполнения, в которой выполняется ваш код, когда
принятие решения о том, следует ли помечать функцию "noexcept", особенно из-за проблемы
о метании и распределении. Код, который должен быть совершенно общим (например
стандартная библиотека и другой служебный код такого рода) нуждается в поддержке
среды, в которых исключение "bad_alloc" может быть обработано многозначительно.
Тем не менее, большинство программ и сред выполнения не могут осмысленно
обработайте отказ выделить, и прерывать программу самые чистые и
самый простой ответ на сбой распределения в этих случаях. Если вы знаете, что
код приложения не может реагировать на сбой выделения, это может быть
целесообразно добавить 'noexcept' даже на функции, которые выделяют.

Скажем иначе: в большинстве программ большинство функций можно выбросить (например, потому что они
используйте `new', вызывайте соответствующие функции или используйте библиотечные функции, которые сообщают об ошибке
бросая), так что не просто посыпать "noexcept" по всему месту без
рассмотрение вопроса о том, можно ли обрабатывать возможные исключения.

'noexcept' является наиболее полезным (и наиболее четко правильно) для часто используемых,
низкоуровневые функции.

##### Записка

Деструкторы, функции "подкачки", операции перемещения и конструкторы по умолчанию никогда не должны бросать.
См.также [C. 44](#Rc-default00).

##### Принуждение

* Флаг функции, которые не являются " noexcept`, но не может бросить.
* Флаг бросая "своп", "перемещение", деструкторы и конструкторы по умолчанию.

### <a name= "Rf-smart"><a name= "Rf-smart">< / a > F. 7: для общего использования возьмите аргументы 'T*' или 'T&' вместо интеллектуальных указателей

##### Причина

Передача интеллектуального указателя передает или разделяет владение и должна использоваться только тогда, когда семантика владения предназначена (см. [R. 30](#RR-smartptrparam)).
Передача по интеллектуальному указателю ограничивает использование функции для вызывающих объектов, использующих интеллектуальные указатели.
Передача общего интеллектуального указателя (например, `std::shared_ptr`) подразумевает затраты времени выполнения.

##### Образец

 // принимает любой int*
 void f(int*);

 // можно принимать только те int, для которых вы хотите передать право собственности
 void g(unique_ptr<int>);

 // может принимать только инт, для которых вы готовы поделиться собственностью
 void g(shared_ptr<int>);

 // не меняет владельца, но требует определенного владения вызывающего объекта
 void h(const unique_ptr<int>&);

 // принимает любой int
 void h(int&);

##### Пример, плохо

 // вызываемый
 void f(shared_ptr<widget > & w)
 {
 // ...
 use(*w); / / только использование w -- срок службы не используется вообще
 // ...
 };

Смотрите далее в [R. 30] (#RR-smartptrparam).

##### Записка

Мы можем ловить висячие указатели статически, поэтому нам не нужно полагаться на управление ресурсами, чтобы избежать нарушений от висячих указателей.

**Смотреть также**:

* [Предпочесть `T* ' над ' T&', когда" без аргумента " является допустимым вариантом] (#Rf-ptr-ref)
* [Smart pointer rule summary] (#Rr-summary-smartptrs)

##### Принуждение

Отметьте параметр типа интеллектуального указателя (тип, который перегружает 'operator - > `или' operator*'), для которого не используется семантика владения;
то есть

* копируемая, но никогда не копируемая / перемещаемая из или подвижная, но никогда не перемещаемая
* и это никогда не изменяется и не передается другой функции, которая могла бы сделать это.

### <a name= "Rf-pure" ><a name= "Rf-pure">< / a > F. 8: предпочтение чистых функций

##### Причина

Чистые функции легче рассуждать, иногда их легче оптимизировать (и даже распараллеливать), а иногда их можно запомнить.

##### Образец

 шаблон<класс T>
 auto square (T t) { return t * t; }

##### Принуждение

- Это невозможно.

### <a name= "Rf-unused" ><a name= "Rf-unused">< / a > F. 9: неиспользуемые параметры должны быть безымянными

##### Причина

Удобочитаемость.
Подавление предупреждений о неиспользуемых параметрах.

##### Образец

 X * find(map<Blob>& m, const string& s, Hint); / / однажды была использована подсказка

##### Записка

Разрешение неназванных параметров было введено в начале 1980-х годов для решения этой проблемы.

##### Принуждение

Флаг с именем неиспользуемые параметры.

## <a name= "SS-call" ><a name= "SS-call" >< / a>F. вызов: передача параметров

Существует множество способов передачи параметров в функцию и возврата значений.

### <a name= "Rf-conventional" ><a name= "Rf-conventional">< / a > F. 15: предпочитайте простые и обычные способы передачи информации

##### Причина

Использование "необычных и умных" методов вызывает сюрпризы, замедляет понимание другими программистами и поощряет ошибки.
Если вы действительно чувствуете потребность в оптимизации за пределами обычных методов, измерьте, чтобы убедиться, что это действительно улучшение, и документ/комментарий, потому что улучшение не может быть переносимым.

В нижеследующих таблицах кратко излагаются рекомендации, содержащиеся в следующих руководящих принципах, F. 16-21.

Нормальная передача параметров:

![Обычная таблица передачи параметров] (./ парам-проходим-нормально.png " нормальная передача параметров")

Расширенный параметр передачи:

![Таблица передачи расширенных параметров] (./ парам-попутно-продвинутый.png " расширенный параметр передачи")

Используйте передовые методы только после демонстрации необходимости, и документ, который нужно в комментарии.

Для передачи последовательностей символов см. раздел [String] (#SS-string).

### <a name= "Rf-in" ><a name= "Rf-in" >< / a > F. 16: для параметров " in "передайте дешево скопированные типы по значению и другие по ссылке на' const`

##### Причина

Оба позволяют вызывающему объекту знать, что функция не будет изменять аргумент, и оба разрешают инициализацию с помощью rvalues.

То, что является" дешевым для копирования", зависит от архитектуры машины, но два или три слова (двойники, указатели, ссылки) обычно лучше всего передаются по значению.
Когда копирование дешево, ничто не сравнится с простотой и безопасностью копирования, и для небольших объектов (до двух или трех слов) это также быстрее, чем передача по ссылке, потому что это не требует дополнительного косвенного доступа к функции.

##### Образец

 void f1 (const string& s); / / OK: переход по ссылке на const; всегда дешево

 void f2 (строка s); / / плохо: потенциально дорого

 пустота f3(int x); / / OK: непревзойденный

 void f4 (const int& x); / / bad: накладные расходы при доступе в f4()

Для расширенного использования (только), где вам действительно нужно оптимизировать для rvalues, переданных в параметры " только для ввода:

* Если функция собирается безоговорочно перейти от аргумента, возьмите его по`&&'. Смотрите [F. 18] (#Rf-consume).
* Если функция собирается сохранить копию аргумента, в дополнение к передаче по 'const&' (для lvalues),
 добавьте перегрузку, которая передает параметр ПО ` & & `(для значений rvalues) и в теле ' std::переместить его к месту назначения. По существу, это перегружает "will-move-from"; см. [F. 18](#Rf-consume).
* В особых случаях, таких как несколько параметров "вход + копирование", рассмотрите возможность использования идеальной переадресации. Смотрите [F. 19] (#Rf-forward).

##### Образец

 int умножьте(int, int); / / просто введите ints, передайте значение

 // суффикс является только входным, но не таким дешевым, как int, проходите мимо const&
 string & concatenate(строка&, const string & suffix);

 void sink(unique_ptr<widget>); / / только ввод и перемещение владельца виджета

Избегайте "эзотерических методов", таких как:

* Передача аргументов как 'T&&' "для эффективности".
 Большинство слухов о преимуществах производительности от прохождения мимо `&&` являются ложными или хрупкими (но см. [F. 18](#Rf-consume) и [F. 19](#Rf-forward)).
* Возврат 'const T&' из назначений и аналогичных операций (см. [F. 47] (#Rf-assignment-op).)

##### Образец

Предполагая, что "матрица" имеет операции перемещения (возможно, сохраняя ее элементы в " std::vector`):

 Матричный оператор+(const Matrix& a, const Matrix& b)
 {
 Матрица res;
 // ... заполните res с суммой ...
 возврат res;
 }

 Матрица x = m1 + m2; / / конструктор перемещения

 y = m3 + m3; / / задание перемещения

##### Примечания

Оптимизация возвращаемого значения не обрабатывает случай присвоения, но назначение перемещения делает это.

Можно предположить, что ссылка относится к допустимому объекту (правилу языка).
Нет никакой (законной) "нулевой ссылки."
Если вам нужно понятие необязательного значения, используйте указатель " std:: optional "или специальное значение, используемое для обозначения" no value."

##### Принуждение

* (Simple) ((Foundation)) предупреждает, когда параметр, передаваемый по значению, имеет размер больше, чем `2*sizeof (void*)`.
 Вместо этого предложите использовать ссылку на `const`.
* (Simple) ((Foundation)) предупреждает, когда параметр, передаваемый по ссылке на `const`, имеет размер меньше, чем `2*sizeof (void*)`. Вместо этого предложите передать значение.
* (Simple) ((Foundation)) предупреждает, когда параметр, передаваемый по ссылке на `const`, является `move'd.

### <a name= "Rf-inout" ><a name= "Rf-inout" >< / a>F. 17: для параметров "in-out" передайте ссылку на не - ' const`

##### Причина

Это позволяет абонентам четко понимать, что объект предполагается изменить.

##### Образец

 void update (Record& r); // предположим, что обновление записывает в r

##### Записка

Аргумент` T& ' может передавать информацию как в функцию, так и из нее.
Таким образом, `T&` может быть параметром in-out. Это само по себе может быть проблемой и источником ошибок:

 void f (string& s)
 {
 s = "Нью-Йорк"; / / неочевидная ошибка
 }

 пустота g()
 {
 string buffer = ".................................";
 f (буфер);
 // ...
 }

Здесь Автор `g () `предоставляет буфер для` f ()`, чтобы заполнить, но` f () ' просто заменяет его (с несколько более высокой стоимостью, чем простая копия символов).
Плохая логическая ошибка может произойти, если писатель `g()` неверно принимает размер `буфера`.

##### Принуждение

* (Moderate) ((Foundation)) предупреждает о функциях относительно ссылки на не-`const` параметры, которые не делают *не* запись в них.
* (Simple) ((Foundation)) предупреждает, когда параметр non-`const`, передаваемый по ссылке, является " move'd.

### <a name= "Rf-consume" ><a name= "Rf-consume">< / a>F. 18: для параметров "will-move-from" пройдите мимо` X&& `и` std::move ' параметр

##### Причина

Это эффективно и устраняет ошибки на сайте вызова: 'X&&' привязывается к rvalues, что требует явного `std::move` на сайте вызова при передаче значения lvalue.

##### Образец

 void sink (vector<int>&& v) {//sink принимает право собственности на все, что принадлежит аргументу
 // обычно здесь могут быть const-доступы v
 store_somewhere(std:: move(v));
 // обычно больше не используется v здесь; он перемещается-от
 }

Обратите внимание, что` std::move(v) `позволяет` store_somewhere () `оставить` v ' в перемещенном состоянии.
[Это может быть опасно] (#Rc-move-semantic).


##### Исключение

Уникальные типы владельцев, доступные только для перемещения и дешевые для перемещения, такие как "unique_ptr", также могут передаваться по значению, которое проще записать и достигает того же эффекта. Переход по значению генерирует одну дополнительную (дешевую) операцию перемещения, но сначала предпочитает простоту и ясность.

Например:

 шаблон <класс T>
 void sink(std:: unique_ptr<T> p) {
 // use p ... возможно, std:: move (p) onward где-то еще
 } / / p уничтожается

##### Принуждение

* Отметьте все параметры 'X&& `(где` X `не является именем параметра типа шаблона), где тело функции использует их без`std::move'.
* Флаг доступа к перемещенным объектам.
* Не уходите условно от объектов

### <a name= "Rf-forward"><a name= "Rf-forward">< / a>F. 19: для параметров" forward "пройдите мимо` TP&& `и только` std::forward' параметр

##### Причина

Если объект должен быть передан в другой код и непосредственно не используется этой функцией, мы хотим сделать эту функцию агностической для аргумента `const`-ness и rvalue-ness.

В этом случае, и только в этом случае, сделайте параметр ' TP&&', где ' TP 'является параметром типа шаблона - это оба * игнорирует* и * сохраняет* 'const' - ness и rvalue-ness. Поэтому любой код, который использует `TP&&`, неявно объявляет, что он сам не заботится о переменной`const `-ness и rvalue-ness (потому что он игнорируется), но намеревается передать значение вперед в другой код, который заботится о`const ' -ness и rvalue-ness (потому что он сохраняется). При использовании в качестве параметра` TP&& ' безопасно, потому что любые временные объекты, передаваемые от вызывающего объекта, будут жить в течение всего времени вызова функции. Параметр типа 'TP&& `должен по существу всегда передаваться вперед через` std::forward' в теле функции.

##### Образец

 шаблон .. Параметр args>
 встроенный автоматический вызов(F f, Args&&... параметр args) {
 возврат f (forward<Args>(args)...);
 }

 ??? звонки ???

##### Принуждение

* Отметьте функцию, которая принимает параметр` TP&& '(где 'TP ` - это имя параметра типа шаблона) и делает с ним что-либо, кроме 'std::forward', передавая его ровно один раз на каждом статическом пути.

### <a name= "Rf-out" ><a name= "Rf-out" >< / a>F. 20: для выходных значений" out " предпочтите возвращаемые значения выходным параметрам

##### Причина

Возвращаемое значение является самодокументирующим, в то время как `&` может быть либо входящим, либо только выходящим и может быть неправильно использовано.

Это включает в себя большие объекты, такие как стандартные контейнеры, которые используют неявные операции перемещения для повышения производительности и во избежание явного управления памятью.

Если у вас есть несколько значений для возврата, [используйте кортеж](#Rf-out-multi) или аналогичный многоместный тип.

##### Образец

 // OK: возврат указателей на элементы со значением x
 вектор<const int*> find_all(const vector<const int*><int>&, int x);

 // Плохо: размещение указателей на элементы со значением x in-out
 void find_all(const vector<int>&, vector<int><const int*>& out, int x);

##### Записка

"Структура" из многих (индивидуально дешевых для перемещения) элементов может быть в совокупности дорогой для перемещения.

Не рекомендуется возвращать значение 'const'.
Такие старые советы теперь устарели; они не добавляют ценности и мешают семантике перемещения.

 const vector<int > fct (); / / bad: то, что "const" - это больше проблем, чем стоит

 вектор<int > g(const vector<int > <int>& vx)
 {
 // ...
 fct () = vx; / / предотвращается "const"
 // ...
 return fct (); / / expensive copy: перемещение семантики, подавленной "const"
 }

Аргумент для добавления 'const' к возвращаемому значению состоит в том, что он предотвращает (очень редко) случайный доступ к временному значению.
Аргумент против is предотвращает (очень частое) использование семантики перемещения.

##### Исключения

* Для типов без значений, таких как типы в иерархии наследования, возвращают объект с помощью `unique_ptr` или `shared_ptr`.
* Если тип дорог для перемещения (например, `array<BigPOD>`), рассмотрите возможность выделения его в свободном хранилище и возврата дескриптора (например, `unique_ptr`), или передачи его в ссылке на не-`const` целевой объект для заполнения (который будет использоваться в качестве параметра out).
* Чтобы повторно использовать объект, несущий емкость (например, `std::string`, `std::vector`) при нескольких вызовах функции во внутреннем цикле: [рассматривать его как параметр in/out и передавать по ссылке] (#Rf-out-multi).

##### Образец

 пакет struct {//исключительный случай: дорогостоящий объект для перемещения
 заголовок char[16];
 нагрузка char[2024-16];
 };

 Package fill (); / / Bad: большое возвращаемое значение
 заполнение пустот (пакет&); / / OK

 int val (); / / OK
 void val(int&); / / плохо: читает ли вал свой аргумент

##### Принуждение

* Ссылка флага на не - 'const' параметры, которые не читаются перед записью и являются типом, который может быть возвращен дешево; они должны быть возвращенными значениями" out".
* Флаг, возвращающий значение 'const'. Чтобы исправить: удалите 'const`, чтобы вернуть не` const' значение вместо этого.

### <a name= "Rf-out-multi" ><a name= "Rf-out-multi">< / a > F. 21: чтобы вернуть несколько значений "out", предпочтите вернуть структуру или кортеж

##### Причина

Возвращаемое значение является самодокументируемым как" только выходное " значение.
Обратите внимание, что C++ действительно имеет несколько возвращаемых значений, по соглашению используя ' кортеж '(включая ' пару`),
возможно, с дополнительным удобством "галстук" на сайте вызова.
Предпочитайте использовать именованную структуру, где есть семантика возвращаемого значения. В противном случае, безымянный `кортеж` полезен в универсальном коде.

##### Образец

 // BAD: параметр только для вывода, задокументированный в комментарии
 int f(const string& input, / * output only* / string& output_data)
 {
 // ...
 output_data = что-то();
 возвращенный статус;
 }

 // Хорошо: самостоятельное документирование
 кортеж<int, string> f(const string& input)
 {
 // ...
 возврат make_tuple(статус, что-то());
 }

Стандартная библиотека C++98 уже использовала этот стиль, потому что "пара" похожа на двухэлементный "кортеж".
Например, учитывая 'set<string> my_set', рассмотрим:

 // C++98
 result = my_set.вставить ("Привет");
 если (результат.во-вторых) do_something_with (результат.во-первых); / / обходной путь

С помощью C++11 мы можем написать это, помещая результаты непосредственно в существующие локальные переменные:

 Sometype iter; / / инициализация по умолчанию, если мы еще не сделали этого
 Somethertype success; / / использовал эти переменные для какой-то другой цели

 tie (iter, success) = my_set.вставить ("Привет"); / / нормальное возвращаемое значение
 если (успех) do_something_with(iter);

С помощью C++17 мы можем использовать" структурированные привязки " для объявления и инициализации нескольких переменных:

 if (auto [ iter, success ] = my_set.insert ("Hello"); success) do_something_with(iter);

##### Исключение

Иногда нам нужно передать объект в функцию, чтобы управлять его состоянием.
В таких случаях передача объекта по ссылке ['T&'] (#Rf-inout) обычно является правильным методом.
Явная передача параметра in-out обратно в качестве возвращаемого значения часто не требуется.
Например:

 istream & operator>>>(istream& is, string& s); / / очень похоже на std:: operator>>>>>>()

 для (строка s; cin >>> s; ) {
 // сделайте что-нибудь с line
 }

Здесь и `s', и ' cin ' используются в качестве входных параметров.
Мы проходим` cin`мимо (не` const') ссылки, чтобы иметь возможность манипулировать его состоянием.
Мы передаем `s', чтобы избежать повторных распределений.
При повторном использовании `s `(передается по ссылке) мы выделяем новую память только тогда, когда нам нужно расширить ' S ' S емкость.
Этот метод иногда называют шаблоном" caller-allocated out " и особенно полезен для типов,
например, "строка" и "вектор", который должен делать свободные распределения магазина.

Для сравнения, если бы мы передали все значения как возвращаемые значения, мы бы что-то вроде этого:

 pair<istream&, string> get_string(istream & is); // не рекомендуется
 {
 строка s;
 is >>> s;
 возврат {is, s};
 }

 for (auto p = get_string(cin); p. первый; ) {
 // сделайте что-нибудь с p.second
 }

Мы считаем, что значительно менее элегантный с значительно меньшей производительностью.

Для действительно строгого чтения этого правила (F. 21) исключение на самом деле не является исключением, потому что оно зависит от параметров in-out,
вместо обычных параметров, упомянутых в правиле.
Однако мы предпочитаем быть откровенными, а не тонкими.

##### Записка

Во многих случаях может быть полезно вернуть определенный пользовательский тип.
Например:

 расстояние структуры {
 int значение;
 int unit = 1; / / 1 означает метры
 };

 Расстояние d1 = мера (obj1); / / доступ d1.значение и d1.единица измерения
 auto d2 = measure (obj2); / / access d2.значение и d2.единица измерения
 auto [value, unit] = мера (obj3); / / значение доступа и единица измерения; несколько избыточно
 // для людей, которые знают меру()
 auto [x, y] = measure(obj4); // не надо; скорее всего, это будет запутанно

Слишком общие "пара" и "Кортеж" должны использоваться только тогда, когда возвращаемое значение представляет независимые сущности, а не абстракцию.

Другой пример, используйте определенный тип вдоль строк ' variant<T, error_code>', а не используя общий `кортеж`.

##### Принуждение

* Выходные параметры должны быть заменены возвращаемыми значениями.
 Выходной параметр-это тот, в который функция выполняет запись, вызывает не-`const` функцию-член или передает как не - `const`.

### <a name= "Rf-ptr" ><a name= "Rf-ptr" >< / a > F. 22: используйте `T* ' или ' owner< / a><T * > для обозначения одного объекта

##### Причина

Читаемость: это делает значение простого указателя ясным.
Включает значительную поддержку инструмента.

##### Записка

В традиционном коде C и C++ простая буква "T*" используется для многих слабо связанных целей, таких как:

* Определите (единственный) объект (не подлежащий удалению с помощью этой функции)
* Укажите на объект, выделенный в свободном хранилище (и удалите его позже)
* Держите `nullptr`
* Определите строку C-типа (zero-terminated блок характеров)
* Определите массив с длиной, указанной отдельно
* Определение местоположения в массиве

Это затрудняет понимание того, что код делает и должен делать.
Это усложняет проверку и инструментальную поддержку.

##### Образец

 пустое использование(int * p, int n, char* s, int * q)
 {
 p[n-1] = 666; / / плохо: мы не знаем, указывает ли p на N элементов;
 // предположим, что он не использует или использует span<int>
 cout <;
 // предположим, что он не использует или использует zstring
 удалить q; / / плохо: мы не знаем, если *q выделяется на свободном магазине;
 // предположим, что это не так или использовать владельца
 }

лучше

 void use2(span<int> p, zstring s, owner<int > <int* > q)
 {
 p[p. размер() - 1] = 666; // хорошо, ошибка диапазона может быть поймана
 cout <
 удалить q; / / OK
 }

##### Записка

'owner<T*>' представляет собственность, 'zstring' представляет строку в стиле C.

**Также**: предположим, что `T*', полученный из интеллектуального указателя на `T `(например,` unique_ptr<T>'), указывает на один элемент.

** Смотрите также**: [библиотека поддержки](#S-gsl)

**Смотрите также**: [не передавайте массив в виде одного указателя] (#Ri-array)

##### Принуждение

* (Simple) ((Bounds)) предупреждение для любой арифметической операции над выражением типа указателя, которое приводит к значению типа указателя.

### <a name= "Rf-nullptr" ><a name= "Rf-nullptr" >< / a > F. 23: используйте 'not_null< / a><T>, чтобы указать, что" null " не является допустимым значением

##### Причина

Ясность. Функция с параметром` not_null<T > `ясно показывает, что вызывающий объект функции отвечает за любые проверки` nullptr', которые могут потребоваться.
Аналогично, функция с возвращаемым значением 'not_null<T > `дает понять, что вызывающему объекту функции не нужно проверять наличие`nullptr'.

##### Образец

'not_null<T*>' делает очевидным для читателя (человека или машины), что тест для `nullptr` не является необходимым перед разыменованием.
Кроме того, при отладке `owner<T*>` и `not_null<T*><T>` могут быть инструментированы для проверки правильности.

Считать:

 длина int(запись* p);

Когда я вызываю 'length (p)`, должен ли я проверить, является ли` p `сначала` nullptr'? Должна ли реализация 'length ()' проверять, является ли `p` `nullptr`?

 // это работа вызывающего абонента, чтобы убедиться, что p != nullptr
 int длина(not_null<запись* > p);

 // исполнитель length () должен предполагать, что P == nullptr возможен
 длина int(запись* p);

##### Записка

Предполагается, что "not_null<T*>" не является "nullptr"; "T*" может быть "nullptr"; оба могут быть представлены в памяти как "T*" (поэтому не подразумевается никаких накладных расходов во время выполнения).

##### Записка

'not_null' - это не только для встроенных указателей. Он работает для "unique_ptr", "shared_ptr" и других указательных типов.

##### Принуждение

* (Simple) предупреждает, что если необработанный указатель разыменован без проверки на `nullptr` (или эквивалент) в функции, вместо этого рекомендуется объявить `not_null`.
* (Простая) ошибка, если необработанный указатель иногда разыменовывается после первого тестирования против 'nullptr' (или эквивалента) внутри функции, а иногда и нет.
* (Простой) предупреждает, если указатель `not_null` проверяется против `nullptr` в функции.

### <a name= "Rf-диапазон"><a name= "Rf-диапазон">< / a > F. 24: используйте 'span< / a > <T>' или 'span_p<T > <T>' для обозначения полуоткрытой последовательности

##### Причина

Неформальные / неявные диапазоны являются источником ошибок.

##### Образец

 X * найти (span<X> r, const X& v); / / найти v в r

 вектор<X > vec;
 // ...
 auto p = найти({vec.begin (), vec.end ()}, X {}); / / Найти X{} в vec

##### Записка

Диапазоны чрезвычайно распространены в коде C++. Как правило, они подразумеваются, и их правильное использование очень трудно обеспечить.
В частности, учитывая пару аргументов `(p, n)`, обозначающих массив ' [p:p+n)`,
в общем случае невозможно узнать, действительно ли есть` n `элементов для доступа после`*p'.
'span<T>' и 'span_p<T><T>' - это простые вспомогательные классы, обозначающие диапазон` [p:q) `и диапазон, начинающийся с` p ' и заканчивающийся первым элементом, для которого предикат истинен соответственно.

##### Образец

"Пядь" представляет собой диапазон элементов, но как мы манипулируем элементами этого диапазона?

 void f (span<int> s)
 {
 // обход диапазона (гарантируется правильно)
 для (int x : s) cout << x <;

 // Обход в стиле C (потенциально проверено)
 для (gsl:: index i = 0; i < s.size (); ++i) cout << s[i] <;

 // произвольный доступ (потенциально проверено)
 s[7] = 9;

 // извлечь указатели (потенциально проверено)
 std:: сортировка (&s[0], &s[S. size () / 2]);
 }

##### Записка

Объект` span<T> ' не владеет своими элементами и настолько мал, что его можно передать по значению.

Передача объекта "span" в качестве аргумента точно так же эффективна, как передача пары аргументов указателя или передача указателя и целочисленного числа.

** Смотрите также**: [библиотека поддержки](#S-gsl)

##### Принуждение

(Комплекс) предупреждает, когда доступ к параметрам указателя ограничен другими параметрами, которые являются целыми типами, и предполагает, что они могут использовать вместо этого "span".

### <a name= "Rf-zstring" ><a name= "Rf-zstring">< / a>F. 25: используйте `zstring ' или 'not_null< / a><zstring>' для обозначения строки в стиле C

##### Причина

Строки в стиле C распространены повсеместно. Они определяются соглашением: массивы символов, заканчивающиеся нулем.
Мы должны отличать строки в стиле C от указателя на один символ или старомодного указателя на массив символов.

Если вам не нужно нулевое завершение, используйте 'string_view'.

##### Образец

Считать:

 int длина(const char* p);

Когда я вызываю 'length(s)`, должен ли я проверить, является ли` s `сначала` nullptr'? Должна ли реализация 'length ()' проверять, является ли `p` `nullptr`?

 // исполнитель length () должен предполагать, что P == nullptr возможен
 int длина(zstring p);

 // это работа вызывающего абонента, чтобы убедиться, что p != nullptr
 int длина(not_null<zstring> p);

##### Записка

`zstring ' не представляет собой право собственности.

** Смотрите также**: [библиотека поддержки](#S-gsl)

### <a name= "Rf-unique_ptr" ><a name= "Rf-unique_ptr" >< / a > F. 26: используйте ' unique_ptr< / a><T> для передачи права собственности там, где требуется указатель

##### Причина

Использование 'unique_ptr' является самым дешевым способом безопасно передать указатель.

**Смотрите также**: [C. 50] (#Rc-factory) о том, когда следует вернуть `shared_ptr` с завода.

##### Образец

 unique_ptr<Shape> get_shape(istream& is) / / соберите фигуру из входного потока
 {
 auto kind = read_header (is); / / чтение заголовка и определение следующей фигуры на входе
 переключатель (вид) {
 дело kCircle:
 возврат make_unique<Circle>(is);
 кейс kTriangle:
 возврат make_unique<треугольник > (is);
 // ...
 }
 }

##### Записка

Вы должны передать указатель, а не объект, если то, что вы передаете, является объектом из иерархии классов, которая должна использоваться через интерфейс (базовый класс).

##### Принуждение

(Простой) предупреждает, если функция возвращает локально выделенный необработанный указатель. Вместо этого рекомендуется использовать либо `unique_ptr`, либо `shared_ptr`.

### <a name= "Rf-shared_ptr" ><a name= "Rf-shared_ptr">< / a > F. 27: используйте ' shared_ptr< / a > <T> для совместного владения

##### Причина

Использование` std::shared_ptr ' является стандартным способом представления общего владения. То есть, последний владелец удаляет объект.

##### Образец

 shared_ptr<const Image > im { read_image (где-то) };

 std:: thread t0 {shade, args0, top_left, im};
 std:: thread t1 {shade, args1, top_right, im};
 std:: thread t2 {shade, args2, bottom_left, im};
 std:: thread t3 {shade, args3, bottom_right, im};

 // отсоединить резьбу
 // последний поток для завершения удаляет изображение

##### Записка

Предпочитайте "unique_ptr" над "shared_ptr", если никогда не существует более одного владельца одновременно.
'shared_ptr' - это общее владение.

Обратите внимание, что повсеместное использование `shared_ptr` имеет стоимость (атомарные операции над количеством ссылок `shared_ptr`имеют измеримую совокупную стоимость).

##### Альтернатива

Имейте один объект, владеющий общим объектом (например, объект с областью действия), и уничтожьте его (предпочтительно неявно), когда все пользователи завершат.

##### Принуждение

(Не подлежит исполнению) это слишком сложная модель, чтобы ее можно было надежно обнаружить.

### <a name= "Rf-ptr-ref" ><a name= "Rf-ptr-ref" >< / a>F. 60: предпочтение `T* ' над ' T&', когда" без аргумента " является допустимым вариантом

##### Причина

Указатель ('T*`) может быть` nullptr`и ссылка (`T&') не может, нет никакой допустимой "нулевой ссылки".
Иногда полезно иметь` nullptr 'в качестве альтернативы указанному "нет объекта", но если это не так, ссылка нотационно проще и может дать лучший код.

##### Образец

 строка zstring_to_string(zstring p) // zstring-это символ*; это строка в стиле C
 {
 если (!p) возвращаемая строка{}; // p может быть nullptr; не забудьте проверить
 возвращаемая строка{p};
 }

 void print (const vector<int>& r)
 {
 // r относится к вектору<int>; проверка не требуется
 }

##### Записка

Это возможно, но не допустимо C++, чтобы построить ссылку, которая по существу является `nullptr` (например, `T* p = nullptr; T& r = (T&)*p;).
Эта ошибка очень редка.

##### Записка

Если вы предпочитаете нотацию указателя (`- >'и/или ` * 'против'.`), 'not_null<T*>' предоставляет ту же гарантию, что и `T&`.

##### Принуждение

* Флаг ???

### <a name= "Rf-return-ptr" ><a name= "Rf-return-ptr">< / a > F. 42: верните A ' T*, чтобы указать позицию (только)

##### Причина

Вот для чего хороши указатели.
Возврат `T* ' для передачи права собственности является злоупотреблением.

##### Образец

 Node * find(Node* t, const string& s) / / найти s в двоичном дереве узлов
 {
 если (!t || t - >name == s) возврат t;
 если ((auto p = find (t->left, s))) возврат p;
 если ((auto p = find (t->right, s))) возврат p;
 возврат nullptr;
 }

Если это не `nullptr`, указатель, возвращенный `find', указывает на 'узел', удерживающий 's'.
Важно отметить, что это не означает передачу права собственности на объект, на который указывают, вызывающему абоненту.

##### Записка

Позиции также могут быть переданы итераторами, индексами и ссылками.
Ссылка часто является превосходной альтернативой указателю [если нет необходимости использовать 'nullptr'] (#Rf-ptr-ref) или [если объект, на который ссылаются, не должен меняться](???).

##### Записка

Не возвращайте указатель на что-то, что не находится в области действия вызывающего объекта; см. [F. 43](#Rf-dangle).

**Смотрите также**: [обсуждение предотвращения оборванных указателей] (#???)

##### Принуждение

* Флаг 'delete', 'std:: free ()' и др. приложенный к простому " T*".
Только владельцы должны быть удалены.
* Флаг 'new', 'malloc ()' и др. присваивается простой букве " Т*".
Только владельцы должны нести ответственность за удаление.

### <a name= "Rf-dangle" ><a name= "Rf-dangle">< / a > F. 43: никогда (прямо или косвенно) не возвращайте указатель или ссылку на локальный объект

##### Причина

Чтобы избежать сбоев и повреждения данных, которые могут возникнуть в результате использования такого висячего указателя.

##### Пример, плохо

После возврата функции ее локальные объекты больше не существуют:

 int* f()
 {
 int fx = 9;
 возврат &fx; / / плохо
 }

 void g(int* p) / / выглядит достаточно невинно
 {
 int gx;
 cout < < "*p = = " < < * p <;
 *p = 999;
 cout < < "gx = =" < < gx <;
 }

 пустота h()
 {
 int* p = f();
 int z = *p; / / чтение из заброшенного кадра стека (плохо)
 g (p); / / передайте указатель на заброшенный кадр стека для работы (плохо)
 }

Вот на одной популярной реализации я и получил свой выход:

 * p = = 999
 gx = = 999

Я ожидал этого, потому что вызов "g ()" повторно использует пространство стека, оставленное вызовом " f ()", поэтому "*p "относится к пространству, которое теперь занимает "gx".

* Представьте себе, что произошло бы, если бы `fx` и `gx` были разных типов.
* Представьте себе, что произошло бы, если бы " fx " или " gx " были типом с инвариантом.
* Представьте себе, что произошло бы, если бы больше этого висячего указателя передавалось между большим набором функций.
* Представьте себе, что взломщик может сделать с этой болтающейся указкой.

К счастью, большинство (все?) современные компиляторы ловят и предостерегают от этого простого случая.

##### Записка

Это относится и к ссылкам:

 int& f()
 {
 int x = 7;
 // ...
 return x; / / Bad: возвращает ссылку на объект, который должен быть уничтожен
 }

##### Записка

Это относится только к нестатическим локальным переменным.
Все "статические" переменные (как показывает их название) статически распределены, так что указатели на них не могут висеть.

##### Пример, плохо

Не все примеры утечки указателя на локальную переменную настолько очевидны:

 int* glob; / / глобальные переменные плохи во многих отношениях

 шаблон<класс T>
 пустота украсть(T x)
 {
 glob = x (); / / плохо
 }

 пустота f()
 {
 int i = 99;
 steal([&] { return &i; });
 }

 int main()
 {
 ф();
 cout < < * glob <;
 }

Здесь мне удалось прочитать местоположение, оставленное вызовом `f".
Указатель, сохраненный в 'glob', может быть использован гораздо позже и вызвать проблемы непредсказуемым образом.

##### Записка

Адрес локальной переменной может быть "возвращен" / утечка оператором return, out-параметром ' T&', как член возвращаемого объекта, как элемент возвращаемого массива и многое другое.

##### Записка

Подобные примеры можно построить "утечка" указателя из внутренней области видимости во внешнюю;
такие примеры обрабатываются аналогично утечкам указателей из функции.

Несколько иной вариант проблемы заключается в размещении указателей в контейнере, который переживает указанные объекты.

**Смотрите также**: еще один способ получения висячих указателей - это [аннулирование указателя](#???).
Его можно обнаружить / предотвратить с подобными методами.

##### Принуждение

* Компиляторы, как правило, перехватывают возврат ссылки на локальные объекты и во многих случаях могут перехватывать возврат указателей на локальные объекты.
* Статический анализ может уловить много общих картин пользы указателей показывая положения (таким образом исключающ оборванные указатели)

### <a name= "Rf-return-ref" ><a name= "Rf-return-ref">< / a>F. 44: возврат `T&', когда копирование нежелательно и "возврат без объекта" не требуется

##### Причина

Язык гарантирует, что `T&` относится к объекту, так что тестирование для `nullptr` не требуется.

** Смотрите также**: возвращение ссылки не должно подразумевать передачу права собственности:
[обсуждение предотвращения оборванных указателей] (#???) и [обсуждение права собственности] (#???).

##### Образец

 автомобиль класса
 {
 массив<колесо, 4 > Вт;
 // ...
 Публично:
 колесо& get_wheel (int i) { ожидает(i ]; }
 // ...
 };

 пустое использование()
 {
 Автомобиль c;
 колесо& w0 = c. get_wheel(0); / / W0 имеет тот же срок службы, что и c
 }

##### Принуждение

Флаговые функции, где никакое выражение` return ' не может дать `nullptr`

### <a name= "Rf-return-ref-ref" ><a name= "Rf-return-ref-ref" >< / a > F. 45: не возвращайте `T&&`

##### Причина

Он просит вернуть ссылку на уничтоженный временный объект.
A '& & ' - это магнит для временных объектов.

##### Образец

Возвращенная ссылка rvalue выходит за пределы области действия в конце полного выражения, в которое она возвращается:

 auto& & x = max(0, 1); / / OK, пока
 foo (x); / / неопределенное поведение

Этот вид использования является частым источником ошибок, часто неверно сообщается как ошибка компилятора.
Исполнитель функции должен избегать установки таких ловушек для пользователей.

[Профиль пожизненной безопасности] (#SS-lifetime) будет (при полной реализации) улавливать такие проблемы.


##### Образец

Возврат ссылки rvalue является прекрасным, когда ссылка на временное передается" вниз " вызываемому объекту;
затем временное значение гарантированно переживет вызов функции (см. [F. 18] (#Rf-consume) и [F. 19] (#Rf-forward)).
Однако это не нормально при передаче такой ссылки "вверх" к большей области вызывающего объекта.
Для функций passthrough, которые передают параметры (по обычной ссылке или совершенной пересылке) и хотят возвращать значения, используйте простой тип возврата "auto" (не " auto&&").

Предположим, что `F` возвращает значение:

 шаблон<класс F>
 авто & & обертка(F f)
 {
 log_call(typeid (f)); / / или любые другие инструменты
 return f (); / / BAD: возвращает ссылку на временный объект
 }

Лучше:

 шаблон<класс F>
 автоматическая завертчица(F f)
 {
 log_call(typeid (f)); / / или любые другие инструменты
 возврат f (); / / OK
 }


##### Исключение

'std:: move' и ' std:: forward` действительно возвращают `&&`, но они являются просто приведениями-используются соглашением только в контекстах выражения, где ссылка на временный объект передается в одном и том же выражении, прежде чем временное будет уничтожено. Мы не знаем ни одного другого хорошего примера возвращения`&&'.

##### Принуждение

Отметьте любое использование ` & & 'в качестве возвращаемого типа, за исключением' std:: move `и`std::forward'.

### <a name= "Rf-main" ><a name= "Rf-main" >< / a > F. 46: 'int' - это тип возврата для функции ' main()`

##### Причина

Это языковое правило, но оно нарушается через "расширение языка" так часто, что о нем стоит упомянуть.
Объявление "main" (одного глобального "main" программы) "void" ограничивает переносимость.

##### Образец

 void main() { /* ... * / }; / / плохо, не C++

 int main()
 {
 std:: cout <";
 }

##### Записка

Мы упоминаем об этом только из-за сохранения этой ошибки в сообществе.

##### Принуждение

* Компилятор должен это сделать
* Если компилятор не делает этого, пусть инструменты помечают его

### <a name= "Rf-assignment-op" ><a name= "Rf-assignment-op" >< / a > F. 47: возврат `T& ' от операторов присваивания

##### Причина

Конвенция для перегрузок операторов (особенно для типов значений) предназначена для
'operator=(const T&)' для выполнения задания и последующего возврата (не ' const`)
`*этот.` Это обеспечивает согласованность с типами стандартной библиотеки и следует за
принцип "делай так, как делают Инты."

##### Записка

Исторически существовали некоторые рекомендации, чтобы оператор присваивания возвращал ' const T&'.
Это было сделано прежде всего для того, чтобы избежать кода вида `(a = b) = c` - такой код не является достаточно распространенным, чтобы гарантировать нарушение согласованности со стандартными типами.

##### Образец

 класс Фу
 {
 Публично:
 ...
 Foo & operator=(const Foo & rhs) {
 // Копировать участников.
 ...
 возвращение *это;
 }
 };

##### Принуждение

Это должно быть применено инструментом путем проверки типа возврата (и возврата
значение) любого оператора присваивания.


### <a name= "Rf-return-move-local" >< / a > F. 48: Don't ' return std:: move(local)`

##### Причина

При гарантированном копировании elision теперь почти всегда пессимистично использовать `std::move` в обратном операторе.

##### Пример, плохо

 S f()
 {
 S результат;
 возврат std:: move(результат);
 }

##### Пример, хорошо

 S f()
 {
 S результат;
 возвращаемый результат;
 }

##### Принуждение

Это должно быть принудительно применено инструментом путем проверки возвращаемого выражения .


### <a name= "Rf-capture-vs-overload" ><a name= "Rf-capture-vs-overload">< / a > F. 50: используйте лямбду, когда функция не работает (для захвата локальных переменных или для записи локальной функции)

##### Причина

Функции не могут захватывать локальные переменные или определяться в локальной области; Если вам нужны эти вещи, предпочтите лямбда, где это возможно, и рукописный объект функции, где его нет. С другой стороны, объекты lambdas и function не перегружаются; если вам нужно перегружать, предпочтите функцию (обходные пути, чтобы сделать перегрузку lambdas, богато украшены). Если любой из них будет работать, предпочтите написать функцию; используйте самый простой инструмент, необходимый.

##### Образец

 // написание функции, которая должна принимать только int или строку
 // -- перегрузка естественна
 void f(int);
 void f (const string&);

 // запись объекта функции, который должен захватить локальное состояние и появиться
 // at оператор или область выражения -- a lambda является естественным
 вектор<работа > v = lots_of_work();
 для (int tasknum = 0; tasknum ) {
 Бассейн.run ([=, &v]{
 /*
 ...
 ... процесс 1 / max-й из v, tasknum-й кусок
 ...
 */
 });
 }
 Бассейн.Присоединиться();

##### Исключение

Общие лямбды предлагают краткий способ написания шаблонов функций и поэтому могут быть полезны, даже если обычный шаблон функции будет одинаково хорошо работать с немного большим синтаксисом. Это преимущество, вероятно, исчезнет в будущем, как только все функции получат возможность иметь параметры концепции.

##### Принуждение

* Предупреждать об использовании именованной непатентованной лямбды(например, `auto x = [] (int i){ /*...* / ;};`), который ничего не захватывает и появляется в глобальном масштабе. Вместо этого напишите обычную функцию.

### <a name= "Rf-default-args" ><a name= "Rf-default-args">< / a > F. 51: где есть выбор, предпочитайте аргументы по умолчанию с перегрузкой

##### Причина

Аргументы по умолчанию просто предоставляют альтернативные интерфейсы для одной реализации.
Нет никакой гарантии, что набор перегруженных функций реализует одну и ту же семантику.
Использование аргументов по умолчанию позволяет избежать репликации кода.

##### Записка

Существует выбор между использованием аргумента по умолчанию и перегрузкой, когда альтернативы находятся из набора аргументов одного и того же типа.
Например:

 void print(const string& s, формат f = {});

в отличие от

 void print (const string& s); / / использовать формат по умолчанию
 void print (const string& s, формат f);

Когда набор функций используется для выполнения семантически эквивалентной операции с набором типов, выбора не существует. Например:

 void print (const char&);
 void print(int);
 void print(zstring);

##### Смотреть также


[Аргументы по умолчанию для виртуальных функций] (#Rh-virtual-default-arg)

##### Принуждение

* Предупреждать о наборе перегрузок, где перегрузки имеют общий префикс параметров(например, `f(int)`, `f(int, const string&)`, `f (int, const string&, double)`). (Примечание: просмотрите это исполнение, если оно слишком шумно на практике.)

### <a name= "Rf-reference-capture" ><a name= "Rf-reference-capture">< / a > F. 52: предпочтите захват по ссылке в lambdas, которые будут использоваться локально, включая передаваемые алгоритмам

##### Причина

Для обеспечения эффективности и корректности, вы почти всегда хотите захватить по ссылке при использовании лямбда локально. Это включает в себя при написании или вызове параллельных алгоритмов, которые являются локальными, потому что они объединяются перед возвратом.

##### Обсуждение

Учет эффективности заключается в том, что большинство типов дешевле передать по ссылке, чем по стоимости.

Корректность рассмотрения заключается в том, что многие вызовы хотят выполнять побочные эффекты на исходный объект на сайте вызова (см. пример ниже). Переход по значению предотвращает это.

##### Записка

К сожалению, нет простого способа захватить по ссылке на 'const', чтобы получить эффективность для локального вызова, но и предотвратить побочные эффекты.

##### Образец

Здесь большой объект (сетевое сообщение) передается итерационному алгоритму, и он не является эффективным или правильным для копирования сообщения (которое может быть недоступно для копирования):

 std:: for_each (начало (сокеты), конец (сокеты), [&сообщение] (авто & сокет)
 {
 разъем.отправить сообщение);
 });

##### Образец

Это простой трехступенчатый параллельный трубопровод. Каждый объект "stage" инкапсулирует рабочий поток и очередь, имеет функцию "process" для постановки работы в очередь и в своем деструкторе автоматически блокирует ожидание освобождения очереди перед завершением потока.

 void send_packets(buffers& bufs)
 {
 этап encryptor ([] (buffer& b) { encrypt(b); });
 ступенчатый компрессор ([&] (буфер& b){ compress (b); шифратор.процесс(b); });
 декоратор сцены ([&] (буфер& b){ украсьте (b); компрессор.процесс(b); });
 для (auto& b: bufs) {декоратор.процесс(b); }
 } / / автоматически блокирует ожидание завершения конвейера

##### Принуждение

Отметьте лямбда-код, который захватывается по ссылке, но используется не локально в области действия функции или передается в функцию по ссылке. (Примечание: это правило является приближением, но делает флаг, передаваемый указателем, поскольку те, скорее всего, будут сохранены вызываемым объектом, записывая в место кучи, доступ к которому осуществляется через параметр, возвращая лямбду и т. д. Правила жизненного цикла также предоставляют общие правила, которые помечают экранирующие указатели и ссылки, в том числе через lambdas.)

### <a name= "Rf-value-capture" ><a name= "Rf-value-capture">< / a > F. 53: избегайте захвата по ссылке в lambdas, которые будут использоваться нелокально, включая возвращенные, сохраненные в куче или переданные в другой поток

##### Причина

Указатели и ссылки на местных жителей не должны выходить за их рамки. Лямбды, записываемые по ссылке, - это просто другое место для хранения ссылки на локальный объект, и не следует этого делать, если они (или копия) переживают область.

##### Пример, плохо

 int local = 42;

 // Требуется ссылка на local.
 // Обратите внимание, что после выхода программы из этой области,
 // local больше не существует, поэтому
 // process() вызов будет иметь неопределенное поведение!
 пул потоков.queue_work ([&] { process (local); });

##### Пример, хорошо

 int local = 42;
 // Нужна копия local.
 // Так как копия local сделана, она будет
 // всегда быть доступным для вызова.
 пул потоков.queue_work ([=] { process (local); });

##### Принуждение

* (Простой) предупреждать, когда capture-list содержит ссылку на локально объявленную переменную
* (Сложный) флаг, когда capture-list содержит ссылку на локально объявленную переменную, а лямбда передается в не-` const ' и нелокальный контекст

### <a name= "Rf-this-capture" ><a name= "Rf-this-capture">< / a > F. 54: Если вы записываете " это`, записывайте все переменные явно (без записи по умолчанию)

##### Причина

Это сбивает с толку. Запись ` [ = ] 'в функции-члене, по-видимому, захватывает значение, но на самом деле захватывает элементы данных по ссылке, потому что он фактически захватывает невидимый указатель "this" по значению. Если вы намеревались сделать это, напишите " это " явно.

##### Образец

 класс My_class {
 int x = 0;
 // ...

 пустота f() {
 int i = 0;
 // ...

 auto lambda = [ = ] { use(i, x);}; / / BAD: "looks like" copy / value capture
 // [ & ] имеет идентичную семантику и копирует указатель this в соответствии с текущими правилами
 // [=, это] и [&, это] не намного лучше, и сбивает с толку

 х = 42;
 lambda (); / / использование вызовов(0, 42);
 х = 43;
 lambda (); / / использование вызовов(0, 43);

 // ...

 auto lambda2 = [i, this] { use(i, x);}; / / ok, самый явный и наименее запутанный

 // ...
 }
 };

##### Записка

Этот вопрос активно обсуждается в рамках стандартизации и может быть рассмотрен в будущем варианте стандарта путем добавления нового режима захвата или, возможно, корректировки значения" [=]". А пока просто будьте откровенны.

##### Принуждение

* Флаг любой Lambda capture-список, который определяет захват по умолчанию, а также захватывает " это "(явно или через захват по умолчанию)

### <a name= "F-varargs" ><a name= "F-varargs" >< / a > F. 55: Не используйте аргументы `va_arg

##### Причина

Чтение из `va_arg ' предполагает, что правильный тип был фактически передан.
Переход к varargs предполагает, что будет прочитан правильный тип.
Это хрупко, потому что обычно его нельзя заставить быть безопасным в языке и поэтому полагается на дисциплину программиста, чтобы получить его правильно.

##### Образец

 int sum(...) {
 // ...
 время.*/( ..*/)
 result += va_arg(list, int); / / BAD, предполагает, что он будет передан ints
 // ...
 }

 sum(3, 2); / / ok
 sum(3.14159, 2.71828); / / плохо, неопределенно

 класс шаблона. ..Параметр args>
 auto sum(Args... args) {//хорошо, и гораздо более гибкий
 вернуть.( .. + args); / / Примечание: C++17 "сложите выражение"
 }

 sum(3, 2); / / ok: 5
 sum(3.14159, 2.71828); / / ok: ~5.85987

##### Альтернативы

* перегрузка
* вариативные шаблоны
* аргументы "варианта"
* 'initializer_list '(однородный)

##### Записка

Объявляя а'...'параметр иногда полезен для техник, которые не включают фактическую передачу аргумента, в частности, чтобы объявить функции "take-anything", чтобы отключить "все остальное" в наборе перегрузки или выразить общий случай в шаблоне метапрограммы.

##### Принуждение

* Выполните диагностику для использования `va_list`, `va_start`или 'va_arg'.
* Выполните диагностику для передачи аргумента параметру vararg функции, которая не предлагает перегрузку для более конкретного типа в позиции vararg. Чтобы исправить: используйте другую функцию или `[[подавление (типы)]]".

# <a name= "S-class" ><a name= "S-class" >< / a>C: классы и иерархии классов

Класс-это определяемый пользователем тип, для которого программист может определить представление, операции и интерфейсы.
Иерархии классов используются для организации связанных классов в иерархические структуры.

Сводка правил класса:

* [C. 1: Организация связанных данных в структуры ('struct или' class'es)] (#Rc-org)
* [C. 2: Используйте 'class', если класс имеет инвариант; используйте 'struct', если члены данных могут изменяться независимо] (#Rc-struct)
* [C. 3: представляет собой различие между интерфейсом и реализацией с использованием класса] (#Rc-интерфейс)
* [C. 4: сделать функцию членом только в том случае, если ей требуется прямой доступ к представлению класса] (#Rc-член)
* [C. 5: Поместите вспомогательные функции в то же пространство имен, что и класс, который они поддерживают] (#Rc-helper)
* [C. 7: не определяйте класс или перечисление и не объявляйте переменную его типа в одном и том же операторе] (#Rc-standalone)
* [C. 8: используйте 'class' вместо 'struct', если какой-либо член не является открытым] (#Rc-class)
* [C. 9: сведение к минимуму воздействия членов] (#Rc-private)

Подразделы:

* [C. бетон: типы бетона] (#SS-бетон)
* [C. ctor: конструкторы, назначения и деструкторы] (#s-ctor)
* [C. con: контейнеры и другие дескрипторы ресурсов] (#SS-containers)
* [C. лямбды: функциональные объекты и лямбды] (#SS-лямбды)
* [C. hier: Class hierarchies (OOP)] (#SS-hier)
* [C. over: перегрузка и перегруженные операторы] (#SS-перегрузка)
* [C. union: Unions] (#SS-union)

### <a name= "Rc-org" ><a name= "Rc-org" >< / a>C. 1: организуйте связанные данные в структуры ('struct или' class'es)

##### Причина

Легкость понимания.
Если данные связаны (по фундаментальным причинам), то этот факт должен быть отражен в коде.

##### Образец

 void draw(int x, int y, int x2, int y2); / / плохо: ненужные неявные отношения
 void draw(точка от, точка до); / / лучше

##### Записка

Простой класс без виртуальных функций не подразумевает никаких пространственных или временных накладных расходов.

##### Записка

С точки зрения языка 'class` и 'struct' различаются только видимостью своих членов по умолчанию.

##### Принуждение

Наверное, это невозможно. Возможно, возможен эвристический поиск элементов данных, используемых вместе.

### <a name= "Rc-struct" ><a name= "Rc-struct" >< / a>C. 2: Используйте 'class', если класс имеет инвариант; используйте 'struct', если члены данных могут изменяться независимо

##### Причина

Удобочитаемость.
Легкость понимания.
Использование "класса" предупреждает программиста о необходимости инварианта.
Это очень полезная конвенция.

##### Записка

Инвариант-это логическое условие для членов объекта, которое конструктор должен установить для предполагаемых функций-членов public.
После того, как инвариант установлен (обычно конструктором), каждая функция-член может быть вызвана для объекта.
Инвариант может быть сформулирован неофициально (например, в комментарии) или более формально, используя "ожидает".

Если все члены данных могут изменяться независимо друг от друга, то инвариант невозможен.

##### Образец

 struct Pair { // члены могут меняться независимо
 строковое имя;
 int volume;
 };

но:

 дата занятия {
 Публично:
 // проверьте, что {yy, mm, dd} является допустимой датой, и инициализируйте
 Дата(int yy, месяц mm, char dd);
 // ...
 Частное:
 int y;
 Месяц m;
 char d; / / day
 };

##### Записка

Если класс имеет какие-либо "частные" данные, пользователь не может полностью инициализировать объект без использования конструктора.
Следовательно, определитель класса предоставит конструктор и должен указать его значение.
Это фактически означает, что определитель должен определить инвариант.

**Смотреть также**:

* [определите класс с частными данными как 'class'] (#Rc-class)
* [Предпочтительно разместить интерфейс первым в классе] (#Rl-порядок)
* [минимизировать экспозицию участников] (#Rc-private)
* [Избегать 'защищенных' данных] (#Rh-protected)

##### Принуждение

Ищите 'struct со всеми закрытыми данными и' class'es с открытыми членами.

### <a name= "Rc-interface" ><a name= "Rc-interface" >< / a>C. 3: представляет собой различие между интерфейсом и реализацией с использованием класса

##### Причина

Явное различие между интерфейсом и реализацией улучшает читаемость и упрощает обслуживание.

##### Образец

 дата занятия {
 Публично:
 Дата();
 // проверьте, что {yy, mm, dd} является допустимой датой, и инициализируйте
 Дата(int yy, месяц mm, char dd);

 int day () const;
 Месяц month () const;
 // ...
 Частное:
 // ... какое-то представление ...
 };

Например, теперь мы можем изменить представление "даты", не затрагивая его пользователей (перекомпиляция, однако, вероятна).

##### Записка

Использование класса таким образом, чтобы представить различие между интерфейсом и реализацией, конечно, не единственный способ.
Например, мы можем использовать набор объявлений автономных функций в пространстве имен, абстрактном базовом классе или шаблонной функции с понятиями для представления интерфейса.
Самый важный вопрос заключается в том, чтобы явно различать интерфейс и его реализацию "детали."
В идеале, и обычно, интерфейс намного более стабилен, чем его реализация(ы).

##### Принуждение

???

### <a name= "Rc-member" ><a name= "Rc-member" >< / a>C. 4: Сделайте функцию членом только в том случае, если ей требуется прямой доступ к представлению класса

##### Причина

Меньше связей, чем с функциями-членами, меньше функций, которые могут вызвать проблемы путем изменения состояния объекта, уменьшает число функций, которые должны быть изменены после изменения представления.

##### Образец

 дата занятия {
 // ... относительно небольшой интерфейс ...
 };

 // вспомогательная функция:
 Дата next_weekday(дата);
 оператор bool==(дата, дата);

"Вспомогательные функции" не нуждаются в прямом доступе к представлению `даты`.

##### Записка

Это правило становится еще лучше, если C++ получает ["равномерный вызов функции"] (http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0251r0.pdf).

##### Исключение

Язык требует, чтобы "виртуальные" функции были членами, и не все "виртуальные" функции непосредственно обращаются к данным.
В частности, члены абстрактного класса редко это делают.

Примечание [мульти-методы](https://parasol.tamu.edu / ~yuriys / papers / OMM10. pdf).

##### Исключение

Язык требует операторов`=`, `()`, `[]`, и` ->', чтобы быть членами.

##### Исключение

Набор перегрузки может иметь некоторые члены, которые не имеют прямого доступа к "частным" данным:

 класс Foobar {
 Публично:
 void foo (long x) {/*управление личными данными */ }
 void foo (double x) { foo (std::lround(x)); }
 // ...
 Частное:
 // ...
 };

##### Исключение

Аналогично, набор функций может быть разработан для использования в цепочке:

 x. масштаб (0,5).поверните (45).set_color(Color:: red);

Как правило, некоторые, но не все из таких функций непосредственно обращаются к "частным" данным.

##### Принуждение

* Ищите не "виртуальные" функции-члены, которые не касаются непосредственно членов данных.
Загвоздка заключается в том, что многие функции-члены, которым не нужно непосредственно касаться элементов данных, делают это.
* Игнорируйте "виртуальные" функции.
* Игнорировать функции, которые являются частью перегрузочного набора, из которого по крайней мере одна функция обращается к "частным" членам.
* Игнорировать функции, возвращающие `это".

### <a name= "Rc-helper" ><a name= "Rc-helper">< / a>C. 5: Поместите вспомогательные функции в то же пространство имен, что и поддерживаемый ими класс

##### Причина

Вспомогательная функция-это функция (обычно предоставляемая автором класса), которая не нуждается в прямом доступе к представлению класса, но рассматривается как часть полезного интерфейса к классу.
Размещение их в том же пространстве имен, что и класс, делает их связь с классом очевидной и позволяет находить их с помощью поиска, зависящего от аргумента.

##### Образец

 namespace Chrono {//здесь мы сохраняем связанные со временем сервисы

 время занятий { /* ... */ };
 дата занятия { /* ... */ };

 // вспомогательная функция:
 оператор bool==(дата, дата);
 Дата next_weekday(дата);
 // ...
 }

##### Записка

Это особенно важно для [перегруженных операторов] (#Ro-пространство имен).

##### Принуждение

* Флаг глобальных функций, принимающих типы аргументов из одного пространства имен.

### <a name= "Rc-standalone" ><a name= "Rc-standalone">< / a>C. 7: не определяйте класс или перечисление и не объявляйте переменную его типа в одном и том же операторе

##### Причина

Смешивание определения типа и определения другого объекта в одном и том же объявлении является запутанным и ненужным.

##### Пример, плохо

 struct Data { /*...* / } data{ /*...*/ };

##### Пример, хорошо

 struct Data { /*...*/ };
 Data data{ /*...*/ };

##### Принуждение

* Флаг, если за`} ' определения класса или перечисления не следует`;'. Это"; " отсутствует.

### <a name= "Rc-class" ><a name= "Rc-class" >< / a>C. 8: используйте 'class' вместо 'struct', если какой-либо элемент не является общедоступным

##### Причина

Удобочитаемость.
Чтобы было ясно, что что-то скрывается/абстрагируется.
Это очень полезная конвенция.

##### Пример, плохо

 структурная дата {
 int d, m;

 Дата (int i, месяц m);
 // ... много функций ...
 Частное:
 int y; / / год
 };

Нет ничего плохого в этом коде, поскольку речь идет о правилах языка C++ ,
но почти все неправильно с точки зрения дизайна.
Личные данные скрыты далеко от общих данных.
Данные разделяются на различные части объявления класса.
Различные части данных имеют разный доступ.
Все это снижает читаемость и усложняет техническое обслуживание.

##### Записка

Предпочитайте размещать интерфейс первым в классе, [см. NL.16] (#RL-порядок).

##### Принуждение

Флаговые классы объявляются с помощью `struct`, если существует `private` или `protected` член.

### <a name= "Rc-private" ><a name= "Rc-private">< / a > C. 9: минимизация экспозиции участников

##### Причина

Инкапсуляция.
Сокрытие информации.
Сведите к минимуму вероятность непреднамеренного доступа.
Это упрощает техническое обслуживание.

##### Образец

 шаблон<typename T, typename U>
 структурная пара {
 Т а;
 U b;
 // ...
 };

Что бы мы ни делали в `//`-части, произвольный пользователь `пары` может произвольно и независимо изменять свои `а` и `в`.
В большой базе кода мы не можем легко найти, какой код делает то, что с членами "пары".
Это может быть именно то, что мы хотим, но если мы хотим навязать отношения между членами, нам нужно сделать их " частными`
и применять это отношение (инвариантное) через конструкторы и функции-члены.
Например:

 расстояние класса {
 Публично:
 // ...
 двойные метры () const { возвращенная величина * единица измерения; }
 void set_unit(double u)
 {
 // ... проверьте, что u-это коэффициент 10 ...
 // ... измените величину соответствующим образом ...
 единица измерения = u;
 }
 // ...
 Частное:
 двойная величина;
 двойной блок; / / 1 метры, 1000 километры, 0,001 миллиметра, etc.
 };

##### Записка

Если набор непосредственных пользователей набора переменных не может быть легко определен, тип или использование этого набора не может быть (легко) изменено/улучшено.
Для "публичных" и "защищенных" данных, как правило, это так.

##### Образец

Класс может предоставить своим пользователям два интерфейса.
Один для производных классов ('protected`) и один для обычных пользователей (`public').
Например, производному классу может быть разрешено пропустить проверку времени выполнения, поскольку он уже гарантировал правильность:

 класс Фу {
 Публично:
 int bar (int x) { check (x); return do_bar_ (x); }
 // ...
 защищенный:
 int do_bar_(int x); / / выполните некоторые операции с данными
 // ...
 Частное:
 // ... данные...
 };

 класс реж.: public Foo {
 //...
 int mem(int x, int y)
 {
 /* ... сделать нечто. .. */
 возврат do_bar(x + y); / / OK: производный класс может обойти проверку
 }
 };

 void user(Foo& x)
 {
 int r1 = X. bar(1); / / OK, проверим
 int r2 = x. do_bar_(2); / / ошибка: обойдет проверку
 // ...
 }

##### Записка

["защищенные" данные-это плохая идея] (#Rh-protected).

##### Записка

Предпочтите порядок 'public' членов перед 'protected' членов перед 'private' членов [см.] (#RL-порядок).

##### Принуждение

* [Данные, защищенные флагом] (#Rh-protected).
* Флаговые смеси "публичных" и частных " данных`

## <a name= "SS-concrete" ><a name= "SS-concrete" >< / a>C. бетон: типы бетона

Один идеал для класса должен быть регулярным типом.
Это означает примерно " ведет себя как `int`."Конкретный тип-это самый простой вид класса.
Значение обычного типа может быть скопировано, и результатом копирования является независимый объект с тем же значением, что и оригинал.
Если конкретный тип имеет оба ` = 'и'==`, `a = b` должно привести к тому, что `a == b`будет "истинным".
Конкретные классы без назначения и равенства могут быть определены, но они являются (и должны быть) редкими.
Встроенные типы C++ являются регулярными, а также классы стандартной библиотеки, такие как "строка", "вектор" и "карта".
Конкретные типы также часто называются типами значений, чтобы отличать их от типов, используемых в рамках иерархии.

Краткое описание правила конкретного типа:

* [C. 10: предпочтение конкретных типов над иерархиями классов] (#Rc-concrete)
* [C. 11: сделайте бетонные типы регулярными] (#Rc-регулярные)

### <a name= "Rc-concrete" ><a name= "Rc-concrete" >< / a > C. 10: предпочтение конкретных типов над иерархиями классов

##### Причина

Конкретный тип принципиально проще иерархии:
легче проектировать, легче внедрять, проще использовать, проще рассуждать, меньше и быстрее.
Вам нужна причина (варианты использования) для использования иерархии.

##### Образец

 класс Point1 {
 int x, y;
 // ... оперативный...
 // ... никаких виртуальных функций ...
 };

 класс Point2 {
 int x, y;
 // ... операции, некоторые виртуальные ...
 виртуальный ~Point2();
 };

 пустое использование()
 {
 Point1 p11 {1, 2}; / / сделать объект в стеке
 Point1 p12 {p11}; / / копия

 auto p21 = make_unique<Point2>(1, 2); / / сделать объект в свободном магазине
 auto p22 = p21 - >clone (); / / сделать копию
 // ...
 }

Если класс может быть частью иерархии, мы (в реальном коде, если не обязательно в небольших примерах) должны управлять его объектами с помощью указателей или ссылок.
Это означает больше затрат памяти, больше распределений и освобождений, а также больше затрат времени выполнения для выполнения результирующих косвенных действий.

##### Записка

Конкретные типы могут быть распределены стеком и быть членами других классов.

##### Записка

Использование косвенного обращения является фундаментальным для полиморфных интерфейсов времени выполнения.
Накладные расходы по распределению/освобождению не являются (это просто самый распространенный случай).
Мы можем использовать базовый класс в качестве интерфейса объекта с областью видимости производного класса.
Это делается там, где динамическое выделение запрещено (например, в режиме реального времени) и чтобы обеспечить стабильный интерфейс для некоторых видов плагинов.


##### Принуждение

???

### <a name= "Rc-regular" ><a name= "Rc-regular">< / a > C. 11: сделайте конкретные типы регулярными

##### Причина

Регулярные типы легче понять и рассуждать о них, чем типы, которые не являются регулярными (нерегулярности требуют дополнительных усилий для понимания и использования).

##### Образец

 структурный пучок {
 строковое имя;
 вектор<запись > vr;
 };

 оператор bool==(const Bundle& a, const Bundle& b)
 {
 возвращение a.name == b.name && a. vr = = b. vr;
 }

 Пучок b1 {"мой пучок", {r1, r2, r3}};
 Пучок b2 = b1;
 если (!(b1 == b2)) ошибка ("невозможно!");
 b2.name = " другая связка";
 если (b1 == b2) ошибка ("нет!");

В частности, если конкретный тип имеет назначение, также дайте ему равный оператор так, что` a = b `подразумевает`a == b'.

##### Записка

Дескрипторы для ресурсов, которые не могут быть клонированы, например, "scoped_lock" для "мьютекса", напоминают конкретные типы в том, что они чаще всего выделяются стеком.
Однако объекты таких типов обычно не могут быть скопированы (вместо этого они обычно могут быть перемещены),
поэтому они не могут быть "регулярными"; вместо этого они имеют тенденцию быть "полурегулярными".
Часто такие типы называются "только для перемещения типов".

##### Принуждение

???

## <a name= "S-ctor" ><a name= "S-ctor" >< / a > C. ctor: конструкторы, назначения и деструкторы

Эти функции управляют жизненным циклом объектов: создание, копирование, перемещение и уничтожение.
Определите конструкторы, гарантирующие и упрощающие инициализацию классов.

Это операции *по умолчанию*:

* конструктор по умолчанию: 'X()`
* конструктор копирования: 'X (const X&)`
* назначение копии: 'operator=(const X&)`
* конструктор перемещения: 'X(X&&)`
* назначение перемещения: 'operator=(X&&)`
* деструктор: '~X()`

По умолчанию компилятор определяет каждую из этих операций, если она используется, но значение по умолчанию может быть подавлено.

Операции по умолчанию - это набор связанных операций, которые совместно реализуют семантику жизненного цикла объекта.
По умолчанию C++ рассматривает классы как типы, подобные значениям, но не все типы являются такими же значениями.

Набор правил операций по умолчанию:

* [C. 20: если вы можете избежать определения каких-либо операций по умолчанию, сделайте] (#Rc-ноль)
* [C. 21: Если вы определяете или '=delete 'любую операцию по умолчанию, определите или` =delete' их все] (#Rc-five)
* [C. 22: сделайте операции по умолчанию согласованными] (#Rc-matched)

Правила деструктора:

* [C. 30: определите деструктор, если класс нуждается в явном действии при уничтожении объекта] (#Rc-dtor)
* [C. 31: все ресурсы, полученные классом, должны быть освобождены деструктором класса] (#Rc-dtor-release)
* [C. 32: Если класс имеет необработанный указатель (`T*`) или ссылку (`T&`), подумайте, может ли он быть владельцем] (#Rc-dtor-ptr)
* [C. 33: Если класс имеет член-указатель владельца, определите или` =delete ' деструктор] (#Rc-dtor-ptr2)
* [C. 35: деструктор базового класса должен быть либо общедоступным и виртуальным, либо защищенным и невиртуальным] (#Rc-dtor-virtual)
* [C. 36: деструктор не может отказать] (#Rc-dtor-fail)
* [C. 37: Make destructors 'noexcept'] (#Rc-dtor-noexcept)

Правила конструктора:

* [C. 40: определите конструктор, если класс имеет инвариант] (#Rc-ctor)
* [C. 41: конструктор должен создать полностью инициализированный объект] (#Rc-complete)
* [C. 42: Если конструктор не может построить допустимый объект, создайте исключение] (#Rc-throw)
* [C. 43: убедитесь, что копируемый класс (тип значения) имеет конструктор по умолчанию] (#Rc-default0)
* [C. 44: предпочитайте, чтобы конструкторы по умолчанию были простыми и не бросали] (#Rc-default00)
* [C. 45: не определяйте конструктор по умолчанию, который только инициализирует данные; вместо этого используйте инициализаторы членов](#Rc-default)
* [C. 46: по умолчанию объявите конструкторы с одним аргументом "явными"] (#Rc-явными)
* [C. 47: определение и инициализация переменных-членов в порядке объявления членов] (#Rc-порядок)
* [C. 48: предпочтите инициализаторы в классе инициализаторам членов в конструкторах для инициализаторов констант] (#Rc-in-class-initializer)
* [C. 49: предпочтение инициализации назначению в конструкторах] (#Rc-initialize)
* [C. 50: используйте заводскую функцию, если вам нужно" виртуальное поведение " во время инициализации] (#Rc-factory)
* [C. 51: использование делегирующих конструкторов для представления общих действий для всех конструкторов класса] (#Rc-делегирование)
* [C. 52: используйте наследование конструкторов для импорта конструкторов в производный класс, который не нуждается в дальнейшей явной инициализации] (#Rc-наследование)

Копирование и перемещение правил:

* [C. 60: сделайте назначение копии не 'виртуальным', возьмите параметр по 'const&' и возвратите по non - ' const&'] (#Rc-copy-assignment)
* [C. 61: операция копирования должна быть скопирована] (#Rc-copy-semantic)
* [C. 62: сделайте назначение копии безопасным для самостоятельного назначения] (#Rc-copy-self)
* [C. 63: Make move assignment non - 'virtual', take the parameter by`&&', and return by non - ' const&'] (#Rc-move-assignment)
* [C. 64: операция перемещения должна перемещаться и оставлять свой источник в допустимом состоянии] (#Rc-move-semantic)
* [C. 65: сделать назначение перемещения безопасным для самостоятельного назначения] (#Rc-move-self)
* [C. 66: выполнение операций перемещения 'noexcept'] (#Rc-move-noexcept)
* [C. 67: полиморфный класс должен подавлять копирование] (#Rc-copy-virtual)

Другие правила операций по умолчанию:

* [C. 80: используйте `=default', если вы должны явно использовать семантику по умолчанию] (#Rc-eqdefault)
* [C. 81: используйте `=delete', если вы хотите отключить поведение по умолчанию (без необходимости выбора альтернативы)] (#Rc-delete)
* [C. 82: не вызывайте виртуальные функции в конструкторах и деструкторах] (#Rc-ctor-virtual)
* [C. 83: для типов, подобных значению, рассмотрите возможность предоставления функции свопа 'noexcept'] (#Rc-swap)
* [C. 84: a 'swap' не может потерпеть неудачу] (#Rc-swap-fail)
* [C. 85: Make 'swap ''noexcept'] (#Rc-swap-noexcept)
* [C. 86: сделайте ` = = 'симметричным относительно типов операндов и 'noexcept'] (#Rc-eq)
* [C. 87: остерегайтесь ` = = ' на базовых классах] (#Rc-eq-base)
* [C. 89: сделайте 'hash ''noexcept'] (#Rc-hash)
* [C. 90: полагайтесь на конструкторы и операторы присваивания, а не на memset и memcpy] (#Rc-memset)

## <a name= "SS-defop" ><a name= "SS-defop" >< / a > C. defop: операции по умолчанию

По умолчанию язык предоставляет операции по умолчанию с их семантикой по умолчанию.
Однако программист может отключить или заменить эти значения по умолчанию.

### <a name= "Rc-zero" ><a name= "Rc-zero" >< / a>C. 20: если вы можете избежать определения операций по умолчанию, сделайте

##### Причина

Он самый простой и дает самую чистую семантику.

##### Образец

 структура Named_map {
 Публично:
 // ... операции по умолчанию не объявлены ...
 Частное:
 строковое имя;
 map<int, int > rep;
 };

 Named_map nm; / / конструкция по умолчанию
 Named_map nm2 {nm}; / / копировать конструкцию

Поскольку 'std:: map` и 'string' имеют все специальные функции, никакой дальнейшей работы не требуется.

##### Записка

Это известно как"правило нуля".

##### Принуждение

(Не подлежит исполнению) в то время как не подлежит исполнению, хороший статический анализатор может обнаружить шаблоны, которые указывают на возможное улучшение для удовлетворения этому правилу.
Например, класс с парой членов (указатель, размер) и деструктором, который "удаляет указатель", вероятно, может быть преобразован в "вектор".

### <a name= "Rc-five" ><a name= "Rc-five" >< / a>C. 21: Если вы определяете или `=delete` любую операцию по умолчанию, определите или '=delete ' их все

##### Причина

* Специальные функции-члены* являются конструктором по умолчанию, конструктор копирования,
скопируйте оператор присвоения, конструктор перемещения, оператор присвоения перемещения и
деструктор.

Семантика специальных функций тесно связана друг с другом, так что если один из них должен быть объявлен, то есть вероятность того, что другие тоже нуждаются в рассмотрении.

Объявление любой специальной функции-члена, кроме конструктора по умолчанию,
даже если `=default ' или '=delete', подавит неявное объявление
конструктора перемещения и оператора назначения перемещения.
Объявление конструктора перемещения или оператора назначения перемещения, даже как
'=default ' или '=delete', вызовет неявно созданный конструктор копий
или неявно сгенерированный оператор присвоения копии, который должен быть определен как удаленный.
Поэтому, как только какая-либо из специальных функций объявляется, остальные должны
все будет объявлено, чтобы избежать нежелательных эффектов, таких как поворот всех потенциальных движений
в более дорогих экземплярах, или сделать класс move-only.

##### Пример, плохо

 struct M2 {//bad: неполный набор операций по умолчанию
 Публично:
 // ...
 // ... никаких операций копирования или перемещения ...
 ~M2 () { удалить [] rep; }
 Частное:
 pair<int, int> * rep; / / нуль-терминированный набор пар
 };

 пустое использование()
 {
 M2 x;
 M2 y;
 // ...
 x = y; / / назначение по умолчанию
 // ...
 }

Учитывая, что" особое внимание " было необходимо для деструктора (здесь, чтобы освободить место), вероятность того, что копирование и перемещение назначения (оба будут неявно уничтожать объект) являются правильными, невелика (здесь мы получим двойное удаление).

##### Записка

Это известно как" правило пяти "или" правило шести", в зависимости от того, учитывается ли конструктор по умолчанию.

##### Записка

Если вы хотите реализовать операцию по умолчанию по умолчанию (при определении другой), напишите `=default", чтобы показать, что вы делаете это намеренно для этой функции.
Если вы не хотите использовать операцию по умолчанию, подавите ее с помощью `=delete'.

##### Пример, хорошо

Когда деструктор должен быть объявлен только для того, чтобы сделать его "виртуальным", он может быть
определено как дефолт. Чтобы избежать подавления неявных операций перемещения
они также должны быть объявлены, а затем, чтобы избежать превращения класса в move-only
(и не подлежит копированию) операции копирования должны быть объявлены:

 класс AbstractBase {
 Публично:
 virtual ~AbstractBase () = по умолчанию;
 AbstractBase (const AbstractBase&) = значение по умолчанию;
 Оператор AbstractBase & =(const AbstractBase&) = по умолчанию;
 AbstractBase (AbstractBase&&) = по умолчанию;
 Оператор AbstractBase& = (AbstractBase&&) = по умолчанию;
 };

Кроме того, чтобы предотвратить нарезку в соответствии с [C. 67] (#Rc-copy-virtual),
все операции копирования и перемещения можно удалить:

 класс ClonableBase {
 Публично:
 виртуальный unique_ptr<ClonableBase > clone () const;
 virtual ~ClonableBase () = по умолчанию;
 ClonableBase (const ClonableBase&) = удалить;
 ClonableBase & operator=(const ClonableBase&) = удалить;
 ClonableBase (ClonableBase&&) = удалить;
 ClonableBase & operator=(ClonableBase&&) = удалить;
 };

Определение только операций перемещения или только операций копирования будет иметь вид
тот же эффект здесь, но с указанием намерения явно для каждого специального члена
это делает его более очевидным для читателя.

##### Записка

Компиляторы применяют большую часть этого правила и в идеале предупреждают о любом нарушении.

##### Записка

Использование неявно созданной операции копирования в классе с деструктором не рекомендуется.

##### Записка

Запись шести специальных функций-членов может быть подвержена ошибкам.
Обратите внимание на их типы аргументов:

 класс X {
 Публично:
 // ...
 virtual ~X () = default; // деструктор (виртуальный, если X должен быть базовым классом)
 X (const X&) = по умолчанию; / / конструктор копий
 X & operator=(const X&) = default; / / copy assignment
 X (X&&) = по умолчанию; / / конструктор перемещения
 X & operator=(X&&) = default; / / переместить назначение
 };

Незначительная ошибка (например, неправильное написание, пропуск `const`, использование `&` вместо ` & & ` или пропуск специальной функции) может привести к ошибкам или предупреждениям.
Чтобы избежать скуки и возможности ошибок, старайтесь следовать [правилу нуля](#Rc-zero).

##### Принуждение

(Простой) класс должен иметь объявление (даже a` =delete ' one) для всех или ни для одной из специальных функций.

### <a name= "Rc-matched" ><a name= "Rc-matched">< / a>C. 22: сделайте операции по умолчанию согласованными

##### Причина

Операции по умолчанию являются концептуально согласованным набором. Их семантика взаимосвязана.
Пользователи будут удивлены, если конструкция копирования / перемещения и назначение копирования / перемещения делают логически разные вещи. Пользователи будут удивлены, если конструкторы и деструкторы не предоставляют согласованного представления об управлении ресурсами. Пользователи будут удивлены, если копирование и перемещение не отражают способ работы конструкторов и деструкторов.

##### Пример, плохо

 класс Silly {//BAD: несогласованные операции копирования
 класс Impl {
 // ...
 };
 shared_ptr<Impl > p;
 Публично:
 Silly (const Silly& a): p{a. p} { *p = *a. p;} / / deep copy
 Silly & operator=(const Silly& a) { p = a. p;} / / мелкая копия
 // ...
 };

Эти операции не согласуются с семантикой копирования. Это приведет к путанице и ошибкам.

##### Принуждение

* (Комплекс) конструктор копирования/перемещения и соответствующий оператор назначения копирования/перемещения должны выполнять запись в одни и те же переменные-члены на одном уровне разыменования.
* (Комплекс) любые переменные-члены, записанные в конструкторе копирования / перемещения, также должны быть инициализированы всеми другими конструкторами.
* (Комплекс)если конструктор копирования/перемещения выполняет глубокую копию переменной-члена, то деструктор должен изменить переменную-член.
* (Комплекс) если деструктор изменяет переменную-член, то эта переменная-член должна быть записана в любые конструкторы копирования/перемещения или операторы присваивания.

## <a name= "SS-dtor" ><a name= "SS-dtor" >< / a>C. dtor: деструкторы

-Нужен ли этому классу деструктор?"это удивительно мощный вопрос дизайна.
Для большинства классов ответ "нет" либо потому, что класс не содержит ресурсов, либо потому, что разрушение обрабатывается [правилом нуля](#Rc-zero);
то есть ее члены могут сами позаботиться о себе в том, что касается уничтожения.
Если ответ "да", то большая часть конструкции класса следует (см. [Правило пяти](#Rc-пять)).

### <a name= "Rc-dtor" ><a name= "Rc-dtor" >< / a > C. 30: определите деструктор, если класс нуждается в явном действии при уничтожении объекта

##### Причина

Деструктор неявно вызывается в конце жизненного цикла объекта.
Если деструктор по умолчанию достаточен, используйте его.
Определите деструктор не по умолчанию только в том случае, если классу необходимо выполнить код, который еще не является частью деструкторов его членов.

##### Образец

 шаблон<typename A>
 struct final_action {//слегка упрощенная
 Действие;
 final_action (A a): act{a} {}
 ~final_action () { act(); }
 };

 шаблон<typename A>
 final_action<A > finally (a act) / / вывод типа действия
 {
 возврат final_action<A > {act};
 }

 испытание на пустоту()
 {
 auto act = наконец ([] { cout <
 // ...
 если (что-то) вернется; / / действие сделано здесь
 // ...
 } / / действие сделано здесь

Вся цель 'final_action' состоит в том, чтобы получить кусок кода (обычно лямбда), выполненный при уничтожении.

##### Записка

Существует две общие категории классов, которым требуется определяемый пользователем деструктор:

* Класс с ресурсом, который еще не представлен в виде класса с деструктором, например, "вектор" или класс транзакций.
* Класс, который существует главным образом для выполнения действия при уничтожении, например трассировщик или `final_action`.

##### Пример, плохо

 класс Foo {//bad; используйте деструктор по умолчанию
 Публично:
 // ...
 ~Foo () { s = ""; i = 0; vi. clear ();} / / clean up
 Частное:
 строка s;
 int i;
 вектор<int > vi;
 };

Деструктор по умолчанию делает это лучше, более эффективно и не может ошибиться.

##### Записка

Если деструктор по умолчанию необходим, но его генерация была подавлена (например, путем определения конструктора перемещения), используйте `=default`.

##### Принуждение

Ищите вероятные "неявные ресурсы", такие как указатели и ссылки. Ищите классы с деструкторами, даже если все их члены данных имеют деструкторы.

### <a name= "Rc-dtor-release" ><a name= "Rc-dtor-release">< / a>C. 31: все ресурсы, полученные классом, должны быть освобождены деструктором класса

##### Причина

Предотвращение утечек ресурсов, особенно в случаях ошибок.

##### Записка

Для ресурсов, представленных в виде классов с полным набором операций по умолчанию, это происходит автоматически.

##### Образец

 класс X {
 ifstream f; / / может владеть файлом
 // ... операции по умолчанию не определены или =удалены ...
 };

`X `s 'ifstream' неявно закрывает любой файл, который он может открыть после уничтожения его 'X'.

##### Пример, плохо

 класс X2 {//плохо
 FILE* f; / / может иметь собственный файл
 // ... операции по умолчанию не определены или =удалены ...
 };

`X2 ' может привести к утечке дескриптора файла.

##### Записка

А как насчет розетки, которая не закроется? Операция деструктора, закрытия или очистки [никогда не должна завершаться ошибкой] (#Rc-dtor-fail).
Если это все же произойдет, у нас есть проблема, которая не имеет действительно хорошего решения.
Во-первых, автор деструктора не знает, почему деструктор вызван, и не может "отказаться действовать", создавая исключение.
Смотрите раздел [Обсуждение] (#Sd-never-fail).
Чтобы усугубить проблему, многие операции "закрыть / освободить"не могут быть повторены.
Многие пытались решить эту проблему, но общее решение не известно.
Если это вообще возможно, считайте, что сбой закрытия / очистки является фундаментальной ошибкой проектирования и завершается.

##### Записка

Класс может содержать указатели и ссылки на объекты, которые ему не принадлежат.
Очевидно, что такие объекты не должны быть удалены деструктором класса.
Например:

 Препроцессор pp { /* ... */ };
 Парсер p { pp,/*... */ };
 Type_checker tc { p,/* ... */ };

Здесь `p ' относится к `pp`, но не владеет им.

##### Принуждение

* (Простой) если класс имеет указатель или ссылочные переменные-члены, являющиеся владельцами
 (например, считается владельцем с помощью `gsl:: owner'), то они должны быть указаны в его деструкторе.
* (Трудно) определить, являются ли переменные-члены указателя или ссылки владельцами, когда нет явного заявления о собственности
 (например, посмотрите в конструкторы).

### <a name= "Rc-dtor-ptr" ><a name= "Rc-dtor-ptr" >< / a>C. 32: Если класс имеет необработанный указатель (`T*`) или ссылку (`T&`), подумайте, может ли он быть владельцем

##### Причина

Существует много кода, который не является конкретным о собственности.

##### Образец

 ???

##### Записка

Если `T* " или "T&" является владельцем, отметьте его "владение". Если `T* 'не является владельцем, рассмотрите возможность маркировки его 'ptr'.
Это будет способствовать документированию и анализу.

##### Принуждение

Посмотрите на инициализацию необработанных указателей элементов и ссылок на элементы и посмотрите, используется ли выделение.

### <a name= "Rc-dtor-ptr2" ><a name= "Rc-dtor-ptr2" >< / a > C. 33: Если класс имеет член-указатель владельца, определите деструктор

##### Причина

Принадлежащий объект должен быть "удален" при уничтожении объекта, которому он принадлежит.

##### Образец

Элемент указателя может представлять ресурс.
[A 'T*' не должен этого делать] (#Rr-ptr), но в более старом коде это распространено.
Рассмотрим `T* ' как возможного владельца и, следовательно, подозреваемого.

 шаблон<typename T>
 класс Smart_ptr {
 T* p; / / BAD: неопределенное владение *p
 // ...
 Публично:
 // ... никаких пользовательских операций по умолчанию ...
 };

 использование void(Smart_ptr<int> p1)
 {
 // ошибка: p2.P утечка (если не nullptr и не принадлежит какому-то другому коду)
 авто p2 = p1;
 }

Обратите внимание, что при определении деструктора необходимо определить или удалить [все операции по умолчанию] (#Rc-five):

 шаблон<typename T>
 класс Smart_ptr2 {
 T* p; / / BAD: неопределенное владение *p
 // ...
 Публично:
 // ... никаких пользовательских операций копирования ...
 ~Smart_ptr2 () { delete p;} / / p является владельцем!
 };

 использование void(Smart_ptr2<int> p1)
 {
 auto p2 = p1; / / ошибка: двойное удаление
 }

Операция копирования по умолчанию будет просто скопировать `p1.p ' в `p2.p ' приводит к двойному разрушению `p1.п'. Будьте откровенны о собственности:

 шаблон<typename T>
 класс Smart_ptr3 {
 owner<T*> p; / / OK: явное владение *p
 // ...
 Публично:
 // ...
 // ... копирование и перемещение операций ...
 ~Smart_ptr3 () { удалить p; }
 };

 использование void(Smart_ptr3<int> p1)
 {
 auto p2 = p1; / / OK: нет двойного удаления
 }

##### Записка

Часто самый простой способ получить деструктор-это заменить указатель на интеллектуальный указатель (например, "std::unique_ptr") и позволить компилятору неявно организовать надлежащее уничтожение.

##### Записка

Почему бы просто не потребовать, чтобы все указатели-владельцы были "умными указателями"?
Это иногда потребует нетривиальных изменений кода и может повлиять на ABIs.

##### Принуждение

* Класс с элементом данных указателя является подозрительным.
* Класс с 'owner<T >' должен определять свои операции по умолчанию.


### <a name= "Rc-dtor-virtual"><a name= "Rc-dtor-virtual">< / a > C. 35: деструктор базового класса должен быть либо общедоступным и виртуальным, либо защищенным и невиртуальным

##### Причина

Чтобы предотвратить неопределенное поведение.
Если деструктор является общедоступным, то вызывающий код может попытаться уничтожить производный объект класса с помощью указателя базового класса, и результат не определен, если деструктор базового класса не является виртуальным.
Если деструктор защищен, то вызывающий код не может быть уничтожен через указатель базового класса, и деструктор не должен быть виртуальным; он должен быть защищен, а не частным, чтобы производные деструкторы могли его вызывать.
В общем, автор базового класса не знает, какое соответствующее действие должно быть сделано при уничтожении.

##### Обсуждение

Смотрите [это в разделе Обсуждения] (#Sd-dtor).

##### Пример, плохо

 struct Base {//BAD: неявно имеет открытый невиртуальный деструктор
 виртуальная пустота f();
 };

 структура D: основание {
 строка s {"ресурс, нуждающийся в очистке"};
 ~D () { / * ... займись уборкой ... */ }
 // ...
 };

 пустое использование()
 {
 unique_ptr<Base > p = make_unique<Base > <D>();
 // ...
 } / / разрушение p вызывает ~Base (), а не ~D (), который протекает D:: s и, возможно, больше

##### Записка

Виртуальная функция определяет интерфейс к производным классам, который можно использовать, не глядя на производные классы.
Если интерфейс позволяет разрушать,это должно быть безопасно сделать.

##### Записка

Деструктор должен быть неприватизированным, иначе он не сможет использовать этот тип:

 класс X {
 ~X (); / / private destructor
 // ...
 };

 пустое использование()
 {
 X a; / / ошибка: не удается уничтожить
 auto p = make_unique<X > (); / / ошибка: не удается уничтожить
 }

##### Исключение

Мы можем представить себе один случай, когда вам может понадобиться защищенный виртуальный деструктор: когда объекту производного типа (и только такого типа) должно быть разрешено уничтожить *другой* объект (не сам по себе) через указатель на базу. Однако на практике мы не сталкивались с таким случаем.


##### Принуждение

* Класс с любыми виртуальными функциями должен иметь деструктор, который является либо общедоступным и виртуальным, либо защищенным и невиртуальным.

### <a name= "Rc-dtor-fail" ><a name= "Rc-dtor-fail">< / a > C. 36: деструктор не может завершиться ошибкой

##### Причина

Как правило, мы не знаем, как написать безошибочный код, если деструктор должен потерпеть неудачу.
Стандартная библиотека требует, чтобы все классы, с которыми она имеет дело, имели деструкторы, которые не выходят путем метания.

##### Образец

 класс X {
 Публично:
 ~X () noexcept;
 // ...
 };

 X::~X () noexcept
 {
 // ...
 если (cannot_release_a_resource) завершить();
 // ...
 }

##### Записка

Многие пытались разработать надежную схему для борьбы с отказами в деструкторах.
Никому не удалось придумать общую схему.
Это может быть реальная практическая проблема: например, как насчет сокета, который не закроется?
Автор деструктора не знает, почему деструктор вызван, и не может "отказаться действовать", бросив исключение.
Смотрите раздел [Обсуждение] (#Sd-never-fail).
Чтобы усугубить проблему, многие операции "закрыть / освободить"не могут быть повторены.
Если это вообще возможно, считайте, что сбой закрытия / очистки является фундаментальной ошибкой проектирования и завершается.

##### Записка

Объявите деструктор 'noexcept'. Это гарантирует, что он либо завершает нормально, либо завершает программу.

##### Записка

Если ресурс не может быть освобожден, и программа не может потерпеть неудачу, попробуйте сигнализировать об ошибке остальной части системы так или иначе
(может быть, даже изменив какое-то глобальное состояние и надеясь, что что-то заметит и сможет позаботиться о проблеме).
Полностью осознайте, что эта техника является специальной и подвержена ошибкам.
Рассмотрим пример "моя связь не будет закрываться".
Вероятно, на другом конце соединения есть проблема, и только часть кода, ответственная за оба конца соединения, может правильно решить эту проблему.
Деструктор может отправить сообщение (каким-то образом) в ответственную часть системы, считать, что соединение закрыто, и вернуться нормально.

##### Записка

Если деструктор использует операции, которые могут завершиться ошибкой, он может перехватывать исключения и в некоторых случаях все еще успешно завершать
(например, с помощью другого механизма очистки от того, который вызвал исключение).

##### Принуждение

(Простой) деструктор должен быть объявлен "noexcept", если он может бросить.

### <a name= "Rc-dtor-noexcept" ><a name= "Rc-dtor-noexcept" >< / a > C. 37: сделайте деструкторы ' noexcept`

##### Причина

 [Деструктор не может отказать] (#Rc-dtor-fail). Если деструктор пытается выйти с исключением, это плохая ошибка проектирования, и программа должна была бы завершиться.

##### Записка

Деструктор (определяемый пользователем или созданный компилятором) неявно объявляется "noexcept" (независимо от того, какой код находится в его теле), если все члены его класса имеют деструкторы "noexcept". Явным образом помечая деструкторы "noexcept", автор предупреждает, что деструктор становится неявно "noexcept(false)" через добавление или изменение члена класса.

##### Образец

Не все деструкторы являются noexcept по умолчанию; один бросающий элемент отравляет всю иерархию классов

 структура X {
 Детали x; / / случается иметь метательный деструктор
 // ...
 ~X () { } / / неявно noexcept (false); aka может бросить
 };

Поэтому, если вы сомневаетесь, объявите деструктор noexcept.

##### Записка

Почему бы тогда не объявить все деструкторы noexcept?
Потому что это во многих случаях-особенно в простых случаях-будет отвлекать беспорядок.

##### Принуждение

(Простой) деструктор должен быть объявлен "noexcept", если он может бросить.

## <a name= "SS-ctor" ><a name= "SS-ctor" >< / a>C. ctor: конструкторы

Конструктор определяет способ инициализации (построения) объекта.

### <a name= "Rc-ctor" ><a name= "Rc-ctor" >< / a > C. 40: определите конструктор, если класс имеет инвариант

##### Причина

Вот для чего нужны конструкторы.

##### Образец

 дата класса {//a Date представляет допустимую дату
 // в диапазоне с 1 января 1900 года по 31 декабря 2100 года
 Дата (int dd, int mm, int yy)
 :d{dd}, m{mm}, y{yy}
 {
 если (!is_valid (d, m, y)) бросьте Bad_date {}; / / принудительно инвариантный
 }
 // ...
 Частное:
 int d, m, y;
 };

Это часто хорошая идея, чтобы выразить инвариант в качестве "гарантирует" на конструкторе.

##### Записка

Конструктор может быть использован для удобства, даже если класс не имеет инварианта. Например:

 struct Rec {
 строка s;
 int i {0};
 Rec (const string& ss) : s{ss} {}
 Rec (int ii): i{ii} {}
 };

 Rec r1 {7};
 Rec r2 {"Foo bar"};

##### Записка

Правило списка инициализаторов C++11 устраняет необходимость во многих конструкторах. Например:

 структура Rec2{
 строка s;
 int i;
 Rec2 (const string& ss, int ii = 0): s{ss}, i{ii} {} / / избыточно
 };

 Rec2 r1 {"Foo", 7};
 Rec2 r2 {"бар"};

Конструктор` Rec2 ' является избыточным.
Кроме того, значение по умолчанию для `int` было бы лучше сделать в качестве инициализатора [члена](#Rc-in-class-initializer).

**Смотрите также**: [построить допустимый объект] (#Rc-complete) и [конструктор бросает] (#Rc-throw).

##### Принуждение

* Классы флагов с пользовательскими операциями копирования, но без конструктора (пользовательская копия является хорошим индикатором того, что класс имеет инвариант)

### <a name= "Rc-complete" ><a name= "Rc-complete" >< / a>C. 41: конструктор должен создать полностью инициализированный объект

##### Причина

Конструктор устанавливает инвариант для класса. Пользователь класса должен быть в состоянии предположить, что построенный объект может быть использован.

##### Пример, плохо

 класс X1 {
 Файл* f; / / вызов init () перед любой другой функцией
 // ...
 Публично:
 Х1() {}
 void init (); / / инициализировать f
 void read (); / / read from f
 // ...
 };

 пустота f()
 {
 X1 файл;
 файл.read (); / / авария или плохое чтение!
 // ...
 файл.init (); / / слишком поздно
 // ...
 }

Компиляторы не читают комментарии.

##### Исключение

Если допустимый объект не может быть удобно сконструирован конструктором, [используйте функцию фабрики] (#Rc-factory).

##### Принуждение

* (Простой) каждый конструктор должен инициализировать каждую переменную-член (либо явно, через делегирующий вызов ctor, либо через конструкцию по умолчанию).
* (Неизвестно) если у конструктора есть контракт "гарантирует", попробуйте проверить, выполняется ли он в качестве постусловия.

##### Записка

Если конструктор получает ресурс (чтобы создать допустимый объект), этот ресурс должен быть [выпущен деструктором](#Rc-dtor-release).
Идиома того, что конструкторы получают ресурсы, а деструкторы освобождают их, называется [RAII](#Rr-raii) ("приобретение ресурсов-это инициализация").

### <a name= "Rc-throw" ><a name= "Rc-throw">< / a>C. 42: Если конструктор не может построить допустимый объект, создайте исключение

##### Причина

Оставляя позади недопустимый объект напрашивается на неприятности.

##### Образец

 класс X2 {
 Файл* f;
 // ...
 Публично:
 X2 (const string& name)
 :f{fopen(name.c_str (), " r")}
 {
 если (!f) throw runtime_error {"не удалось открыть" + name};
 // ...
 }

 void read (); / / read from f
 // ...
 };

 пустота f()
 {
 X2 file {"Zeno"}; / / бросает, если файл не открыт
 файл.читать (); / / отлично
 // ...
 }

##### Пример, плохо

 класс X3 {//bad: конструктор оставляет недопустимый объект позади
 Файл* f; / / вызов is_valid() перед любой другой функцией
 bool действительно;
 // ...
 Публично:
 X3 (const string& name)
 :f{fopen(name.c_str ()," r")}, valid{false}
 {
 if (f) valid = true;
 // ...
 }

 bool is_valid () { return valid; }
 void read (); / / read from f
 // ...
 };

 пустота f()
 {
 X3 file {"Гераклиды"};
 файл.read (); / / авария или плохое чтение!
 // ...
 if (file. is_valid()) {
 файл.Читать();
 // ...
 }
 еще {
 // ... обработайте ошибку ...
 }
 // ...
 }

##### Записка

Для определения переменной (например, в стеке или в качестве элемента другого объекта) не существует явного вызова функции, из которого может быть возвращен код ошибки.
Оставляя недопустимый объект и полагаясь на то, что пользователи будут последовательно проверять функцию "is_valid ()" перед использованием, это утомительно, подвержено ошибкам и неэффективно.

##### Исключение

Существуют области, такие как некоторые жесткие системы реального времени (например, управление самолетом), где (без дополнительной инструментальной поддержки) обработка исключений недостаточно предсказуема с точки зрения времени.
Там должна быть использована техника ' is_valid ()'. В таких случаях проверьте` is_valid () ' последовательно и немедленно, чтобы имитировать [RAII](#Rr-raii).

##### Альтернатива

Если вы чувствуете соблазн использовать некоторую идиому "постконструктивной инициализации" или "двухэтапной инициализации", постарайтесь этого не делать.
Если вам действительно нужно, посмотрите на [заводские функции](#Rc-factory).

##### Записка

Одна из причин, по которой люди использовали функции `init()` вместо выполнения работы по инициализации в конструкторе, заключалась в том, чтобы избежать репликации кода.
[Делегирование конструкторов] (#Rc-делегирование) и [инициализация элемента по умолчанию] (#Rc-in-class-initializer) делают это лучше.
Другой причиной была задержка инициализации до тех пор, пока не потребуется объект; решение этой проблемы часто заключается в том, что [не объявлять переменную, пока она не будет правильно инициализирована] (#Res-init)

##### Принуждение

???

### <a name= "Rc-default0" ><a name= "Rc-default0" >< / a > C. 43: убедитесь, что копируемый класс (тип значения) имеет конструктор по умолчанию

##### Причина

Многие языковые и библиотечные средства используют конструкторы по умолчанию для инициализации своих элементов, например ' T A[10] `и`std::vector<T> v(10)'.
Конструктор по умолчанию часто упрощает задачу определения подходящего [перемещенного из состояния] (#???) для типа, который также можно скопировать.

##### Записка

A [value type] (#SS-concrete) - это класс, который можно скопировать (и обычно также сопоставить).
Это тесно связано с понятием регулярного типа из [EoP](http://elementsofprogramming.com/) и [Пало-Альто TR](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf).

##### Образец

 дата класса {//BAD: нет конструктора по умолчанию
 Публично:
 Дата (int dd, int mm, int yyyy);
 // ...
 };

 вектор<дата > vd1 (1000); / / здесь требуется дата по умолчанию
 вектор < дата> vd2(1000, дата{месяц:: октябрь, 7, 1885}); / / альтернатива

Конструктор по умолчанию генерируется автоматически только в том случае, если нет объявленного пользователем конструктора, поэтому инициализировать вектор " vd1 " в приведенном выше примере невозможно.
Отсутствие значения по умолчанию может вызвать сюрпризы для пользователей и затруднить его использование, поэтому, если его можно разумно определить, оно должно быть.

"Дата" выбрана для поощрения мысли:
Нет никакой" естественной " даты по умолчанию (Большой взрыв слишком далеко назад во времени, чтобы быть полезным для большинства людей), поэтому этот пример нетривиален.
'{0, 0, 0} 'не является допустимой датой в большинстве календарных систем, поэтому выбор этой даты будет представлять что-то вроде" Нан " с плавающей запятой.
Однако большинство реалистичных классов` Date ' имеют "первую дату" (например, 1 января 1970 года является популярным), поэтому по умолчанию обычно тривиально.

 дата занятия {
 Публично:
 Дата (int dd, int mm, int yyyy);
 Date () = default; / / [Смотрите также] (#Rc-default)
 // ...
 Частное:
 int dd = 1;
 int mm = 1;
 int yyyy = 1970;
 // ...
 };

 вектор<дата > vd1(1000);

##### Записка

Класс с членами, которые все имеют конструкторы по умолчанию неявно получает конструктор по умолчанию:

 структура X {
 строка s;
 вектор<int > v;
 };

 X x; / / означает X {{}, {}}; это пустая строка и пустой вектор

Будьте осторожны, чтобы встроенные типы не были построены должным образом по умолчанию:

 структура X {
 строка s;
 int i;
 };

 пустота f()
 {
 X x; / / x.s инициализируется в пустую строку; x. i неинициализируется

 cout << x. s < < '' < < x. i <;
 ++x. i;
 }

Статически выделенные объекты встроенных типов по умолчанию инициализируются до `0`, а локальные встроенные переменные-нет.
Будьте осторожны, что ваш компилятор может инициализировать локальные встроенные переменные по умолчанию, в то время как оптимизированная сборка не будет.
Таким образом, код, подобный приведенному выше примеру, может работать, но он зависит от неопределенного поведения.
Предполагая, что требуется инициализация, явная инициализация по умолчанию может помочь:

 структура X {
 строка s;
 int i {}; / / инициализация по умолчанию (до 0)
 };

##### Примечания

Классы, которые не имеют разумной конструкции по умолчанию, как правило, также не могут быть скопированы, поэтому они не подпадают под это руководство.

Например, базовый класс не является типом значения (базовые классы не должны быть копируемыми) и поэтому необязательно нуждается в конструкторе по умолчанию:

 // Shape является абстрактным базовым классом, а не копируемым типом значения.
 // Для этого может потребоваться или не требуется конструктор по умолчанию.
 форма конструкции {
 virtual void draw () = 0;
 virtual void rotate (int) = 0;
 // =удалить функции копирования и перемещения
 // ...
 };

Класс, который должен получить ресурс, предоставляемый вызывающей стороной, во время построения часто не может иметь конструктор по умолчанию, но он не подпадает под это руководство, потому что такой класс обычно не копируется в любом случае:

 // std:: lock_guard не является копируемым типом значения.
 // У него нет конструктора по умолчанию.
 lock_guard g {mx}; / / охраняйте мьютекс mx
 lock_guard g2; / / ошибка: ничего не защищает

Класс, имеющий "особое состояние", которое должно обрабатываться отдельно от других состояний функциями-членами или пользователями, вызывает дополнительную работу
(и, скорее всего, больше ошибок). Такой тип может естественным образом использовать специальное состояние в качестве построенного значения по умолчанию, независимо от того, является ли он копируемым:

 // std:: ofstream не является копируемым типом значения.
 // У него действительно есть конструктор по умолчанию
 / это сопровождается особым состоянием "не открыто".
 ofstream out {"Foobar"};
 // ...
 выход <);

Аналогичные типы специальных состояний, которые можно скопировать, например копируемые интеллектуальные указатели, имеющие специальное состояние "==nullptr", должны использовать специальное состояние в качестве своего значения по умолчанию.

Однако предпочтительно иметь конструктор по умолчанию по умолчанию к значимому состоянию, такому как ` std::string ` "" и `std::vector `{}.

##### Принуждение

* Классы флагов, которые копируются с помощью ` = ' без конструктора по умолчанию
* Классы флагов, которые сопоставимы с`==', но не могут быть скопированы


### <a name= "Rc-default00" ><a name= "Rc-default00" >< / a > C. 44: предпочитайте, чтобы конструкторы по умолчанию были простыми и не бросали

##### Причина

Возможность установить значение "по умолчанию" без операций, которые могут завершиться неудачей, упрощает обработку ошибок и рассуждения об операциях перемещения.

##### Пример, проблематично

 шаблон<typename T>
 // elem указывает на пробел-элемент elem, выделенный с помощью new
 класс Vector0 {
 Публично:
 Vector0 (): Vector0{0} {}
 Vector0 (int n): elem{new T[n]}, space{elem + n}, last{elem} {}
 // ...
 Частное:
 собственный < T*> элемент;
 T * пространство;
 T * последний;
 };

Это хорошо и вообще, но установка "Vector0" пустым после ошибки включает в себя выделение, которое может завершиться неудачей.
Кроме того, наличие вектора по умолчанию, представленного как " {new T[0], 0, 0}", кажется расточительным.
Например, 'Vector0<int> v[100]' стоит 100 распределений.

##### Образец

 шаблон<typename T>
 // elem-это nullptr или elem указывает на элемент space-elem, выделенный с помощью new
 класс Vector1 {
 Публично:
 // устанавливает представление в {nullptr, nullptr, nullptr}; не выбрасывает
 Vector1 () noexcept {}
 Vector1 (int n): elem{new T[n]}, space{elem + n}, last{elem} {}
 // ...
 Частное:
 собственный < T*> elem = nullptr;
 T * space = nullptr;
 T * last = nullptr;
 };

Использование ' {nullptr, nullptr, nullptr}` делает `Vector1{}` дешевым, но частным случаем и подразумевает проверки времени выполнения.
Установка пустого значения `Vector1` после обнаружения ошибки является тривиальной.

##### Принуждение

* Флаг бросая конструкторы по умолчанию

### <a name= "Rc-default" ><a name= "Rc-default" >< / a>C. 45: не определяйте конструктор по умолчанию, который только инициализирует члены данных; вместо этого используйте инициализаторы членов в классе

##### Причина

Использование инициализаторов членов в классе позволяет компилятору создать функцию для вас. Функция, сгенерированная компилятором, может быть более эффективной.

##### Пример, плохо

 класс X1 {//BAD: не использует инициализаторы членов
 строка s;
 int i;
 Публично:
 X1 (): s {"default"}, i{1} { }
 // ...
 };

##### Образец

 класс X2 {
 строка s = " default";
 int i = 1;
 Публично:
 // использовать конструктор по умолчанию, созданный компилятором
 // ...
 };

##### Принуждение

(Простой) конструктор по умолчанию должен делать больше, чем просто инициализировать переменные-члены с константами.

### <a name= "Rc-explicit" ><a name= "Rc-explicit">< / a>C. 46: по умолчанию объявите конструкторы с одним аргументом явными

##### Причина

Чтобы избежать непреднамеренных преобразований.

##### Пример, плохо

 строка класса {
 Публично:
 String (int); / / плохо
 // ...
 };

 Строка s = 10; / / сюрприз: строка размера 10

##### Исключение

Если вы действительно хотите неявное преобразование из типа аргумента конструктора в тип класса, не используйте`явный':

 классный комплекс {
 Публично:
 Комплекс (двойной d); / / OK: нам нужно преобразование из d в {d, 0}
 // ...
 };

 Комплекс z = 10.7; / / неудивительное преобразование

** Смотрите также**: [обсуждение неявных преобразований](#Ro-conversion)

##### Записка

Конструкторы копирования и перемещения не должны быть "явными", поскольку они не выполняют преобразования. Явные конструкторы копирования / перемещения затрудняют передачу и возврат по значению.

##### Принуждение

(Простые) конструкторы с одним аргументом должны быть объявлены "явными". Хорошие единичные аргументы, не являющиеся "явными" конструкторами, редко встречаются в большинстве баз кода. Предупреждайте обо всем, что не входит в "позитивный список".

### <a name= "Rc-order" ><a name= "Rc-order" >< / a > C. 47: определение и инициализация переменных-членов в порядке объявления членов

##### Причина

Чтобы свести к минимуму путаницу и ошибки. Это порядок, в котором происходит инициализация (независимо от порядка инициализаторов членов).

##### Пример, плохо

 класс Фу {
 int m1;
 int m2;
 Публично:
 Foo(int x): m2{x}, m1{++x} { } / / BAD: вводящий в заблуждение порядок инициализации
 // ...
 };

 Foo x(1); / / сюрприз: x. m1 = = x. m2 == 2

##### Принуждение

(Простой) список инициализаторов членов должен упоминать членов в том же порядке, в котором они объявлены.

** Смотрите также**: [обсуждение](#Sd-order)

### <a name= "Rc-in-class-initializer" ><a name= "Rc-in-class-initializer">< / a > C. 48: предпочитайте инициализаторы в классе инициализаторам членов в конструкторах для инициализаторов констант

##### Причина

Явно указывает, что одно и то же значение предполагается использовать во всех конструкторах. Избегает повторений. Во избежание проблемы обслуживания. Это приводит к самому короткому и наиболее эффективному коду.

##### Пример, плохо

 класс X {//плохо
 int i;
 строка s;
 int j;
 Публично:
 X (): i{666}, s {"qqq"} { } / / j неинициализирован
 X (int ii): i{ii} {} / / s - это"", а j-неинициализированный
 // ...
 };

Как специалист по сопровождению может знать, был ли `j` преднамеренно неинициализирован (вероятно, плохая идея в любом случае) и было ли это намеренно, чтобы дать `s` значение по умолчанию `""` в одном случае и `qqq` в другом (почти наверняка ошибка)? Проблема с `j ' (забыв инициализировать элемент) часто возникает, когда новый элемент добавляется к существующему классу.

##### Образец

 класс X2 {
 int i {666};
 строка s {"qqq"};
 int j {0};
 Публично:
 X2 () = default; / / все члены инициализируются до их значений по умолчанию
 X2 (int ii): i{ii} {} // s и j инициализированы по умолчанию
 // ...
 };

** Альтернатива**: мы можем получить часть преимуществ от аргументов по умолчанию для конструкторов, и это не редкость в более старом коде. Однако это менее явно, приводит к передаче большего количества аргументов и повторяется, когда существует более одного конструктора:

 класс X3 {//BAD: inexplicit, передача аргументов накладные расходы
 int i;
 строка s;
 int j;
 Публично:
 X3(int ii = 666, const string& ss = "qqq", int jj = 0)
 :i{ii}, s{ss}, j{jj} { } / / все члены инициализируются по умолчанию
 // ...
 };

##### Принуждение

* (Простой) каждый конструктор должен инициализировать каждую переменную-член (либо явно, через делегирующий вызов ctor, либо через конструкцию по умолчанию).
* (Простые) аргументы по умолчанию для конструкторов предполагают, что инициализатор в классе может быть более подходящим.

### <a name= "Rc-initialize" ><a name= "Rc-initialize">< / a>C. 49: предпочтение инициализации назначению в конструкторах

##### Причина

Инициализация явно указывает, что инициализация, а не назначение, выполняется и может быть более элегантной и эффективной. Предотвращает ошибки "use before set".

##### Пример, хорошо

 класс А {//хорошо
 строка s1;
 Публично:
 A (czstring p) : s1{p} { } / / хорошо: непосредственно построить (и C-строка явно именуется)
 // ...
 };

##### Пример, плохо

 класс B {//плохо
 строка s1;
 Публично:
 B (const char* p) { s1 = p;} / / BAD: конструктор по умолчанию с последующим назначением
 // ...
 };

 класс C {//некрасивый, он же очень плохой
 int* p;
 Публично:
 C () { cout <
 // ...
 };

##### Пример, еще лучше

Вместо этих 'const char*' мы могли бы использовать 'gsl:: string_span' или (в C++17) ' std:: string_view`
как [более общий способ представления аргументов для функции] (#Rstr-view):

 класс D {//хорошо
 строка s1;
 Публично:
 A (string_view v): s1{v} { } / / хорошо: непосредственно построить
 // ...
 };

### <a name= "Rc-factory" ><a name= "Rc-factory" >< / a > C. 50: используйте заводскую функцию, если вам нужно" виртуальное поведение " во время инициализации

##### Причина

Если состояние объекта базового класса должно зависеть от состояния производной части объекта, мы должны использовать виртуальную функцию (или эквивалент), минимизируя окно возможностей для неправильного использования несовершенно построенного объекта.

##### Записка

Возвращаемый тип фабрики обычно должен быть 'unique_ptr' по умолчанию; если некоторые виды использования являются общими, вызывающий может `переместить` `unique_ptr` в `shared_ptr`. Однако, если автор фабрики знает, что все применения возвращенного объекта будут общими, верните `shared_ptr` и используйте `make_shared` в теле, чтобы сохранить выделение.

##### Пример, плохо

 класс В {
 Публично:
 Б() {
 /* ... */
 f (); / / BAD: C. 82: не вызывайте виртуальные функции в конструкторах и деструкторах
 /* ... */
 }

 виртуальная пустота f () = 0;
 };

##### Образец

 класс В {
 защищенный:
 маркер класса {};

 Публично:
 явный B (токен) { / * ... * / } / / создайте несовершенно инициализированный объект
 виртуальная пустота f () = 0;

 шаблон<класс T>
 статический shared_ptr < T> create () / / интерфейс для создания общих объектов
 {
 auto p = make_shared<T > (typename T:: Token{});
 p - >post_initialize();
 возврат p;
 }

 защищенный:
 virtual void post_initialize () / / вызывается сразу после построения
 { /* ... * / f(); /* ... * / } / / Хорошо: виртуальная отправка безопасна
 };

 класс D: public B {//некоторый производный класс
 защищенный:
 маркер класса {};

 Публично:
 явный D (токен): B{ B::Token{} } {}
 void f () переопределение { /* ... */ };

 защищенный:
 шаблон<класс T>
 друг shared_ptr<T> B:: создать();
 };

 shared_ptr<D > p = D:: create<D > <D> (); / / создание объекта D

'make_shared' требует, чтобы конструктор был общедоступным. Требуя защищенного "токена" конструктор больше не может быть публично вызван, поэтому мы избегаем неполного построения объекта, выходящего в дикую природу.
Путем обеспечивать функцию фабрики " создает ()", мы делаем конструкцию (на свободном магазине) удобным.

##### Записка

Обычные фабричные функции распределяются по свободному магазину, а не по стеку или в окружающем объекте.

** Смотрите также**: [обсуждение](#Sd-factory)

### <a name= "Rc-delegating" ><a name= "Rc-delegating">< / a>C. 51: используйте делегирующие конструкторы для представления общих действий для всех конструкторов класса

##### Причина

Чтобы избежать повторения и случайных различий.

##### Пример, плохо

 класс дата {//плохо: повторяющийся
 int d;
 Месяц m;
 int y;
 Публично:
 Дата (int dd, месяц мм, год yy)
 :d{dd}, m{mm}, y{yy}
 { если (!допустимый (d, m, y)) бросок Bad_date{}; }

 Дата(int dd, месяц mm)
 :d{dd}, m{mm} y{current_year()}
 { если (!допустимый (d, m, y)) бросок Bad_date{}; }
 // ...
 };

Общее действие становится утомительным для написания и может случайно не быть общим.

##### Образец

 класс Date2 {
 int d;
 Месяц m;
 int y;
 Публично:
 Date2(int dd, месяц мм, год yy)
 :d{dd}, m{mm}, y{yy}
 { если (!допустимый (d, m, y)) бросок Bad_date{}; }

 Date2(int dd, месяц mm)
 :Date2{dd, mm, current_year()} {}
 // ...
 };

**Смотрите также**: если "повторное действие" является простой инициализацией, рассмотрите [инициализатор члена в классе](#Rc-in-class-initializer).

##### Принуждение

(Умеренный) ищите аналогичные тела конструктора.

### <a name= "Rc-наследование" ><a name= "Rc-наследование">< / a>C. 52: используйте наследование конструкторов для импорта конструкторов в производный класс, который не нуждается в дальнейшей явной инициализации

##### Причина

Если вам нужны эти конструкторы для производного класса, повторная реализация их утомительна и подвержена ошибкам.

##### Образец

'std:: vector' имеет много сложных конструкторов, поэтому, если я хочу свой собственный "вектор", я не хочу их переопределять:

 класс Rec {
 // ... данные и много хороших конструкторов ...
 };

 класс Опер: public Rec {
 использование Rec:: Rec;
 // ... нет элементов данных ...
 // ... много приятных функций полезности ...
 };

##### Пример, плохо

 struct Rec2 : public Rec {
 int x;
 использование Rec:: Rec;
 };

 Rec2 r {"foo", 7};
 int val = r. x; / / uninitialized

##### Принуждение

Убедитесь, что инициализирован каждый член производного класса.

## <a name= "SS-copy" ><a name= "SS-copy">< / a > C. copy: копировать и перемещать

Типы значений обычно должны быть доступны для копирования, но интерфейсы в иерархии классов-нет.
Дескрипторы ресурсов могут быть или не быть копируемыми.
Типы могут быть определены для перемещения по логическим, а также по причинам производительности.

### <a name= "Rc-copy-assignment" ><a name= "Rc-copy-assignment">< / a>C. 60: сделайте назначение копии не 'виртуальным', возьмите параметр по 'const&' и возвратите по non - ' const&

##### Причина

Это просто и эффективно. Если вы хотите оптимизировать для rvalues, предоставьте перегрузку, которая принимает ` & & ' (см. [F. 18] (#Rf-consume)).

##### Образец

 класс Фу {
 Публично:
 Foo & operator=(const Foo & x)
 {
 // Хорошо: нет необходимости проверять самоназначение (кроме производительности)
 auto tmp = x;
 swap(tmp); / / см. C. 83
 возвращение *это;
 }
 // ...
 };

 Фу а;
 Foo b;
 Foo f();

 a = b; / / присвоить значение lvalue: копировать
 a = f (); / / присвоить значение rvalue: потенциально переместить

##### Записка

Метод реализации "своп" предлагает [сильную гарантию] (#Abrahams01).

##### Образец

Но что делать, если вы можете получить значительно лучшую производительность, не делая временную копию? Рассмотрим простой "вектор", предназначенный для области, где назначение больших, равных по размеру "векторов" является общим. В этом случае копирование элементов, подразумеваемых методом реализации " свопа`, может привести к увеличению стоимости на порядок:

 шаблон<typename T>
 вектор класса {
 Публично:
 Вектор & оператор=(const вектор&);
 // ...
 Частное:
 T * elem;
 int sz;
 };

 Вектор & вектор:: оператор=(const Vector& a)
 {
 если (a.sz > sz) {
 // ... используйте технику подкачки, это не может быть лучше ...
 возвращение *это;
 }
 // ... скопируйте элементы sz из *A. elem в elem ...
 если (a.sz ) {
 // ... уничтожьте лишние элементы в *этом и отрегулируйте размер ...
 }
 возвращение *это;
 }

Записывая непосредственно на целевые элементы, мы получим только [основную гарантию] (#Abrahams01), а не сильную гарантию, предлагаемую методом "swap". Остерегайтесь [самостоятельного присвоения] (#Rc-copy-self).

** Альтернативы**: Если вы считаете, что вам нужен "виртуальный" оператор назначения, и понимаете, почему это очень проблематично, не называйте его " оператор=". Сделайте его именованной функцией, например " virtual void assign(const Foo&)".
Смотрите раздел [конструктор копирования vs. ' clone ()'] (#Rc-copy-virtual).

##### Принуждение

* (Простой) оператор присваивания не должен быть виртуальным. Здесь будут драконы!
* (Простой) оператор присваивания должен возвращать `T&', чтобы включить цепочку, а не альтернативные варианты, такие как `const T&`, которые мешают составлению и помещению объектов в контейнеры.
* (Умеренный) оператор присваивания должен (неявно или явным образом) вызывать все базовые операторы и операторы присваивания членов.
 Посмотрите на деструктор, чтобы определить, имеет ли тип семантику указателя или семантику значения.

### <a name= "Rc-copy-semantic"><a name= "Rc-copy-semantic">< / a > C. 61: операция копирования должна копировать

##### Причина

Это общепринятая семантика. После `x = y 'мы должны иметь `x == y'.
После копирования `x ' и ' y ' могут быть независимыми объектами (семантика значений, способ работы встроенных типов без указателей и типов стандартной библиотеки) или ссылаться на общий объект (семантика указателей, способ работы указателей).

##### Образец

 класс X {//OK: семантика значений
 Публично:
 Икс();
 X (const X&); / / копировать X
 void modify (); / / изменить значение X
 // ...
 ~X () { удалить[] p; }
 Частное:
 Т* р;
 int sz;
 };

 оператор bool==(const X& a, const X& b)
 {
 возвращение a.sz == b.sz & & равно (a. p, a.p + a.sz, b. p, b. p + b.sz);
 }

 X:: X (const X& a)
 :p{new T[a.sz]}, sz{a.sz}
 {
 копия (a. p, a. p + sz, p);
 }

 X x;
 X y = x;
 если (x != y) бросать плохо{};
 x. изменить();
 если (x == y) бросить плохо {}; / / принять семантику значения

##### Образец

 класс X2 {//OK: семантика указателя
 Публично:
 Х2();
 X2 (const X2&) = по умолчанию; / / мелкая копия
 ~X2 () = по умолчанию;
 void modify (); / / измените значение pointed-to
 // ...
 Частное:
 Т* р;
 int sz;
 };

 оператор bool==(const X2& a, const X2& b)
 {
 возвращение a.sz == b.sz & & a. p == b. p;
 }

 Х2 х;
 X2 y = x;
 если (x != y) бросать плохо{};
 x. изменить();
 если (x != y) бросок плохой {}; / / предположим, что семантика указателя

##### Записка

Предпочитайте семантику значений, если вы не создаете "умный указатель". Семантика значений-это самый простой способ рассуждать о том, что ожидают средства стандартной библиотеки.

##### Принуждение

(Не подлежит исполнению)

### <a name= "Rc-copy-self" ><a name= "Rc-copy-self">< / a > C. 62: сделайте назначение копии безопасным для самостоятельного назначения

##### Причина

Если `x = x 'изменяет значение `x', люди будут удивлены и возникнут плохие ошибки (часто включая утечки).

##### Образец

Контейнеры стандартн-архива регулируют собственн-назначение шикарно и эффективно:

 std:: vector<int > v = {3, 1, 4, 1, 5, 9};
 v = v;
 // значение v по-прежнему равно{3, 1, 4, 1, 5, 9}

##### Записка

Назначение по умолчанию, созданное из элементов, которые обрабатывают самоназначение, правильно обрабатывает самоназначение.

 конструкционный стержень {
 вектор<пара<int, int><int, int> > v;
 map<string, int> m;
 строка s;
 };

 Бар b;
 // ...
 b = b; / / правильно и эффективно

##### Записка

Вы можете справиться с самостоятельным назначением путем явного тестирования для самостоятельного назначения, но часто это быстрее и более элегантно, чтобы справиться без такого теста (например, [с помощью `swap`](#Rc-swap)).

 класс Фу {
 строка s;
 int i;
 Публично:
 Foo & operator=(const Foo& a);
 // ...
 };

 Foo& Foo:: operator=(const Foo& a) / / хорошо, но есть стоимость
 {
 если (this == &a) возвращает *this;
 s = a. s;
 i = a. i;
 возвращение *это;
 }

Это очевидно безопасно и, по-видимому, эффективно.
Однако что, если мы сделаем одно самостоятельное задание на миллион заданий?
Это около миллиона избыточных тестов (но поскольку ответ по существу всегда один и тот же, предсказатель ветвей компьютера будет угадывать правильно практически каждый раз).
Считать:

 Foo& Foo:: operator=(const Foo& a) / / проще, и, вероятно, намного лучше
 {
 s = a. s;
 i = a. i;
 возвращение *это;
 }

'std:: string' безопасен для самостоятельного присвоения, как и 'int'. Вся стоимость осуществляется за счет (редкого)случая самостоятельного присвоения.

##### Принуждение

(Простые) операторы присваивания не должны содержать шаблон " если (this == &a) return *this;"???

### <a name= "Rc-move-assignment" ><a name= "Rc-move-assignment">< / a>C. 63: сделайте Move assignment non - 'virtual`, возьмите параметр по ` & &' и вернитесь по non - ' const &

##### Причина

Это просто и эффективно.

** Смотрите**: [правило для копирования-присвоения] (#Rc-copy-assignment).

##### Принуждение

Эквивалентно тому, что делается для [copy-assignment](#Rc-copy-assignment).

* (Простой) оператор присваивания не должен быть виртуальным. Здесь будут драконы!
* (Простой) оператор присваивания должен возвращать `T&', чтобы включить цепочку, а не альтернативные варианты, такие как `const T&`, которые мешают составлению и помещению объектов в контейнеры.
* (Умеренный) оператор присваивания перемещения должен (неявно или явно) вызывать все операторы присваивания перемещения базы и члена.

### <a name= "Rc-move-semantic"><a name= "Rc-move-semantic">< / a > C. 64: операция перемещения должна перемещаться и оставлять свой источник в допустимом состоянии

##### Причина

Это общепринятая семантика.
После `y = std:: move (x)` значение `y` должно быть значением `x` имел и `x` должен быть в допустимом состоянии.

##### Образец

 шаблон<typename T>
 класс X {//OK: семантика значений
 Публично:
 Икс();
 X (X&& a) noexcept; / / move X
 void modify (); / / изменить значение X
 // ...
 ~X () { удалить[] p; }
 Частное:
 Т* р;
 int sz;
 };


 X:: X(X&& a)
 :p{a. p}, sz{a.sz} / / украсть представление
 {
 a. p = nullptr; / / установить значение " пустой"
 a.sz = 0;
 }

 пустое использование()
 {
 X x{};
 // ...
 X y = std:: move(x);
 x = X {}; / / OK
 } / / OK: x можно уничтожить

##### Записка

В идеале, это перемещение должно быть значением по умолчанию для данного типа.
Убедитесь, что если нет исключительно веской причины, чтобы этого не делать.
Однако не все типы имеют значение по умолчанию, и для некоторых типов установление значения по умолчанию может быть дорогостоящим.
Стандарт требует только, чтобы перемещенный объект можно было уничтожить.
Часто мы можем легко и дешево сделать лучше: стандартная библиотека предполагает, что ее можно назначить перемещаемому объекту.
Всегда оставляйте перемещенный объект в некотором (обязательно указанном) допустимом состоянии.

##### Записка

Если нет исключительно веской причины не делать этого, пусть `x = std::move(y); y = z;` работает с обычной семантикой.

##### Принуждение

(Не подлежит принудительному исполнению) Поиск назначений участникам в операции перемещения. Если имеется конструктор по умолчанию, сравните эти назначения с инициализациями в конструкторе по умолчанию.

### <a name= "Rc-move-self" ><a name= "Rc-move-self">< / a > C. 65: сделайте назначение перемещения безопасным для самостоятельного назначения

##### Причина

Если `x = x 'изменяет значение `x', люди будут удивлены и могут возникнуть плохие ошибки. Тем не менее, люди обычно не пишут непосредственно самоназначение, которое превращается в движение, но это может произойти. Однако 'std:: swap' реализуется с помощью операций перемещения, поэтому, если вы случайно сделаете " swap (a, b)", где " a " и " b " относятся к одному и тому же объекту, неспособность обрабатывать самостоятельное перемещение может быть серьезной и тонкой ошибкой.

##### Образец

 класс Фу {
 строка s;
 int i;
 Публично:
 Foo & operator=(Foo&& a);
 // ...
 };

 Foo& Foo:: operator=(Foo&& a) noexcept / / OK, но есть стоимость
 {
 если (this == &a) return *this; // эта строка является избыточной
 s = std:: move(a. s);
 i = a. i;
 возвращение *это;
 }

Один из миллиона аргументов против тестов "если (this == &a) return *this;" из обсуждения [self-assignment](#Rc-copy-self) еще более уместен для самостоятельного перемещения.

##### Записка

Нет никакого известного общего способа избежать теста "если (это == &a) возвратит *это;" для задания перемещения и все равно получить правильный ответ (т. е. после "x = x "значение" x " остается неизменным).

##### Записка

Стандарт ISO гарантирует только" допустимое, но неопределенное " состояние для контейнеров стандартной библиотеки. По-видимому, это не было проблемой в течение примерно 10 лет экспериментального и производственного использования. Пожалуйста, свяжитесь с редакцией, если вы найдете встречный пример. Правило здесь более осторожное и настаивает на полной безопасности.

##### Образец

Вот способ перемещения указателя без теста (представьте его как код в реализации назначения перемещения):

 // переходите от другого.ptr к этому->ptr
 T * temp = другое.запись ptr;
 Другие.ptr = nullptr;
 удалить ptr;
 ptr = темп;

##### Принуждение

* (Умеренный) в случае самостоятельного присвоения оператор присвоения перемещения не должен оставлять элементы указателя удержания объекта, которые были "удалены" или установлены в "nullptr".
* (Не подлежит принудительному исполнению) посмотрите на использование типов контейнеров стандартной библиотеки (ВКЛ. 'string') и считают их безопасными для обычных (не жизненно важных) применений.

### <a name= "Rc-move-noexcept" ><a name= "Rc-move-noexcept" >< / a > C. 66: выполнение операций перемещения ' noexcept`

##### Причина

Бросательный ход нарушает разумные предположения большинства людей.
Не-бросая движение будет использовано более эффективно стандартн-библиотекой и средствами языка.

##### Образец

 шаблон<typename T>
 вектор класса {
 Публично:
 Вектор (Vector&& a) noexcept: elem{a. elem}, sz{a.sz} { a.sz = 0; a. elem = nullptr; }
 Вектор & оператор=(Vector&& a) noexcept { elem = a. elem; sz = a.sz; a.sz = 0; a. elem = nullptr; }
 // ...
 Частное:
 T * elem;
 int sz;
 };

Эти операции не выбрасывают.

##### Пример, плохо

 шаблон<typename T>
 класс Vector2 {
 Публично:
 Vector2 (Vector2&& a) {*this = a;} / / просто используйте копию
 Vector2 & operator=(Vector2&& a) { *this = a;} / / просто используйте копию
 // ...
 Частное:
 T * elem;
 int sz;
 };

Этот 'Vector2' не просто неэффективен,но так как векторная копия требует выделения, он может бросить.

##### Принуждение

(Простой) операция перемещения должна быть помечена как "noexcept".

### <a name= "Rc-copy-virtual" ><a name= "Rc-copy-virtual">< / a > C. 67: полиморфный класс должен подавлять копирование

##### Причина

* Полиморфный класс* - это класс, который определяет или наследует по крайней мере одну виртуальную функцию. Вполне вероятно, что он будет использоваться в качестве базового класса для других производных классов с полиморфным поведением. Если он случайно передается по значению, с неявно созданным конструктором копирования и назначением, мы рискуем срезать: будет скопирована только базовая часть производного объекта, и полиморфное поведение будет повреждено.

##### Пример, плохо

 class B {//BAD: полиморфный базовый класс не подавляет копирование
 Публично:
 виртуальный символ m () { return 'B'; }
 // ... ничего о копировании операций, так что использует по умолчанию ...
 };

 класс D: public B {
 Публично:
 char M () override { return 'D'; }
 // ...
 };

 void f(B& b) {
 auto b2 = b; / / oops, срезает объект; b2.m () вернет 'B'
 }

 Д-р;
 f(d);

##### Образец

 class B {//GOOD: полиморфный класс подавляет копирование
 Публично:
 B (const B&) = исключить;
 Оператор B&=(const B&) = удалить;
 виртуальный символ m () { return 'B'; }
 // ...
 };

 класс D: public B {
 Публично:
 char M () override { return 'D'; }
 // ...
 };

 void f(B& b) {
 auto b2 = b; / / ok, компилятор обнаружит случайное копирование и запротестует
 }

 Д-р;
 f(d);

##### Записка

Если вам нужно создать глубокие копии полиморфных объектов, используйте функции ' clone ()': смотрите [C. 130](#Rh-copy).

##### Исключение

Классы, представляющие объекты исключения, должны быть как полиморфными, так и копируемыми.

##### Принуждение

* Отметьте полиморфный класс с помощью операции неотделенной копии.
* Отметьте назначение объектов полиморфного класса.

## C. другое: Другие правила работы по умолчанию

В дополнение к операциям, для которых язык предлагает реализации по умолчанию,
есть несколько операций, которые настолько фундаментальны, что для их определения необходимы ИТ-правила:
сравнения, "своп" и "хэш".

### <a name= "Rc-eqdefault" ><a name= "Rc-eqdefault" >< / a>C. 80: используйте `=default', если необходимо явно указать семантику по умолчанию

##### Причина

Компилятор, скорее всего, получит правильную семантику по умолчанию, и вы не можете реализовать эти функции лучше, чем компилятор.

##### Образец

 классометр {
 строковое сообщение;
 Публично:
 Tracer (const string& m): message{m} { cerr < < "ввод" < < сообщение <; }
 ~Tracer () { cerr < < "выход" < < сообщение <; }

 Tracer (const Tracer&) = по умолчанию;
 Tracer & operator=(const Tracer&) = по умолчанию;
 Tracer (Tracer&&) = по умолчанию;
 Tracer & operator=(Tracer&&) = по умолчанию;
 };

Поскольку мы определили деструктор, мы должны определить операции копирования и перемещения. `= Default ' - это лучший и самый простой способ сделать это.

##### Пример, плохо

 класс Tracer2 {
 строковое сообщение;
 Публично:
 Tracer2 (const string& m): message{m} { cerr < < "ввод" < < сообщение <; }
 ~Tracer2 () { cerr < < "выход" < < сообщение <; }

 Tracer2 (const Tracer2& a): сообщение{a. сообщение} {}
 Tracer2 & operator=(const Tracer2& a) { message = a. message; return *this; }
 Tracer2(Tracer2&& a): message{a. message} {}
 Tracer2 & operator=(Tracer2&& a) { message = a. message; return *this; }
 };

Выписывание тел операций копирования и перемещения является многословным, утомительным и подверженным ошибкам. Компилятор делает это лучше.

##### Принуждение

(Умеренный) тело специальной операции не должно иметь те же доступность и семантику, что и версия, сгенерированная компилятором, потому что это было бы избыточно

### <a name= "Rc-delete" ><a name= "Rc-delete" >< / a > C. 81: используйте `=delete', когда вы хотите отключить поведение по умолчанию (не требуя альтернативы)

##### Причина

В некоторых случаях операция по умолчанию нежелательна.

##### Образец

 класс Бессмертный {
 Публично:
 ~Immortal () = удалить; // не допускать разрушения
 // ...
 };

 пустое использование()
 {
 Бессмертный тьфу; / / ошибка: тьфу нельзя уничтожить
 Бессмертный* p = новый Бессмертный{};
 удалить p; / / ошибка: не удается уничтожить *p
 }

##### Образец

'Unique_ptr' может быть перемещен, но не скопирован. Для этого его операции копирования удаляются. Чтобы избежать копирования, необходимо `=удалить ' его операции копирования из lvalues:

 шаблон <класс T, класс D = default_delete<T > <T> > класс unique_ptr {
 Публично:
 // ...
 constexpr unique_ptr () noexcept;
 явный unique_ptr (указатель p) noexcept;
 // ...
 unique_ptr (unique_ptr&& u) noexcept; / / конструктор перемещения
 // ...
 unique_ptr (const unique_ptr&) = удалить; / / отключить копирование из lvalue
 // ...
 };

 unique_ptr<int > make (); / / сделать "что-то" и вернуть его путем перемещения

 пустота f()
 {
 unique_ptr<int> pi {};
 auto pi2 {pi}; / / ошибка: нет конструктора перемещения из lvalue
 auto pi3 {make ()}; / / OK, move: результатом make() является значение rvalue
 }

Обратите внимание, что удаленные функции должны быть общедоступными.

##### Принуждение

Исключение операции по умолчанию основано (должно быть) на требуемой семантике класса. Считайте такие классы подозрительными, но поддерживайте "позитивный список" классов, где человек утверждал, что семантика правильна.

### <a name= "Rc-ctor-virtual"><a name= "Rc-ctor-virtual">< / a > C. 82: не вызывайте виртуальные функции в конструкторах и деструкторах

##### Причина

Вызываемая функция будет принадлежать объекту, построенному до сих пор, а не возможно переопределяющей функции в производном классе.
Это может быть очень запутанным.
Хуже того, прямой или косвенный вызов неосуществленной чистой виртуальной функции из конструктора или деструктора приводит к неопределенному поведению.

##### Пример, плохо

 основание класса {
 Публично:
 виртуальный пробел f () = 0; / / не реализован
 virtual void g(); // реализовано с базовой версией
 virtual void h(); // реализовано с базовой версией
 virtual ~Base (); / / реализовано с базовой версией
 };

 производный класс: public Base {
 Публично:
 void G () переопределяет; / / обеспечивает производную реализацию
 void h () final; / / обеспечить производную реализацию

 Полученный()
 {
 // BAD: попытка вызова нереализованной виртуальной функции
 ф();

 // Плохо: позвоню производному:: g, не отправляйте дальше практически
 г();

 // Хорошо: явно укажите намерение вызывать только видимую версию
 Производные:: g();

 // хорошо, квалификация не требуется, h является окончательным
 х();
 }
 };

Обратите внимание, что вызов определенной явно определенной функции не является виртуальным вызовом, даже если эта функция является "виртуальной".

**Смотрите также* * [заводские функции] (#Rc-factory) для получения сведений о том, как достичь эффекта вызова производной функции класса без риска неопределенного поведения.

##### Записка

Нет ничего изначально неправильного в вызове виртуальных функций из конструкторов и деструкторов.
Семантика таких вызовов является типобезопасной.
Однако опыт показывает, что такие вызовы редко нужны, легко запутывают сопровождающих и становятся источником ошибок при использовании новичками.

##### Принуждение

* Флаговые вызовы виртуальных функций от конструкторов и деструкторов.

### <a name= "Rc-swap" ><a name= "Rc-swap" >< / a > C. 83: для типов, подобных значению, рассмотрите возможность предоставления функции подкачки ' noexcept

##### Причина

"Подкачка" может быть удобна для реализации ряда идиом, от плавного перемещения объектов вокруг к реализации назначения легко обеспечить гарантированную функцию фиксации, которая позволяет сильно ошибочный вызывающий код. Рассмотрите возможность использования swap для реализации назначения копирования с точки зрения построения копии. Смотрите также раздел [деструкторы, освобождение и замена не должны завершаться ошибкой] (#Re-never-fail).

##### Пример, хорошо

 класс Фу {
 Публично:
 void swap (Foo& rhs) noexcept
 {
 М1.своп(rhs.m1);
 std:: swap(m2, rhs.м2);
 }
 Частное:
 Бар m1;
 int m2;
 };

Предоставление функции "подкачки" без элементов в том же пространстве имен, что и ваш тип для удобства вызывающих абонентов.

 void swap(Foo& a, Foo& b)
 {
 a. обмен(b);
 }

##### Принуждение

* (Простой) класс без виртуальных функций должен иметь объявленную функцию-член 'swap'.
* (Простой) когда класс имеет функцию-член` swap', он должен быть объявлен `noexcept`.

### <a name= "Rc-swap-fail" ><a name= "Rc-swap-fail">< / a > C. 84: функция " swap` не может завершиться ошибкой

##### Причина

 "своп" широко используется способами, которые, как предполагается, никогда не потерпят неудачу, и программы не могут быть легко написаны для правильной работы при наличии неисправного "свопа". Контейнеры и алгоритмы стандартной библиотеки не будут работать правильно, если произойдет сбой подкачки типа элемента.

##### Пример, плохо

 void swap(My_vector& x, My_vector& y)
 {
 auto tmp = x; / / копирование элементов
 x = y;
 y = tmp;
 }

Это не просто медленно, но если выделение памяти происходит для элементов в "tmp", этот "своп" может бросить и сделает алгоритмы STL неудачными, если они используются с ними.

##### Принуждение

(Простой) когда класс имеет функцию-член` swap', он должен быть объявлен `noexcept`.

### <a name= "Rc-swap-noexcept" ><a name= "Rc-swap-noexcept" >< / a > C. 85: сделайте 'swap '' noexcept`

##### Причина

 [A 'swap' не может потерпеть неудачу] (#Rc-swap-fail).
Если "своп" пытается выйти с исключением, это плохая ошибка проектирования, и программа должна была бы завершиться.

##### Принуждение

(Простой) когда класс имеет функцию-член` swap', он должен быть объявлен `noexcept`.

### <a name= "Rc-eq" ><A name= "Rc-eq" >< / a > C. 86: сделайте ` = = 'симметричным относительно типов операндов и' noexcept`

##### Причина

Асимметричная обработка операндов вызывает удивление и является источником ошибок там, где возможны преобразования.
'==`является фундаментальной операцией, и программисты должны иметь возможность использовать ее, не опасаясь сбоя.

##### Образец

 структура X {
 строковое имя;
 int число;
 };

 оператор bool==(const X& a, const X& b) noexcept {
 возвращение a.name == b.name && a. number == b. number;
 }

##### Пример, плохо

 класс В {
 строковое имя;
 int число;
 оператор bool==(const B& a) const {
 возвращаемое имя == a.name & & number == a. number;
 }
 // ...
 };

Сравнение `B ' принимает преобразования для своего второго операнда, но не для первого.

##### Записка

Если класс имеет состояние сбоя, такое как `double` s 'NaN', есть соблазн сделать сравнение против броска состояния сбоя.
Альтернативой является сравнение двух состояний сбоя равными, и любое допустимое состояние сравнивается с ложным состоянием сбоя.

##### Записка

Это правило применяется ко всем обычным операторам сравнения:'!=`, `<`, `<=`, `>`, и еще ... `<=`, `>>=`.

##### Принуждение

* Флаг an ' operator== ()`, для которого типы аргументов отличаются; то же самое для других операторов сравнения: `!=`, `<`, `<=`, `>`, и еще ... `<=`, `>>=`.
* Флаг-член `operator==() ' s; то же самое для других операторов сравнения: `!=`, `<`, `<=`, `>`, и еще ... `<=`, `>>=`.

### <a name= "Rc-eq-base" ><a name= "Rc-eq-base" >< / a > C. 87: остерегайтесь ` = = ' на базовых классах

##### Причина

Это действительно трудно написать надежный и полезный ` = = ' для иерархии.

##### Пример, плохо

 класс В {
 строковое имя;
 int число;
 виртуальный оператор bool==(const B& a) const
 {
 возвращаемое имя == a.name & & number == a. number;
 }
 // ...
 };

Сравнение `B ' принимает преобразования для своего второго операнда, но не для первого.

 класс D: B {
 характер char;
 виртуальный оператор bool==(const D& a) const
 {
 возвращаемое имя == a.name && number == a. number & & character == a. character;
 }
 // ...
 };

 B b = ...
 D d = ...
 b == d; / / сравнивает имя и число, игнорирует символ d
 d = = b; / / ошибка: нет = = определено
 D d2;
 d == d2; / / сравнивает имя, число и символ
 B& b2 = d2;
 b2 == d; / / сравнивает имя и число, игнорирует символы d2 и d

Конечно, есть способы заставить ` = = ' работать в иерархии, но наивные подходы не масштабируются

##### Записка

Это правило применяется ко всем обычным операторам сравнения:'!=`, `<`, `<=`, `>`, и еще ... `<=`, `>>=`.

##### Принуждение

* Отметьте виртуальный оператор ' operator== ()'; то же самое для других операторов сравнения: `!=`, `<`, `<=`, `>`, и еще ... `<=`, `>>=`.

### <a name= "Rc-hash" ><a name= "Rc-hash" >< / a > C. 89: сделайте 'hash '' noexcept`

##### Причина

Пользователи хэшированных контейнеров используют хэш косвенно и не ожидают, что простой доступ будет брошен.
Это требование стандартной библиотеки.

##### Пример, плохо

 шаблон><
 struct hash<My_type > {//очень плохая специализация хэша
 использование result_type = size_t;
 использование argument_type = My_type;

 оператор size_t () (const My_type & x) const
 {
 size_t xs = X.s. размер();
 если (xs "
 возвращаемый хэш<size_t>() (X. S. size ()) ^ trim (x. s);
 }
 };

 int main()
 {
 unordered_map<My_type, int> m;
 My_type mt {"asdfg" };
 m[mt] = 7;
 cout << m[My_type {"asdfg"}] <;
 }

Если вам нужно определить специализацию "хэш", попробуйте просто разрешить ей сочетать специализации " хэш "стандартной библиотеки с" ^ " (xor).
Это, как правило, работает лучше, чем" ум " для неспециалистов.

##### Принуждение

* Флаг бросая ' hash'es.

### <a name= "Rc-memset" ><a name= "Rc-memset" >< / a>C. 90: полагайтесь на конструкторы и операторы присваивания, а не на` memset `и`memcpy'

##### Причина

Стандартный механизм C++ для построения экземпляра типа заключается в вызове его конструктора. Как указано в руководстве [C. 41] (#Rc-complete): конструктор должен создать полностью инициализированный объект. Никакой дополнительной инициализации, такой как `memcpy`, не требуется.
Тип предоставляет конструктор копирования и / или оператор назначения копирования, чтобы соответствующим образом создать копию класса, сохраняя инварианты типа. Использование memcpy для копирования нетривиально копируемого типа имеет неопределенное поведение. Часто это приводит к нарезке или повреждению данных.

##### Пример, хорошо

 основание конструкции
 {
 virtual void update () = 0;
 std:: shared_ptr<int > sp;
 };

 структура производная: публичная база
 {
 переопределение void update()  {}
 };

##### Пример, плохо

 void init (производный& a)
 {
 memset (&a, 0, sizeof (производный));
 }

Это тип-небезопасно и перезаписывает таблицу vtable.

##### Пример, плохо

 пустая копия(производная& a, производная& b)
 {
 memcpy(&a, &b, sizeof (производный));
 }

Это также небезопасно для типа и перезаписывает таблицу vtable.

##### Принуждение

* Флаг, передающий нетривиально-копируемый тип в `memset`или 'memcpy'. 

## <a name= "SS-containers" ><a name= "SS-containers" >< / a>C. con: контейнеры и другие дескрипторы ресурсов

Контейнер-это объект, содержащий последовательность объектов некоторого типа; ' std:: vector` - это архетипический контейнер.
Дескриптор ресурса-это класс, которому принадлежит ресурс;` std::vector ' - это типичный дескриптор ресурса; его ресурс-это его последовательность элементов.

Сводка правил контейнера:

* [C. 100: следуйте указаниям STL при определении контейнера] (#Rcon-stl)
* [C. 101: дайте семантику значения контейнера] (#Rcon-val)
* [C. 102: дайте операции перемещения контейнера] (#Rcon-перемещение)
* [C. 103: дайте контейнеру конструктор списка инициализаторов] (#Rcon-init)
* [C. 104: дайте контейнеру конструктор по умолчанию, который устанавливает его пустым] (#Rcon-пустой)
* ???
* [C. 109: если дескриптор ресурса имеет семантику указателя, укажите ` * 'и' ->'] (#Rcon-ptr)

**Смотрите также**: [Resources](#s-resource)


### <a name= "Rcon-stl" ><a name= "Rcon-stl" >< / a > C. 100: следуйте указаниям STL при определении контейнера

##### Причина

Контейнеры STL знакомы большинству программистов на C++ и имеют принципиально звуковой дизайн.

##### Записка

Есть, конечно, и другие принципиально звуковые стили дизайна, а иногда и причины, чтобы отойти от них
стиль стандартной библиотеки, но при отсутствии веской причины отличаться, он проще
и легче для обоих исполнителей и пользователей, чтобы следовать стандарту.

В частности, "std::vector" и "std::map" предоставляют полезные относительно простые модели.

##### Образец

 // упрощенный (например, без распределителей):

 шаблон<typename T>
 класс Sorted_vector {
 использование value_type = T;
 // ... типы итераторов ...

 Sorted_vector () = по умолчанию;
 Sorted_vector (initializer_list<T>); / / инициализатор-конструктор списков: сортировка и хранение
 Sorted_vector(const Sorted_vector&) = по умолчанию;
 Sorted_vector (Sorted_vector&&) = по умолчанию;
 Sorted_vector & operator=(const Sorted_vector&) = по умолчанию; / / назначение копирования
 Sorted_vector & operator=(Sorted_vector&&) = default; // переместить назначение
 ~Sorted_vector () = по умолчанию;

 Sorted_vector (const std:: vector<T>& v); / / хранить и сортировать
 Sorted_vector(std:: vector<T>&& v); / / сортировка и " украсть представление"

 const t & оператор [] (int i) const { return rep[i]; }
 // нет неконстрантного прямого доступа для сохранения порядка

 void push_back(const T&); / / вставить в нужное место (необязательно сзади)
 void push_back (T&&); // вставить в нужное место (необязательно сзади)

 // ... cbegin (), cend ()...
 Частное:
 std:: vector<T > rep; / / используйте std:: vector для хранения элементов
 };

 template<typename T> bool operator==(const Sorted_vector<typename T > <T>&, const Sorted_vector<T > <T>&);
 оператор template<typename T> bool!=(const Sorted_vector<T>&, const Sorted_vector<T > <T>&);
 // ...

Здесь стиль STL соблюдается, но не полностью.
В этом нет ничего необычного.
Предоставьте только столько функциональных возможностей, сколько имеет смысл для конкретного контейнера.
Ключ заключается в определении обычных конструкторов, назначений, деструкторов и итераторов
(как значимый для конкретного контейнера) с их условной семантикой.
От этого основания, контейнер можно расширить как необходим.
Здесь были добавлены специальные конструкторы из` std:: vector`.

##### Принуждение

???

### <a name= "Rcon-val" ><a name= "Rcon-val" >< / a > C. 101: задайте семантику значения контейнера

##### Причина

Правильные объекты проще осмыслить и осмыслить, чем неправильные.
Фамильярность.

##### Записка

Если это имеет смысл, сделайте контейнер "регулярным" (концепция).
В частности, убедитесь,что объект сравнивается с его копией.

##### Образец

 void f (const Sorted_vector<string>& v)
 {
 Sorted_vector<строка > v2 {v};
 если (v != v2)
 cout <\северный";
 // ...
 }

##### Принуждение

???

### <a name= "Rcon-move" ><a name= "Rcon-move">< / a > C. 102: дайте операции перемещения контейнера

##### Причина

Контейнеры, как правило, становятся большими; без конструктора перемещения и конструктора копирования объект может быть
дорого передвигаться, тем самым соблазняя людей передавать указатели на него вокруг и попадать внутрь
проблемы управления ресурсами.

##### Образец

 Sorted_vector<int> read_sorted(istream& is)
 {
 вектор<int > v;
 cin > > > v; / / предположим, что у нас есть операция чтения для векторов
 Sorted_vector<int > sv = v; / / сортировка
 возвращение sv;
 }

Пользователь может разумно предположить, что возврат стандартного контейнера является дешевым.

##### Принуждение

???

### <a name= "Rcon-init" ><a name= "Rcon-init" >< / a > C. 103: дайте контейнеру конструктор списка инициализаторов

##### Причина

Люди ожидают, что смогут инициализировать контейнер с набором значений.
Фамильярность.

##### Образец

 Sorted_vector<int > sv {1, 3, -1, 7, 0, 0}; // Sorted_vector сортирует элементы по мере необходимости

##### Принуждение

???

### <a name= "Rcon-empty" ><a name= "Rcon-empty">< / a > C. 104: дайте контейнеру конструктор по умолчанию, который устанавливает его пустым

##### Причина

Чтобы сделать его "регулярным".

##### Образец

 вектор<Sorted_sequence<string > <string> > vs (100); / / 100 Sorted_sequences каждый со значением ""

##### Принуждение

???

### <a name= "Rcon-ptr" ><a name= "Rcon-ptr" >< / a > C. 109: если дескриптор ресурса имеет семантику указателя, укажите ` * ' и ' - < / a>>`

##### Причина

Это то, что ожидается от указателей.
Фамильярность.

##### Образец

 ???

##### Принуждение

???

## <a name= "SS-lambdas" ><a name= "SS-lambdas">< / a>C. лямбды: функциональные объекты и лямбды

Объект функции-это объект, предоставляющий перегруженный ` ()', чтобы вы могли его вызвать.
Лямбда-выражение (в разговорном языке часто сокращенное до "лямбда") является обозначением для создания объекта функции.
Объекты функции должны быть дешевыми для копирования (и поэтому [передано по значению] (#Rf-in)).

Краткие сведения:

* [F. 50: используйте лямбду, когда функция не работает (для захвата локальных переменных или для записи локальной функции)] (#Rf-capture-vs-overload)
* [F. 52: предпочитайте захват по ссылке в lambdas, которые будут использоваться локально, включая передаваемые алгоритмам] (#Rf-reference-capture)
* [F. 53: избегайте захвата по ссылке в lambdas, которые будут использоваться нелокально, включая возвращенные, сохраненные в куче или переданные в другой поток] (#Rf-value-capture)
* [ES.28: используйте лямбды для комплексной инициализации, особенно переменных `const`] (#Res-lambda-init)

## <a name= "SS-hier" ><a name= "SS-hier" >< / a > C. hier: иерархии классов (OOP)

Иерархия классов строится для представления набора иерархически организованных понятий (только).
Обычно базовые классы действуют как интерфейсы.
Существует два основных способа использования иерархий, часто называемых наследованием реализации и наследованием интерфейса.

Сводка правил иерархии классов:

* [C. 120: используйте иерархии классов для представления концепций с присущей им иерархической структурой (только)] (#Rh-домен)
* [C. 121: если базовый класс используется в качестве интерфейса, сделайте его чистым абстрактным классом] (#Rh-abstract)
* [C. 122: используйте абстрактные классы в качестве интерфейсов, когда требуется полное разделение интерфейса и реализации] (#Rh-разделение)

Разработка правил для классов в сводке иерархии:

* [C. 126: абстрактный класс обычно не нуждается в конструкторе] (#Rh-abstract-ctor)
* [C. 127: класс с виртуальной функцией должен иметь виртуальный или защищенный деструктор] (#Rh-dtor)
* [C. 128: виртуальные функции должны точно указывать одно из значений `virtual', 'override' или`final'] (#Rh-override)
* [C. 129: при проектировании иерархии классов следует различать наследование реализации и наследование интерфейса] (#Rh-вид)
* [C. 130: для создания глубоких копий полиморфных классов предпочтите виртуальную функцию "клонирования" вместо копирования конструкции/назначения] (#Rh-copy)
* [C. 131: избегайте тривиальных геттеров и сеттеров] (#Rh-get)
* [C. 132: Не делайте функцию 'виртуальной' без причины] (#Rh-virtual)
* [C. 133: избегайте "защищенных" данных] (#Rh-protected)
* [C. 134: убедитесь, что все члены данных не 'const' имеют одинаковый уровень доступа] (#Rh-public)
* [C. 135: используйте множественное наследование для представления нескольких различных интерфейсов] (#Rh-mi-interface)
* [C. 136: используйте множественное наследование для представления объединения атрибутов реализации] (#Rh-mi-реализация)
* [C. 137: используйте "виртуальные" базы, чтобы избежать чрезмерно общих базовых классов] (#Rh-vbase)
* [C. 138: создайте перегрузочный набор для производного класса и его оснований с помощью 'using'] (#Rh-using)
* [C. 139: используйте` final ' экономно] (#Rh-final)
* [C. 140: не предоставляйте различные аргументы по умолчанию для виртуальной функции и переопределителя] (#Rh-virtual-default-arg)

Доступ к объектам в сводке правил иерархии:

* [C. 145: доступ к полиморфным объектам через указатели и ссылки] (#Rh-poly)
* [C. 146: используйте "dynamic_cast", где навигация по иерархии классов неизбежна] (#Rh-dynamic_cast)
* [C. 147: используйте параметр ' dynamic_cast` для ссылочного типа, если ошибка поиска требуемого класса считается ошибкой] (#Rh-ref-cast)
* [C. 148: используйте " dynamic_cast` для типа указателя, когда невозможность найти требуемый класс считается допустимой альтернативой] (#Rh-ptr-cast)
* [C. 149: используйте `unique_ptr ' или 'shared_ptr', чтобы не забывать 'удалять' объекты, созданные с помощью 'new'] (#Rh-smart)
* [C. 150: используйте 'make_unique ()' для построения объектов, принадлежащих ' unique_ptr's] (#Rh-make_unique)
* [C. 151: используйте 'make_shared ()' для построения объектов, принадлежащих ' shared_ptr's] (#Rh-make_shared)
* [C. 152: никогда не назначайте указатель на массив производных объектов класса указателю на его базу] (#Rh-массив)
* [C. 153: предпочтение виртуальной функции кастингу] (#Rh-use-virtual)

### <a name= "Rh-domain" ><a name= "Rh-domain" >< / a > C. 120: используйте иерархии классов для представления понятий с присущей им иерархической структурой (только)

##### Причина

Прямое представление идей в коде облегчает понимание и сопровождение. Убедитесь, что идея, представленная в базовом классе, точно соответствует всем производным типам, и нет лучшего способа выразить ее, чем использование тесной связи наследования.

Не используйте наследование, когда достаточно просто иметь элемент данных. Обычно это означает, что производный тип должен переопределить базовую виртуальную функцию или получить доступ к защищенному элементу.

##### Образец

 класс DrawableUIElement {
 Публично:
 virtual void render () const = 0;
 // ...
 };

 класс AbstractButton : public DrawableUIElement {
 Публично:
 virtual void onClick () = 0;
 // ...
 };

 кнопка класса: public AbstractButton {
 void render () const override;
 переопределение void onClick() ;
 // ...
 };

 флажок класса: public AbstractButton {
 // ...
 };

##### Пример, плохо

Не представляйте неиерархические понятия домена в виде иерархий классов.

 шаблон<typename T>
 классный контейнер {
 Публично:
 // операции со списком:
 virtual T & get () = 0;
 виртуальная пустота put(T&) = 0;
 виртуальная пустая вставка (позиция) = 0;
 // ...
 // векторные операции:
 виртуальный оператор T& [] (int) = 0;
 virtual void sort () = 0;
 // ...
 // операции с деревом:
 virtual void balance () = 0;
 // ...
 };

Здесь большинство переопределяющих классов не могут реализовать большинство функций, необходимых в интерфейсе хорошо.
Таким образом, базовый класс становится бременем реализации.
Кроме того, пользователь " контейнера` не может полагаться на функции-члены, фактически выполняющие значимые операции достаточно эффективно;
это может вызвать исключение вместо этого.
Таким образом, пользователи должны прибегать к проверке времени выполнения и/или
не используя этот (над)общий интерфейс в пользу конкретного интерфейса, найденного запросом типа времени выполнения (например, "dynamic_cast").

##### Принуждение

* Ищите классы с большим количеством членов, которые ничего не делают, но бросают.
* Помечать любое использование непубличного базового класса "B", где производный класс " D "не переопределяет виртуальную функцию или не обращается к защищенному члену в "B", и " B "не является одним из следующих: пустой, параметр шаблона или пакет параметров "D", шаблон класса, специализированный С "D".

### <a name= "Rh-abstract" ><a name= "Rh-abstract" >< / a > C. 121: если базовый класс используется в качестве интерфейса, сделайте его чистым абстрактным классом

##### Причина

Класс является более стабильным (менее хрупким), если он не содержит данных.
Интерфейсы обычно должны быть полностью составлены из общедоступных чистых виртуальных функций и виртуального деструктора по умолчанию/пустой.

##### Образец

 класс My_interface {
 Публично:
 // ...здесь только чисто виртуальные функции ...
 virtual ~My_interface () {} / / or =default
 };

##### Пример, плохо

 класс Гуф {
 Публично:
 // ...здесь только чисто виртуальные функции ...
 // нет виртуального деструктора
 };

 класс производный : public Goof {
 строка s;
 // ...
 };

 пустое использование()
 {
 unique_ptr<Goof > p {new Derived {"поехали"}};
 f (p. get ()); / / использовать полученный через интерфейс Goof
 g (p. get ()); / / использовать полученный через интерфейс Goof
 } // утечка

'Derived' - это 'delete' через его интерфейс` Goof', поэтому его "строка" просачивается.
Дайте 'Goof' виртуальный деструктор и все будет хорошо.


##### Принуждение

* Предупреждать о любом классе, который содержит члены данных и также имеет переопределяемую (не`окончательную`) виртуальную функцию, которая не была унаследована от базового класса.

### <a name= "Rh-separation" ><a name= "Rh-separation" >< / a > C. 122: используйте абстрактные классы в качестве интерфейсов, когда требуется полное разделение интерфейса и реализации

##### Причина

Например, на границе ABI (link).

##### Образец

 конструктивное устройство {
 virtual ~Device () = по умолчанию;
 запись в виртуальную пустоту (span<const char > outbuf) = 0;
 виртуальная пустота чтения (span<char> inbuf) = 0;
 };

 класс D1: публичное устройство {
 // ... данные...

 void write (span<const char> outbuf) переопределение;
 void read (span<char> inbuf) переопределение;
 };

 класс D2: публичное устройство {
 // ... разные данные. ..

 void write (span<const char> outbuf) переопределение;
 void read (span<char> inbuf) переопределение;
 };

Теперь пользователь может использовать `D1 `и ' D2 'взаимозаменяемо через интерфейс, предоставляемый 'Device'.
Кроме того, мы можем обновить `D1` и `D2` способами, которые не являются двоичными совместимыми с более старыми версиями, пока весь доступ проходит через `устройство`.

##### Принуждение

 ???

## C. hierclass: проектирование классов в иерархии:

### <a name= "Rh-abstract-ctor" ><a name= "Rh-abstract-ctor" >< / a > C. 126: абстрактный класс обычно не нуждается в конструкторе

##### Причина

Абстрактный класс обычно не имеет никаких данных для инициализации конструктором.

##### Образец

 ???

##### Исключение

* Конструктор базового класса, который действительно работает, например, регистрация объекта где-то, может потребоваться конструктор.
* В крайне редких случаях вы можете найти разумным для абстрактного класса иметь немного данных, совместно используемых всеми производными классами
 (например, использовать статистические данные, отладочную информацию и т.д.); такие классы, как правило, имеют конструкторы. Но имейте в виду: такие классы также склонны требовать виртуального наследования.

##### Принуждение

Флаг абстрактные классы с конструкторами.

### <a name= "Rh-dtor" ><a name= "Rh-dtor" >< / a > C. 127: класс с виртуальной функцией должен иметь виртуальный или защищенный деструктор

##### Причина

Класс с виртуальной функцией обычно (и в целом) используется через указатель на базу. Обычно, последний пользователь должен вызвать delete по указателю на базу, часто через смарт-указатель на базу, поэтому деструктор должен быть общедоступным и виртуальным. Реже, если удаление через указатель на базу не предполагается поддерживать, деструктор должен быть защищен и невиртуальным; см. [C. 35](#Rc-dtor-virtual).

##### Пример, плохо

 структура B {
 virtual int f () = 0;
 // ... нет написанного пользователем деструктора, по умолчанию это public nonvirtual ...
 };

 // bad: производный от класса без виртуального деструктора
 структура D : B {
 строка s {"default"};
 };

 пустое использование()
 {
 unique_ptr<B > p = make_unique<B > <D>();
 // ...
 } / / неопределенное поведение. Может вызвать B::~B только и утечка строки

##### Записка

Есть люди, которые не следуют этому правилу, потому что они планируют использовать класс только через `shared_ptr`: `std::shared_ptr<B> p = std::make_shared<B><D>(args);` здесь общий указатель позаботится об удалении, поэтому никакая утечка не произойдет от неподходящего `удаления` базы. Люди, которые делают это последовательно, могут получить ложный положительный результат, но правило важно-что делать, если он был выделен с помощью "make_unique"? Это не безопасно, если только автор `B ' не гарантирует, что он никогда не будет использоваться неправильно, например, сделав все конструкторы частными и предоставив функцию фабрики для принудительного выделения с помощью `make_shared`.

##### Принуждение

* Класс с любыми виртуальными функциями должен иметь деструктор, который является либо общедоступным и виртуальным, либо защищенным и невиртуальным.
* Флаг 'delete' класса с виртуальной функцией, но без виртуального деструктора.

### <a name= "Rh-override" ><a name= "Rh-override" >< / a>C. 128: виртуальные функции должны указывать точно один из 'virtual', 'override' или ' final`

##### Причина

Удобочитаемость.
Выявление ошибок.
Написание явных "виртуальных", "переопределенных" или "окончательных" является самодокументирующим и позволяет компилятору перехватывать несоответствие типов и/или имен между базовыми и производными классами. Тем не менее, написание более одного из этих трех является как избыточным, так и потенциальным источником ошибок.

Это просто и понятно:

* 'virtual' означает точно и только "это новая виртуальная функция."
* 'override' означает точно и только "это не окончательное переопределение."
* 'final' означает точно и только "это окончательное переопределение."

##### Пример, плохо

 структура B {
 void f1(int);
 виртуальная пустота f2 (int) const;
 виртуальная пустота f3(int);
 // ...
 };

 структура D : B {
 void f1(int); / / плохо (надеюсь на предупреждение): D:: f1() скрывает B::f1()
 void f2 (int) const; / / bad (но обычный и допустимый): нет явного переопределения
 void f3 (double); / / плохо (надеюсь на предупреждение): D:: f3() скрывает B::f3()
 // ...
 };

##### Пример, хорошо

 структура лучше : B {
 переопределение void f1 (int); / / ошибка (поймана): Better:: f1 () скрывает B:: f1()
 void F2 (int) const переопределение;
 void F3 (double) override; / / ошибка (перехвачена): Better:: f3 () скрывает B::f3()
 // ...
 };

#### Обсуждение

Мы хотим исключить два конкретных класса ошибок:

** * неявный виртуальный**: программист предполагал, что функция будет неявно виртуальной, и это так (но читатели кода не могут сказать); или программист предполагал, что функция будет неявно виртуальной, но это не так (например, из-за тонкого несоответствия списка параметров); или программист не предполагал, что функция будет виртуальной, но это так (потому что она имеет ту же подпись, что и виртуальная в базовом классе)
* * * неявное переопределение**: программист предполагал, что функция будет неявно переопределена, и это так (но читатели кода не могут сказать); или программист предполагал, что функция будет неявно переопределена, но это не так (например, из-за тонкого несоответствия списка параметров); или программист не намеревался использовать функцию в качестве переопределителя, но это так (потому что она имеет ту же сигнатуру, что и виртуальная в базовом классе-обратите внимание, что эта проблема возникает независимо от того, объявлена ли функция явным образом виртуальной, потому что программист мог намереваться создать либо новую виртуальную функцию, либо новую невиртуальную функцию)

##### Принуждение

* Сравнение имен виртуальных функций в базовых и производных классах и использование флагов с одинаковыми именами, которые не переопределяются.
* Флаг переопределяет ни с "override", ни с "final".
* Объявления функций флагов, которые используют более одного из 'virtual`, `override`и 'final'.

### <a name= "Rh-kind" ><a name= "Rh-kind">< / a > C. 129: при проектировании иерархии классов следует различать наследование реализации и наследование интерфейса

##### Причина

Детали реализации в интерфейсе делают интерфейс хрупким;
то есть сделать его пользователей уязвимыми к необходимости перекомпиляции после внесения изменений в реализацию.
Данные в базовом классе повышают сложность реализации базы и могут привести к репликации кода.

##### Записка

Определение:

* наследование интерфейса-это использование наследования для отделения пользователей от реализаций,
в частности, разрешить добавлять и изменять производные классы, не затрагивая пользователей базовых классов.
* реализация наследования - это использование наследования для упрощения реализации новых объектов
делая полезные операции доступными для исполнителей связанных новых операций (иногда называемых "Программирование по разнице").

Класс чистого интерфейса-это просто набор чистых виртуальных функций; см. [I. 25](#Ri-abstract).

В начале ООП (например, в 1980-е и 1990-е годы) наследование реализации и наследование интерфейса часто были смешанными
а от плохих привычек трудно избавиться.
Даже сейчас смеси не редкость в старых кодовых базах и в учебном материале старого стиля.

Важность сохранения двух видов наследования возрастает

* с размером иерархии (например, десятки производных классов),
* с течением времени иерархия используется (например, десятилетия), и
* с числом различных организаций, в которых используется иерархия
(например, может быть сложно распространить обновление в базовый класс)


##### Пример, плохо

 класс Shape {//плохой, смешанный интерфейс и реализация
 Публично:
 Форма();
 Форма (точка ce = {0, 0}, цвет co = none): cent{ce}, col {co} { /* ... */}

 Point center () const { return cent; }
 Color color () const { return col; }

 virtual void rotate (int) = 0;
 виртуальное пустое перемещение (точка p) { cent = p; перерисовка(); }

 виртуальная пустота перерисовывается();

 // ...
 Частное:
 Точка цент;
 Цвет col;
 };

 круг класса: общественная форма {
 Публично:
 Круг(точка c, int r): форма{c}, рад{r} { /* ... */ }

 // ...
 Частное:
 int rad;
 };

 треугольник класса: общественная форма {
 Публично:
 Треугольник (точка p1, точка p2, точка p3); / / вычислить центр
 // ...
 };

Проблемы:

* По мере роста иерархии и добавления большего количества данных в "форму", конструкторы становятся все труднее писать и поддерживать.
* Зачем вычислять центр для "треугольника"? мы можем никогда не использовать его.
* Добавьте элемент данных в 'Shape' (например, стиль рисования или холст)
и все классы, производные от 'Shape`, и весь код, использующий` Shape', должны будут быть рассмотрены, возможно, изменены и, вероятно, перекомпилированы.

Реализация 'Shape:: move ()' является примером наследования реализации:
мы определили `move()` раз и навсегда для всех производных классов.
Чем больше кода существует в таких реализациях функций-членов базового класса и тем больше данных совместно используется путем размещения его в базе,
чем больше преимуществ мы получаем - и тем менее устойчива иерархия.

##### Образец

Эту иерархию фигур можно переписать с помощью наследования интерфейса:

 форма класса {//чистый интерфейс
 Публично:
 virtual Point center () const = 0;
 виртуальный цвет color () const = 0;

 virtual void rotate (int) = 0;
 виртуальное пустое перемещение (точка p) = 0;

 virtual void redraw () = 0;

 // ...
 };

Обратите внимание, что чистый интерфейс редко имеет конструкторы: там нечего строить.

 круг класса: общественная форма {
 Публично:
 Круг (точка c, int r, цвет c): cent{c}, rad{r}, col{c} { /* ... */ }

 Point center () const override { return cent; }
 Color color () const override { return col; }

 // ...
 Частное:
 Точка цент;
 int rad;
 Цвет col;
 };

Интерфейс теперь менее хрупкий, но есть больше работы по реализации функций-членов.
Например, 'center' должен быть реализован каждым классом, производным от`Shape'.

##### Пример, двойная иерархия

Как мы можем получить преимущества стабильных иерархий от иерархий реализации и преимущества повторного использования реализации от наследования реализации?
Одним из популярных методов является двойная иерархия.
Существует множество способов реализации идеи двойственных иерархий; здесь мы используем вариант множественного наследования.

Сначала мы разрабатываем иерархию интерфейсных классов:

 форма класса {//чистый интерфейс
 Публично:
 virtual Point center () const = 0;
 виртуальный цвет color () const = 0;

 virtual void rotate (int) = 0;
 виртуальное пустое перемещение (точка p) = 0;

 virtual void redraw () = 0;

 // ...
 };

 класс Circle: public virtual Shape {//чистый интерфейс
 Публично:
 виртуальный int radius () = 0;
 // ...
 };

Чтобы сделать этот интерфейс полезным, мы должны предоставить его классы реализации (здесь, названные эквивалентно, но в пространстве имен ' Impl):

 класс Impl:: Shape: public virtual:: Shape {//реализация
 Публично:
 // конструкторы, деструктор
 // ...
 Point center () const override { /* ... */ }
 Color color() const override { /* ... */ }

 void rotate (int) override { /* ... */ }
 пустое перемещение (точка p) переопределяет { /* ... */ }

 void redraw () override { /* ... */ }

 // ...
 };

Теперь 'Shape' является плохим примером класса с реализацией,
но имейте терпение, потому что это всего лишь простой пример техники, направленной на более сложные иерархии.

 класс Impl:: Circle:public virtual::Circle, public Impl:: Shape {//реализация
 Публично:
 // конструкторы, деструктор

 int radius() переопределяет { /* ... */ }
 // ...
 };

И мы могли бы расширить иерархию, добавив класс смайликов (:-)):

 класс Smiley: public virtual Circle {//чистый интерфейс
 Публично:
 // ...
 };

 класс Impl:: Smiley:public virtual::Smiley, public Impl:: Circle {//реализация
 Публично:
 // конструкторы, деструктор
 // ...
 }

Теперь существует две иерархии:

* интерфейс: смайлик - > круг - > > форма
* реализация: Impl:: Smiley - > Impl:: Circle - > > Impl:: Shape

Поскольку каждая реализация является производной от ее интерфейса, а также ее базового класса реализации, мы получаем решетку (DAG):

 Смайлик - > Круг - > > Форма
 ^ ^ ^
 | | |
 Impl:: Smiley - > Impl:: Circle - > > Impl:: Shape

Как уже упоминалось, это лишь один из способов построения двойной иерархии.

Иерархию реализации можно использовать непосредственно, а не через абстрактный интерфейс.

 void work_with_shape(форма&);

 int пользователь()
 {
 Impl:: Smiley my_smiley { /*args */}; / / создать конкретную форму
 // ...
 my_smiley.some_member (); / / используйте класс реализации напрямую
 // ...
 work_with_shape(my_smiley); / / используйте реализацию через абстрактный интерфейс
 // ...
 }

Это может быть полезно, когда класс реализации имеет члены, которые не предлагаются в абстрактном интерфейсе
или если прямое использование элемента предлагает возможности оптимизации (например, если функция-член реализации является ' окончательной`)

##### Записка

Другой (связанный) метод для разделения интерфейса и реализации является [Pimpl] (#Ri-pimpl).

##### Записка

Часто существует выбор между предложением общей функциональности в качестве (реализованных) функций базового класса и автономных функций
(в пространстве имен реализации).
Базовые классы дают более короткую нотацию и более легкий доступ к общим данным (в базе)
за счет того, что функционал будет доступен только пользователям иерархии.

##### Принуждение

* Флаг производное преобразование базы в базу с данными и виртуальными функциями
(за исключением вызовов от производного члена класса к члену базового класса)
* ???


### <a name= "Rh-copy" ><a name= "Rh-copy">< / a > C. 130: для создания глубоких копий полиморфных классов предпочтите виртуальную функцию " клон` вместо копирования конструкции / назначения

##### Причина

Копирование полиморфного класса не рекомендуется из-за проблемы срезания, см. [C. 67](#Rc-copy-virtual). Если вам действительно нужна семантика копирования, копируйте глубоко: предоставьте виртуальную функцию "клонирования", которая скопирует фактический наиболее производный тип и вернет указатель владельца на новый объект, а затем в производных классах вернет производный тип (используйте ковариантный тип возврата).

##### Образец

 класс В {
 Публично:
 виртуальный владелец < B*> clone () = 0;
 virtual ~B () = по умолчанию;

 B (const B&) = исключить;
 Оператор B&=(const B&) = удалить;
 };

 класс D: public B {
 Публично:
 owner<D* > clone () override;
 ~D () переопределение;
 };

Как правило, рекомендуется использовать интеллектуальные указатели для представления права собственности (см. [R. 20] (#Rr-owner)). Однако из-за правил языка тип ковариантного возврата не может быть интеллектуальным указателем: "D::clone" не может возвращать a " unique_ptr<D>", А "B::clone "возвращает" unique_ptr<D><B>". Поэтому необходимо либо последовательно возвращать 'unique_ptr<B> `во всех переопределениях, либо использовать утилиту` owner<B>< >' из библиотеки поддержки [Guidelines](#SS-views).



### <a name= "Rh-get" ><a name= "Rh-get">< / a > C. 131: избегайте тривиальных геттеров и сеттеров

##### Причина

Тривиальный геттер или сеттер не добавляет никакого семантического значения; элемент данных также может быть "публичным".

##### Образец

 точка класса {//Bad: verbose
 int x;
 int y;
 Публично:
 Точка (int xx, int yy): x{xx}, y{yy} { }
 int get_x () const { return x; }
 void set_x (int xx) { x = xx; }
 int get_y () const { return y; }
 void set_y (int yy) { y = yy; }
 // нет поведенческих функций-членов
 };

Подумайте о том, чтобы сделать такой класс "структурой" - то есть группой переменных без поведения, все открытые данные и никакие функции-члены.

 структурная точка {
 int x {0};
 int y {0};
 };

Обратите внимание, что мы можем поместить инициализаторы по умолчанию на переменные-члены: [C. 49: Prefer initialization to assignment in constructors](#Rc-initialize).

##### Записка

Ключ к этому правилу заключается в том, является ли семантика getter/setter тривиальной. Хотя это не является полным определением "тривиального", рассмотрите, было бы ли какое-либо различие за пределами синтаксиса, если бы геттер/сеттер был общедоступным членом данных вместо этого. Примерами нетривиальной семантики могут быть: сохранение инварианта класса или преобразование между внутренним типом и типом интерфейса.

##### Принуждение

Флаг несколько " get " и " set " функции-члены, которые просто получить доступ к члену без дополнительной семантики.

### <a name= "Rh-virtual"><a name= "Rh-virtual">< / a > C. 132: не делайте функцию `virtual` без причины

##### Причина

Избыточный "виртуальный" увеличивает время выполнения и размер объектного кода.
Виртуальная функция может быть переопределена и, таким образом, открыта для ошибок в производном классе.
Виртуальная функция обеспечивает репликацию кода в иерархии шаблонов.

##### Пример, плохо

 шаблон<класс T>
 вектор класса {
 Публично:
 // ...
 virtual int size () const { return sz;} / / bad: что хорошего может сделать производный класс?
 Частное:
 T * elem; / / элементы
 int sz; / / количество элементов
 };

Этот вид "вектора" вообще не предназначен для использования в качестве базового класса.

##### Принуждение

* Отметьте класс с виртуальными функциями, но без производных классов.
* Отметьте класс, в котором все функции-члены являются виртуальными и имеют реализации.

### <a name= "Rh-protected" ><a name= "Rh-protected">< / a > C. 133: избегайте "защищенных" данных

##### Причина

"защищенные" данные являются источником сложности и ошибок.
"защищенные" данные усложняют постановку инвариантов.
"защищенные" данные по своей сути нарушают руководство против размещения данных в базовых классах, что обычно приводит к необходимости иметь дело с виртуальным наследованием, а также.

##### Пример, плохо

 форма класса {
 Публично:
 // ... интерфейсная функция. ..
 защищенный:
 // данные для использования в производных классах:
 Цвет fill_color;
 Цвет edge_color;
 Стиль st;
 };

Теперь это до каждой производной "формы", чтобы правильно манипулировать защищенными данными.
Это было популярно, но также главный источник проблем обслуживания.
В большой иерархии классов, последовательное использование защищенных данных трудно поддерживать, потому что может быть много кода,
разбросано по множеству классов.
Набор классов, которые могут касаться этих данных, открыт: любой пользователь может создать новый класс и начать манипулировать защищенными данными.
Часто невозможно изучить полный набор классов, поэтому любое изменение представления класса становится неосуществимым.
Для защищенных данных не существует принудительного инварианта; он очень похож на набор глобальных переменных.
Защищенные данные де-факто стали глобальными для большого объема кода.

##### Записка

Защищенные данные часто выглядят заманчиво, чтобы включить произвольные улучшения через вывод.
Часто то, что вы получаете, - это беспринципные изменения и ошибки.
[Предпочитайте "частные" данные] (#Rc-private) с четко заданным и принудительным инвариантом.
Альтернативный, а часто и лучший, способ [хранить данные вне любого класса, используемого в качестве интерфейса] (#Rh-abstract).

##### Записка

Защищенная функция-член может быть просто отлично.

##### Принуждение

Классы флагов с "защищенными" данными.

### <a name= "Rh-public" ><a name= "Rh-public">< / a>C. 134: убедитесь, что все члены данных не 'const' имеют одинаковый уровень доступа

##### Причина

Предотвращение логической путаницы, приводящей к ошибкам.
Если члены данных, не являющиеся 'const', не имеют одинакового уровня доступа, тип запутывается в том, что он пытается сделать.
Это тип, который поддерживает инвариант или просто набор значений?

##### Обсуждение

Основной вопрос заключается в следующем: какой код отвечает за поддержание значимого/правильного значения для этой переменной?

Существует ровно два вида элементов данных:

* A: те, которые не участвуют в инварианте объекта. Допустима любая комбинация значений для этих элементов.
* B: те, которые действительно участвуют в инварианте объекта. Не всякая комбинация значений имеет смысл (иначе не было бы никакого инварианта). Поэтому весь код, имеющий доступ для записи к этим переменным, должен знать об инварианте, знать семантику и знать (а также активно реализовывать и применять) правила сохранения правильных значений.

Члены данных в категории A должны быть просто "открытыми" (или, что еще реже, "защищенными", если вы хотите, чтобы их видели только производные классы). Они не нуждаются в инкапсуляции. Весь код в системе может также видеть и манипулировать ими.

Элементы данных в категории B должны быть 'private`или 'const'. Это происходит потому, что инкапсуляция важна. Чтобы сделать их не "частными" и не "постоянными", это означало бы, что объект не может контролировать свое собственное состояние: неограниченное количество кода за пределами класса должно было бы знать об инварианте и участвовать в его точном поддержании-если бы эти члены данных были "открытыми", это был бы весь вызывающий код, который использует объект; если бы они были "защищены", это был бы весь код в текущих и будущих производных классах. Это приводит к хрупкому и плотно связанному коду, который быстро становится кошмаром для поддержания. Любой код, который непреднамеренно устанавливает для элементов данных недопустимое или неожиданное сочетание значений, может привести к повреждению объекта и всех последующих способов его использования.

Большинство классов - это либо все A, либо все B:

* * All public*: если вы пишете агрегатный пакет переменных без инварианта по этим переменным, то все переменные должны быть "открытыми".
 [По соглашению, объявите такие классы 'struct', а не 'class'] (#Rc-struct)
* Все частные*: если вы пишете тип, который поддерживает инвариант, то все не-`const` переменные должны быть частными -- он должен быть инкапсулирован.

##### Исключение

Иногда классы будут смешивать A и B, как правило, по причинам отладки. Инкапсулированный объект может содержать что-то вроде не - `const` отладочного инструментария, который не является частью инварианта и поэтому попадает в категорию A-он также не является частью значения объекта или значимого наблюдаемого состояния. В этом случае части а должны рассматриваться как части а (ставшие "публичными" или в более редких случаях "защищенными", если они должны быть видны только производным классам), а части В должны по-прежнему рассматриваться как части в ("частные" или "const").

##### Принуждение

Флаг любой класс, который имеет не - 'const' члены данных с различными уровнями доступа.

### <a name= "Rh-mi-interface" ><a name= "Rh-mi-interface" >< / a > C. 135: используйте множественное наследование для представления нескольких различных интерфейсов

##### Причина

Не все классы обязательно будут поддерживать все интерфейсы, и не все вызывающие устройства обязательно захотят иметь дело со всеми операциями.
Особенно для разбиения монолитных интерфейсов на "аспекты" поведения, поддерживаемые данным производным классом.

##### Образец

 класс iostream : public istream, public ostream {//очень упрощенный
 // ...
 };

'istream' предоставляет интерфейс для операций ввода; 'ostream' предоставляет интерфейс для операций вывода.
`iostream 'обеспечивает объединение интерфейсов "istream" и "ostream" и синхронизацию, необходимую для разрешения обоих в одном потоке.

##### Записка

Это очень распространенное использование наследования, потому что потребность в нескольких различных интерфейсах к реализации является общей
и такие интерфейсы часто не легко и не естественно организуются в единую корневую иерархию.

##### Записка

Такие интерфейсы, как правило, являются абстрактными классами.

##### Принуждение

???

### <a name= "Rh-mi-implementation" ><a name= "Rh-mi-implementation">< / a > C. 136: используйте множественное наследование для представления объединения атрибутов реализации

##### Причина

Некоторые формы миксинов имеют состояние и часто работают с этим состоянием.
Если операции являются виртуальными, то необходимо использовать наследование, если же нет, то наследование позволяет избежать шаблонности и переадресации.

##### Образец

 класс iostream : public istream, public ostream {//очень упрощенный
 // ...
 };

'istream' предоставляет интерфейс для операций ввода (и некоторых данных); `ostream` предоставляет интерфейс для операций вывода (и некоторых данных).
`iostream 'обеспечивает объединение интерфейсов "istream" и "ostream" и синхронизацию, необходимую для разрешения обоих в одном потоке.

##### Записка

Это относительно редкое использование, потому что реализация часто может быть организована в однокорневую иерархию.

##### Образец

Иногда "атрибут реализации" больше похож на "mixin", который определяет поведение реализации и вводит
члены для обеспечения возможности осуществления требуемой им политики.
Например, смотрите раздел ' std:: enable_shared_from_this`
или различные базы из boost.интрузивный (например, "list_base_hook" или "intrusive_ref_counter").

##### Принуждение

???

### <a name= "Rh-vbase" ><a name= "Rh-vbase" >< / a > C. 137: используйте 'виртуальные' базы, чтобы избежать чрезмерно общих базовых классов

##### Причина

 Разрешить разделение общих данных и интерфейса.
 Чтобы избежать всех общих данных для размещения в конечном базовом классе.

##### Образец

 структурный интерфейс {
 виртуальная пустота f();
 виртуальный int g();
 // ... здесь нет никаких данных ...
 };

 утилита класса {//с данными
 void utility1();
 virtual void utility2 (); / / точка настройки
 Публично:
 int x;
 int y;
 };

 класс Derive1 : открытый интерфейс, виртуальная защищенная утилита {
 // переопределение функций интерфейса
 // Возможно переопределить виртуальные функции утилиты
 // ...
 };

 класс Derive2: публичный интерфейс, виртуальная защищенная утилита {
 // переопределение функций интерфейса
 // Возможно переопределить виртуальные функции утилиты
 // ...
 };

Факторинг " полезности "имеет смысл, если многие производные классы совместно используют значительные" детали реализации."


##### Записка

Очевидно, что этот пример слишком "теоретичен", но трудно найти *маленький* реалистичный пример.
'Interface' - это корень из [иерархии интерфейса] (#Rh-аннотация)
а "полезность" -это корень иерархии реализации(#Rh-kind).
Вот [немного более реалистично example](https://www.quora.com/What-are-the-uses-and-advantages-of-virtual-base-class-in-C%2B%2B/answer/Lance-Diduck) с объяснением.

##### Записка

Часто линеаризация иерархии является лучшим решением.

##### Принуждение

Флаг смешанных иерархий интерфейса и реализации.

### <a name= "Rh-using" ><a name="Rh-using" >< / a > C. 138: создайте набор перегрузки для производного класса и его оснований с помощью`using

##### Причина

Без объявления using функции-члены в производном классе скрывают все унаследованные наборы перегрузки.

##### Пример, плохо

 #include <iostream>
 класс В {
 Публично:
 virtual int f (int i) { std:: cout <; }
 виртуальный двойник f (double d) { std:: cout <; }
 virtual ~B () = по умолчанию;
 };
 класс D: public B {
 Публично:
 int f(int i) переопределение { std:: cout <; }
 };
 int main()
 {
 Д-р;
 std:: cout < < d.f (2) <"
 std:: cout < < d.f (2.3) <"
 }

##### Пример, хорошо

 класс D: public B {
 Публично:
 int f(int i) переопределение { std:: cout <; }
 использование B::f; / / выставляет f (двойной)
 };

##### Записка

Эта проблема затрагивает как виртуальные, так и невиртуальные функции-члены

Для вариадических базисов C++17 ввел вариадическую форму using-объявления,

 класс шаблона... Ts>
 перегружатель структуры : Ts... {
 используя TS:: оператор()...; / / выставляет оператор () из каждой базы
 };

##### Принуждение

Диагностика скрытия имен

### <a name= "Rh-final" ><a name= "Rh-final">< / a > C. 139: используйте` final ' экономно

##### Причина

Ограничение иерархии `окончательным " редко требуется по логическим причинам и может нанести ущерб расширяемости иерархии.

##### Пример, плохо

 виджет класса { / * ... */ };

 // никто никогда не захочет улучшить My_widget (или так вы думали)
 класс My_widget final: public Widget { / * ... */ };

 класс My_improved_widget: public My_widget { / * ... * / }; / / ошибка: не могу этого сделать

##### Записка

Не каждый класс должен быть базовым классом.
Большинство классов стандартной библиотеки являются примерами этого (например, 'std:: vector `и` std::string' не предназначены для получения из них).
Это правило касается использования 'final' в классах с виртуальными функциями, предназначенными быть интерфейсами для иерархии классов.

##### Записка

Ограничение отдельной виртуальной функции с помощью "final" является ошибочным, поскольку "final" можно легко пропустить при определении/переопределении набора функций.
К счастью, компилятор улавливает такие ошибки: вы не можете повторно объявить/повторно открыть `окончательный` член в производном классе.

##### Записка

Утверждения о повышении производительности от "окончательного" должны быть обоснованы.
Слишком часто такие утверждения основаны на гипотезе или опыте работы с другими языками.

Есть примеры, когда "окончательный" может быть важным как по логическим, так и по производительным причинам.
Одним из примеров является критическая для производительности иерархия AST в компиляторе или инструменте анализа языка.
Новые производные классы добавляются не каждый год, а только разработчиками библиотек.
Однако злоупотребления встречаются (или, по крайней мере, были) гораздо чаще.

##### Принуждение

Флаг использует `final'.


### <a name= "Rh-virtual-default-arg" ><a name= "Rh-virtual-default-arg" >< / a > C. 140: не предоставляйте различные аргументы по умолчанию для виртуальной функции и переопределителя

##### Причина

Это может привести к путанице: переопределитель не наследует аргументы по умолчанию.

##### Пример, плохо

 основание класса {
 Публично:
 virtual int multiply(int value, int factor = 2) = 0;
 virtual ~Base () = по умолчанию;
 };

 производный класс: public Base {
 Публично:
 int multiply(int value, int factor = 10) переопределение;
 };

 Производный d;
 Основание& b = d;

 b. умножьте(10); // эти два вызова вызовут одну и ту же функцию, но
 D. умножим(10); // с разными аргументами и поэтому разными результатами

##### Принуждение

Флаг аргументы по умолчанию для виртуальных функций, если они отличаются между базовыми и производными объявлениями.

## C. hier-access: доступ к объектам в иерархии

### <a name= "Rh-poly" ><a name= "Rh-poly">< / a > C. 145: доступ к полиморфным объектам через указатели и ссылки

##### Причина

Если у вас есть класс с виртуальной функцией, вы не знаете (в общем случае), какой класс предоставил функцию для использования.

##### Образец

 struct B { int a; virtual int f (); virtual ~B () = по умолчанию };
 struct D: B { int b; int f() переопределение; };

 пустое использование(B b)
 {
 Д-р;
 B b2 = d; / / ломтик
 B b3 = b;
 }

 void use2()
 {
 Д-р;
 use (d); / / slice
 }

Оба " d " нарезаны ломтиками.

##### Исключение

Вы можете безопасно получить доступ к именованному полиморфному объекту в области его определения, просто не разрезайте его.

 void use3()
 {
 Д-р;
 d. f (); / / OK
 }

##### Смотреть также

[Полиморфный класс должен подавлять копирование] (#Rc-copy-virtual)

##### Принуждение

Флаг все нарезки.

### <a name= "Rh-dynamic_cast" ><a name= "Rh-dynamic_cast">< / a > C. 146: используйте "dynamic_cast", где навигация по иерархии классов неизбежна

##### Причина

'dynamic_cast' проверяется во время выполнения.

##### Образец

 struct B {//an интерфейс
 виртуальная пустота f();
 виртуальная пустота g();
 виртуальный ~B();
 };

 struct D: B {//A более широкий интерфейс
 void F () переопределение;
 виртуальная пустота h();
 };

 void user(B* pb)
 {
 если (D * pd = dynamic_cast<D*>(pb)) {
 // ... используйте интерфейс D ...
 }
 еще {
 // ... обойдитесь интерфейсом B ...
 }
 }

Использование других приведений может нарушить безопасность типов и привести к тому, что программа получит доступ к переменной, которая на самом деле относится к типу `X`, как если бы она была несвязана с типом `Z`:

 void user2(B* pb) / / плохо
 {
 D * pd = static_cast<D*>(pb); // я знаю, что pb действительно указывает на D; поверьте мне
 // ... используйте интерфейс D ...
 }

 void user3 (B* pb) / / небезопасно
 {
 if (some_condition) {
 D * pd = static_cast<D*>(pb); // я знаю, что pb действительно указывает на D; поверьте мне
 // ... используйте интерфейс D ...
 }
 еще {
 // ... обойдитесь интерфейсом B ...
 }
 }

 пустота f()
 {
 B b;
 пользователь (&b); / / OK
 user2 (&b); / / плохая ошибка
 user3 (&b); // OK * если * программист получил проверку some_condition правильно
 }

##### Записка

Как и другие касты, "dynamic_cast" используется слишком часто.
[Предпочтение виртуальных функций кастингу] (#Rh-use-virtual).
Предпочитаю [статический полиморфизм] (#???) для навигации по иерархии, где это возможно (разрешение во время выполнения не требуется)
и довольно удобно.

##### Записка

Некоторые люди используют "dynamic_cast", где " typeid` был бы более подходящим;
'dynamic_cast' - это общая операция" is kind of " для обнаружения лучшего интерфейса к объекту,
в то время как "typeid" - это операция "дайте мне точный тип этого объекта", чтобы обнаружить фактический тип объекта.
Последнее является по своей сути более простой операцией, которая должна быть быстрее.
Последний ('typeid') легко изготавливается вручную, если это необходимо (например, если работа в системе, где RTTI - по какой-то причине-запрещена),
первый ("dynamic_cast") гораздо сложнее реализовать правильно в целом.

Считать:

 структура B {
 const char * name {"B"};
 // если pb1 - >id () = = pb2 - > > id () *pb1 имеет тот же тип, что и *pb2
 virtual const char* id() const { возвращаемое имя; }
 // ...
 };

 структура D : B {
 const char * name {"D"};
 const char* id() переопределение const { возвращаемое имя; }
 // ...
 };

 пустое использование()
 {
 B* pb1 = новый B;
 B* pb2 = новый D;

 cout < < pb1 - > id (); / / " B"
 cout < < pb2 - > id (); / / " D"


 если (pb1 - >id () = = "D") {//выглядит невинно
 D * pd = static_cast<D*>(pb1);
 // ...
 }
 // ...
 }

Результат `pb2 - >id () = = " D " фактически определен реализацией.
Мы добавили его, чтобы предупредить об опасности домашнего пива RTTI.
Этот код может работать так, как ожидалось в течение многих лет, просто для сбоя на новой машине, новом компиляторе или новом компоновщике, который не унифицирует символьные литералы.

Если вы реализуете свой собственный RTTI, будьте осторожны.

##### Исключение

Если ваша реализация предоставила действительно медленный 'dynamic_cast', вам, возможно, придется использовать обходной путь.
Однако все обходные пути, которые не могут быть решены статически, включают явное приведение (обычно "static_cast") и подвержены ошибкам.
Вы в основном будете создавать свой собственный специальный "dynamic_cast".
Итак, сначала убедитесь, что ваша "dynamic_cast" действительно так медленна, как вы думаете (есть довольно много неподдерживаемых слухов о)
и что ваше использование "dynamic_cast" действительно критично для производительности.

Мы считаем, что текущие реализации "dynamic_cast" являются неоправданно медленными.
Например, при подходящих условиях можно выполнить `dynamic_cast` в [быстром постоянном времени](http://www.stroustrup.com/fast_dynamic_casting.pdf).
Однако совместимость делает изменения трудными, даже если все согласны с тем, что усилия по оптимизации стоят того.

В очень редких случаях, если вы измерили, что накладные расходы "dynamic_cast" существенны, у вас есть другие средства статически гарантировать, что понижение будет успешным (например, вы используете CRTP осторожно), и нет никакого виртуального наследования, связанного с этим, рассмотрите тактически обращение к "static_cast" с заметным комментарием и отказом от ответственности, обобщающим этот параграф, и что человеческое внимание необходимо при обслуживании, потому что система типов не может проверить правильность. Тем не менее, в нашем опыте такие ситуации "я знаю, что я делаю" по-прежнему являются известным источником ошибок.

##### Исключение

Считать:

 шаблон<typename B>
 класс Dx : B {
 // ...
 };

##### Принуждение

* Флаг все виды использования "static_cast" для нисходящих передач, включая приведения в стиле C, которые выполняют "static_cast".
* Это правило является частью профиля [type-safety profile] (#Pro-type-downcast).

### <a name= "Rh-ref-cast" ><a name= "Rh-ref-cast">< / a > C. 147: используйте параметр ' dynamic_cast` для ссылочного типа, если ошибка поиска требуемого класса считается ошибкой

##### Причина

Приведение к ссылке выражает, что вы намерены в конечном итоге с допустимым объектом, поэтому приведение должно быть успешным. 'dynamic_cast' будет затем бросить, если это не удастся.

##### Образец

 ???

##### Принуждение

???

### <a name= "Rh-ptr-cast" ><a name= "Rh-ptr-cast">< / a > C. 148: используйте параметр 'dynamic_cast' для указателя типа, когда невозможность найти требуемый класс считается допустимой альтернативой

##### Причина

Преобразование "dynamic_cast" позволяет проверить, указывает ли указатель на полиморфный объект, который имеет данный класс в своей иерархии. Поскольку неспособность найти класс просто возвращает нулевое значение, он может быть протестирован во время выполнения. Это позволяет писать код, который может выбирать альтернативные пути в зависимости от результатов.

В отличие от [C. 147](#Rh-ptr-cast), где сбой является ошибкой и не должен использоваться для условного выполнения.

##### Образец

В приведенном ниже примере описывается функция ' add 'объекта' Shape_owner`, который принимает во владение построенные объекты` Shape'. Объекты также сортируются по видам в соответствии с их геометрическими атрибутами.
В этом примере `Shape 'не наследуется от 'Geometric_attributes'. Это делают только его подклассы.

 void add(Shape* const item)
 {
 // Право собственности всегда берется
 owned_shapes.emplace_back(item);

 // Проверьте атрибуты Geometric_attributes и добавьте фигуру в none / one / some / all видов

 если (auto even = dynamic_cast<Even_sided*>(item))
 {
 view_of_evens.emplace_back (даже);
 }

 if (auto trisym = dynamic_cast<Trilaterally_symmetrical*>(item))
 {
 view_of_trisyms.emplace_back (trisym);
 }
 }

##### Примечания

Неспособность найти требуемый класс приведет к тому, что 'dynamic_cast' вернет нулевое значение, а удаление ссылки на указатель с нулевым значением приведет к неопределенному поведению.
Поэтому результат 'dynamic_cast' всегда следует рассматривать так, как будто он может содержать нулевое значение, и проверять.

##### Принуждение

* (Комплекс) если не существует нулевого теста на результат `dynamic_cast` типа указателя, предупредите при разыменовании указателя.

### <a name= "Rh-smart" ><a name= "Rh-smart">< / a > C. 149: используйте `unique_ptr ' или 'shared_ptr', чтобы не забыть 'удалить' объекты, созданные с помощью ' new`

##### Причина

Избегайте утечки ресурсов.

##### Образец

 использование пустоты(int i)
 {
 auto p = new int {7}; / / bad: инициализация локальных указателей с помощью new
 auto q = make_unique<int>(9); / / ok: гарантируйте освобождение памяти, выделенной для 9
 если (0 
 исключить p; / / слишком поздно
 }

##### Принуждение

* Инициализация флага голого указателя с результатом ' new`
* Флаг 'delete' локальной переменной

### <a name= "Rh-make_unique" ><a name= "Rh-make_unique" >< / a>C. 150: используйте 'make_unique ()' для построения объектов, принадлежащих ' unique_ptr

##### Причина

`make_unique ' дает более краткое изложение конструкции.
Он также обеспечивает безопасность исключений в сложных выражениях.

##### Образец

 unique_ptr<Foo> p {new Foo{7}}; / / OK: но повторяющийся

 auto q = make_unique<Foo>(7); / / лучше: нет повторения Foo

 // Not exception-safe: компилятор может чередовать вычисления аргументов следующим образом:
 //
 // 1. выделите память для Foo,
 // 2. построить Foo,
 // 3. панель вызовов,
 // 4. построить unique_ptr<Foo>.
 //
 // Если бар бросает, Foo не будет уничтожен, и выделенная для него память будет протекать.
 f (unique_ptr<Foo>(new Foo ()), bar());

 // Exception-safe: вызовы функций никогда не чередуются.
 f (make_unique<Foo> (), bar());

##### Принуждение

* Отметьте повторяющееся использование списка специализации шаблона ' <Foo>`
* Переменные флага, объявленные как ' unique_ptr<Foo>`

### <a name= "Rh-make_shared" ><a name= "Rh-make_shared">< / a > C. 151: используйте 'make_shared ()' для построения объектов, принадлежащих ' shared_ptr

##### Причина

`make_shared ' дает более сжатое изложение конструкции.
Это также дает возможность устранить отдельное выделение для ссылочных счетчиков, поместив счетчики использования 'shared_ptr' рядом со своим объектом.

##### Образец

 испытание на пустоту() {
 // OK: но повторяющиеся; и отдельные выделения для бара и счет использования shared_ptr
 shared_ptr<Bar > p {новый бар{7}};

 auto q = make_shared<Bar > (7); / / лучше: нет повторения бара; один объект
 }

##### Принуждение

* Отметьте повторяющееся использование списка специализации шаблона' < Bar>`
* Переменные флага, объявленные как ' shared_ptr<Bar>`

### <a name= "Rh-array" ><a name= "Rh-array" >< / a > C. 152: никогда не назначайте указатель на массив производных объектов класса указателю на его базу

##### Причина

Подписка на полученный базовый указатель приведет к недопустимому доступу к объекту и, возможно, к повреждению памяти.

##### Образец

 struct B { int x; };
 структура D: B { int y; };

 пустое использование(B*);

 D a[] = {{1, 2}, {3, 4}, {5, 6}};
 B* p = a; / / bad: a распадается на &A[0], который преобразуется в A B*
 p[1].x = 7; / / перезаписать D[0].y

 use(a); / / bad: a распадается на &A[0], который преобразуется в A B*

##### Принуждение

* Отметьте все комбинации распада массива и преобразования базы в производные.
* Передайте массив как 'span', а не как указатель, и не позволяйте имени массива страдать от преобразования производного в базовое, прежде чем попасть в `span`


### <a name= "Rh-use-virtual" ><a name= "Rh-use-virtual">< / a > C. 153: предпочтение виртуальной функции перед литьем

##### Причина

Вызов виртуальной функции безопасен, в то время как приведение подвержено ошибкам.
Вызов виртуальной функции достигает наиболее производной функции, в то время как приведение может достигать промежуточного класса и поэтому
дайте неверный результат (тем более, что иерархия изменяется во время обслуживания).

##### Образец

 ???

##### Принуждение

Смотрите [C. 146] (#Rh-dynamic_cast) и ???

## <a name= "SS-overload"><a name= "SS-overload">< / a > C. over: перегрузка и перегруженные операторы

Вы можете перегружать обычные функции, функции шаблона и операторы.
Вы не можете перегрузить объекты функций.

Сводка правил перегрузки:

* [C. 160: определение операторов в основном для имитации обычного использования] (#Ro-conventional)
* [C. 161: использование несимметричных функций для симметричных операторов] (#Ro-simmetric)
* [C. 162: операции перегрузки, которые примерно эквивалентны] (#Ro-эквивалент)
* [C. 163: перегрузка только для операций, которые примерно эквивалентны] (#Ro-equivalent-2)
* [C. 164: избегайте неявных операторов преобразования] (#Ro-conversion)
* [C. 165: используйте `using ' для точек настройки] (#Ro-custom)
* [C. 166: перегрузка унарных ` & ' только в рамках системы интеллектуальных указателей и ссылок] (#Ro-address-of)
* [C. 167: Используйте оператор для операции с ее обычным значением] (#Ro-перегрузка)
* [C. 168: определение перегруженных операторов в пространстве имен их операндов] (#Ro-namespace)
* [C. 170: Если вы чувствуете, что перегружаете лямбда, используйте общий лямбда] (#Ro-lambda)

### <a name= "Ro-conventional" ><a name= "Ro-conventional">< / a > C. 160: определение операторов в основном для имитации обычного использования

##### Причина

Минимизировать сюрпризы.

##### Образец

 класс X {
 Публично:
 // ...
 X & operator=(const X&); // функция-член, определяющая назначение
 оператор friend bool==(const X&, const X&); / / = = требуется доступ к представлению
 // после a = b имеем a == b
 // ...
 };

Здесь сохраняется условная семантика: [Copies compare equal] (#SS-copy).

##### Пример, плохо

 Оператор X+(X a, X b) { return a. v-b. v;} / / bad: заставляет + вычитать

##### Записка

Немембранные операторы должны быть либо друзьями, либо определены в [том же пространстве имен, что и их операнды](#Ro-пространство имен).
[Бинарные операторы должны обращаться со своими операндами эквивалентно] (#Ro-симметрично).

##### Принуждение

Возможно, даже невозможно.

### <a name= "Ro-simmetric" ><a name= "Ro-simmetric">< / a > C. 161: использование несимметричных функций для симметричных операторов

##### Причина

Если вы используете функции-члены, вам нужно два.
Если вы не используете несемберную функцию для (скажем)`==`, `a == b` и `b == a` будут немного отличаться.

##### Образец

 оператор bool= = (точка a, точка b) { return a. x = = b. x && a. y == b. y; }

##### Принуждение

Функции оператора члена флага.

### <a name= "Ro-эквивалент" ><a name= "Ro-эквивалент" >< / a > C. 162: операции перегрузки, которые примерно эквивалентны

##### Причина

Наличие различных имен для логически эквивалентных операций над различными типами аргументов приводит к путанице, приводит к кодированию информации о типе в именах функций и препятствует универсальному программированию.

##### Образец

Считать:

 void print(int a);
 void print(int a, int base);
 пустая печать(строка const&);

Все эти три функции печатают свои аргументы (соответствующим образом). Напротив:

 void print_int(int a);
 void print_based(int a, int base);
 void print_string(const string&);

Все эти три функции печатают свои аргументы (соответствующим образом). Добавление к названию просто вводит многословность и блокирует общий код.

##### Принуждение

???

### <a name= "Ro-equivalent-2" ><a name= "Ro-equivalent-2" >< / a > C. 163: перегрузка только для операций, которые примерно эквивалентны

##### Причина

Наличие одного и того же имени Для логически различных функций приводит к путанице и ошибкам при использовании общего программирования.

##### Образец

Считать:

 void open_gate(Gate& g); / / удалить препятствие с выездной полосы гаража
 void fopen(const char * name, const char * mode); / / открыть файл

Эти две операции принципиально различны (и не связаны), поэтому хорошо, что их названия отличаются. Напротив:

 пустота открыть (ворота& g); / / удалить препятствие из гаража выездной полосы
 void open(const char * name, const char * mode = "r"); / / open file

Эти две операции по-прежнему принципиально различны (и не связаны), но названия были сведены к их (общему) минимуму, что открывает возможности для путаницы.
К счастью, система типов будет ловить много таких ошибок.

##### Записка

Будьте особенно осторожны с распространенными и популярными именами, такими как "открыть", "переместить", " + "и"==".

##### Принуждение

???

### <a name= "Ro-conversion" ><a name= "Ro-conversion" >< / a > C. 164: избегайте неявных операторов преобразования

##### Причина

Неявные преобразования могут быть существенными (например, `double` в `int`), но часто вызывают сюрпризы (например, `String` в строку C-style).

##### Записка

Предпочитайте явно именованные преобразования, пока не будет продемонстрирована серьезная потребность.
Под "серьезной потребностью" мы подразумеваем причину, которая является фундаментальной в области применения (например, преобразование целого числа в комплексное число)
и часто Это было необходимо. Не вводите неявные преобразования (с помощью операторов преобразования или неявных конструкторов)
просто чтобы получить небольшое удобство.

##### Образец

 структура S1 {
 строка s;
 // ...
 оператор char* () { return s. data ();} / / плохой, скорее всего, вызовет сюрпризы
 };

 struct S2 {
 строка s;
 // ...
 явный оператор char* () { return s. data(); }
 };

 пустота f(S1 s1, S2 s2)
 {
 char* x1 = s1; / / OK, но может вызывать сюрпризы во многих контекстах
 char* x2 = s2; / / ошибка (и это обычно хорошо)
 char * x3 = static_cast<char*>(s2); // мы можем быть явными (на вашей голове это будет)
 }

Неожиданное и потенциально опасное неявное преобразование может происходить в произвольно труднодоступных контекстах, например,

 S1 ff();

 char* g()
 {
 возвращение ff();
 }

Строка, возвращенная `ff ()', уничтожается до того, как возвращенный указатель в нее может быть использован.

##### Принуждение

Отметьте все операторы преобразования.

### <a name= "Ro-custom"><a name= "Ro-custom">< / a > C. 165: используйте `using " для точек настройки

##### Причина

Чтобы найти функциональные объекты и функции, определенные в отдельном пространстве имен, чтобы "настроить" общую функцию.

##### Образец

Рассмотрим `своп'. Это общая (стандартная библиотека) функция с определением, которое будет работать практически для любого типа.
Тем не менее, желательно определить конкретные `swap()`s для конкретных типов.
Например, общая 'swap ()' скопирует элементы двух ' векторов, которые будут заменены, в то время как хорошая конкретная реализация вообще не будет копировать элементы.

 пространство имен N {
 My_type X { / * ... */ };
 void swap(X&, X&); / / оптимизированный своп для N:: X
 // ...
 }

 void f1(N:: X& a, N:: X& b)
 {
 std:: swap(a, b); / / вероятно, не то, что мы хотели: вызовы std:: swap()
 }

'Std:: swap () `в` f1 () `делает именно то, что мы просили его сделать: он вызывает` swap () `в пространстве имен`std'.
К сожалению, это, вероятно, не то, что мы хотели.
Как мы получаем` N::X ' рассматривается?

 пустота f2(N:: X& a, N:: X& b)
 {
 swap(a, b); / / вызовы N:: swap
 }

Но это может быть не то, что мы хотели для общего кода.
Там мы обычно хотим конкретную функцию, если она существует, и общую функцию, если ее нет.
Это делается путем включения общей функции в поиск для функции:

 пустота f3(N:: X& a, N:: X& b)
 {
 использование std:: swap; / / сделать std:: swap доступным
 swap(a, b); / / вызывает N:: swap, если он существует, в противном случае std:: swap
 }

##### Принуждение

Маловероятно, за исключением известных точек настройки, таких как "swap".
Проблема заключается в том, что неквалифицированные и квалифицированные поиски оба имеют использование.

### <a name= "Ro-address-of" ><a name= "Ro-address-of" >< / a > C. 166: перегрузка унарных ` & ' только в рамках системы интеллектуальных указателей и ссылок

##### Причина

Оператор ` & ' является фундаментальным в языке C++.
Многие части семантики C++ принимают значение по умолчанию.

##### Образец

 класс Ptr {//несколько умный указатель
 Ptr(X* pp) :p (pp) {/*проверить */ }
 Оператор X* - > () {/*проверка * / возврат p; }
 X оператор [] (int i);
 Оператор X*();
 Частное:
 Т* р;
 };

 класс X {
 Ptr оператор& () { return Ptr{this}; }
 // ...
 };

##### Записка

Если вы" связываетесь "с оператором'&', убедитесь, что его определение имеет соответствующие значения для`->`, `[]`, `*`, и еще.` о типе результата.
Обратите внимание, что оператор `."в настоящее время нельзя перегружать, поэтому идеальная система невозможна.
Мы надеемся исправить это: <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf>.
Обратите внимание, что` std::addressof () ' всегда дает встроенный указатель.

##### Принуждение

Хитрый. Предупредите, если `&` определяется пользователем без определения также '- > ' для типа результата.

### <a name= "Ro-overload"><a name= "Ro-overload" >< / a > C. 167: Используйте оператор для операции с ее обычным значением

##### Причина

Удобочитаемость. Конвенция. Возможность повторного использования. Поддержка универсального кода

##### Образец

 void cout_my_class(const My_class& c) / / запутанный, не обычный, не общий
 {
 std:: cout < */;
 }

 std:: ostream & operator<
 {
 возврат ОС < */;
 }

Сам по себе, `cout_my_class ' был бы в порядке, но он не может быть использован / скомпонован с кодом, который полагается на `<:

 My_class var { / * ... */ };
 // ...
 cout < < "var =" < < var <;

##### Записка

Существуют сильные и энергичные соглашения для значения большинства операторов, таких как

* сравнения ('==','!=`, `<`, `<=`, `>`, и еще ... `<=`, `>>=`),
* арифметические операции (`+`, `-`, `*`, `/`, и' %`)
* операции доступа (`.` , '- >', одинарный`*', и' [] `)
* назначение`=`( )

Не определяйте их нетрадиционно и не придумывайте для них собственных имен.

##### Принуждение

Хитрый. Требуется семантическая проницательность.

### <a name= "Ro-namespace" ><a name= "Ro-namespace" >< / a > C. 168: определение перегруженных операторов в пространстве имен их операндов

##### Причина

Удобочитаемость.
Возможность поиска операторов с помощью ADL.
Избежание несогласованного определения в различных пространствах имен

##### Образец

 структура S { };
 оператор bool==(S, S); / / OK: в том же пространстве имен, что и S, и даже рядом с S
 S s;

 bool x = (s == s);

Вот что сделал бы дефолт'==', если бы у нас были такие дефолты.

##### Образец

 пространство имен N {
 структура S { };
 оператор bool==(S, S); / / OK: в том же пространстве имен, что и S, и даже рядом с S
 }

 N:: S s;

 bool x = (s == s); // находит N:: оператор== () по ADL

##### Пример, плохо

 структура S { };
 S s;

 пространство имен N {
 S:: оператор!(S a) { вернуть true; }
 S not_s = !с;
 }

 пространство имен M {
 S:: оператор!(S a) { вернуть false; }
 S not_s = !с;
 }

Вот вам и значение слова'!s 'отличается от `N`и 'M'.
Это может быть очень запутанным.
Удалите определение "пространство имен M", и путаница будет заменена возможностью сделать ошибку.

##### Записка

Если двоичный оператор определен для двух типов, которые определены в разных пространствах имен, вы не можете следовать этому правилу.
Например:

 Vec:: векторный оператор*(const Vec:: вектор&, const Mat:: Матрица&);

Возможно, этого лучше всего избегать.

##### Смотреть также

Это частный случай правила ,что [вспомогательные функции должны быть определены в том же пространстве имен, что и их класс] (#Rc-helper).

##### Принуждение

* Определения операторов флагов, которые не являются пространством имен их операндов

### <a name= "Ro-lambda" ><a name= "Ro-lambda" >< / a > C. 170: Если вы хотите перегрузить лямбду, используйте общий лямбда-код

##### Причина

Вы не можете перегружать, определяя два разных лямбда с одним и тем же именем.

##### Образец

 void f(int);
 void f (double);
 auto f = [](char); / / ошибка: не удается перегрузить переменную и функцию

 auto g = [] (int) { /* ... */ };
 auto g = [] (double) { /* ... * / }; / / ошибка: невозможно перегрузить переменные

 auto h = [] (auto) { /* ... * / }; / / OK

##### Принуждение

Компилятор перехватывает попытку перегрузки лямбда-кода.

## <a name= "SS-union" ><a name= "SS-union" >< / a>C. Союз: союзы

"Союз" - это структура, в которой все члены начинаются с одного и того же адреса, так что он может содержать только один член одновременно.
"Союз` не отслеживает, какой член хранится, поэтому программист должен получить его правильно;
это по своей сути подвержено ошибкам, но есть способы компенсировать их.

Тип, который является "объединением" плюс индикатор того, какой член в настоящее время удерживается, называется *tagged union*, a *discriminated union* или A *variant*.

Свод правил профсоюзов:

* [C. 180: используйте ' union для сохранения памяти] (#Ru-union)
* [C. 181: избегайте Союза" голый"] (#Ru-naked)
* [C. 182: используйте anonymous ' union для реализации помеченных союзов] (#Ru-anonymous)
* [C. 183: Не используйте ' union` для каламбуры типа] (#Ru-pun)
* ???

### <a name= "Ru-union" ><a name= "Ru-union" >< / a > C. 180: используйте ' union для сохранения памяти

##### Причина

"Объединение" позволяет использовать один фрагмент памяти для различных типов объектов в разное время.
Следовательно, он может быть использован для сохранения памяти, когда у нас есть несколько объектов, которые никогда не используются одновременно.

##### Образец

 значение объединения {
 int x;
 двойной d;
 };

 Значение v = { 123 }; / / теперь v содержит int
 cout < < v. x <
 v. d = 987.654; / / теперь v содержит двойник
 cout < < v. d <

Но обратите внимание на предупреждение: [избегайте" голого " Союза] (#Ru-naked)

##### Образец

 // Оптимизация короткой строки

 constexpr size_t buffer_size = 16; / / чуть больше размера указателя

 класс Immutable_string {
 Публично:
 Immutable_string(const char* str) :
 размер (strlen (str))
 {
 если (размер )
 strcpy_s(string_buffer, buffer_size, str);
 еще {
 string_ptr = новый символ[размер + 1];
 strcpy_s(string_ptr, size + 1, str);
 }
 }

 ~Immutable_string()
 {
 if (size >= buffer_size)
 удалить string_ptr;
 }

 const char* get_str() const
 {
 возврат (размер  string_buffer : string_ptr;
 }

 Частное:
 // Если строка достаточно коротка, мы сохраняем саму строку
 // вместо указателя на строку.
 союз {
 char * string_ptr;
 char string_buffer[buffer_size];
 };

 const size_t размер;
 };

##### Принуждение

???

### <a name= "Ru-naked"><a name="Ru-naked "></a>C. 181: избегайте Союза" голый

##### Причина

A * naked union* - это объединение без связанного индикатора, который является его членом (если таковой имеется).,
так что программист должен следить за этим.
Голые союзы являются источником ошибок типа.

##### Пример, плохо

 значение объединения {
 int x;
 двойной d;
 };

 Значение v;
 v. d = 987.654; / / v имеет двойное значение

Пока все хорошо, но мы можем легко злоупотреблять " Союзом`:

 cout < < v. x <

Обратите внимание, что ошибка типа произошла без явного приведения.
Когда мы тестировали эту программу, последнее напечатанное значение было '1683627180`, которое является целочисленным значением для битового шаблона для`987.654'.
То, что мы имеем здесь, - это "невидимая" ошибка типа, которая случайно дает результат, который легко может выглядеть невинным.

И, говоря о "невидимом", этот код не произвел никакого вывода:

 v. x = 123;
 cout < < v. d <

##### Альтернатива

Оберните 'объединение' в класс вместе с полем типа.

Тип C++17 `variant` (найденный в `<variant>') делает это за вас:

 вариант<int, double > v;
 v = 123; / / v содержит int
 int x = get<int>(v);
 v = 123.456; / / v имеет двойное значение
 w = get < double > (v);

##### Принуждение

???

### <a name= "Ru-anonymous" ><a name= "Ru-anonymous">< / a > C. 182: используйте anonymous ' union для реализации помеченных союзов

##### Причина

Хорошо продуманное помеченное объединение является типобезопасным.
* Anonymous * union упрощает определение класса с парой (tag, union).

##### Образец

Этот пример в основном заимствован из TC++PL4 pp216-218.
Вы можете посмотреть там для объяснения.

Этот код довольно сложный.
Обработка типа с пользовательским назначением и деструктором является сложной задачей.
Сохранение программистов от необходимости писать такой код является одной из причин включения "variant" в стандарт.

 значение класса {//два альтернативных представления, представленных в виде объединения
 Частное:
 enum class Tag { число, текст };
 Тип тега; / / дискриминант

 union {//representation (Примечание: анонимный Союз)
 int i;
 строка s; / / string имеет конструктор по умолчанию, операции копирования и деструктор
 };
 Публично:
 struct Bad_entry {}; / / используется для исключений

 ~Значение();
 Значение & operator=(const Value&); / / необходимо из-за варианта строки
 Значение (const Value&);
 // ...
 int number () const;
 текст строки () const;

 void set_number(int n);
 void set_text(строка const&);
 // ...
 };

 int Value:: number () const
 {
 если (типа != Tag:: номер) throw Bad_entry{};
 возвращение i;
 }

 строковое значение:: text () const
 {
 если (типа != Tag:: text) throw Bad_entry{};
 возврат s;
 }

 пустое значение:: set_number(int n)
 {
 если (type = = Tag:: text) {
 s.~string (); / / явно уничтожить строку
 type = Tag:: номер;
 }
 i = n;
 }

 пустое значение:: set_text(const string& ss)
 {
 если (type = = Tag:: text)
 s = ss;
 еще {
 new (&s) string{ss}; / / placement new: явно построить строку
 type = Tag:: текст;
 }
 }

 Value& Value:: operator=(const Value& e) / / необходимо из-за варианта строки
 {
 если (type = = Tag:: text & & E. type = = Tag:: text) {
 s = e. s; / / обычное назначение строк
 возвращение *это;
 }

 если (type = = Tag:: text) s.~string (); / / явное уничтожение

 переключатель (e. тип) {
 бирка случая:: номер:
 i = e. i;
 ломать;
 бирка случая:: текст:
 new (&s) string (e. s); / / placement new: явная конструкция
 }

 type = e. тип;
 возвращение *это;
 }

 Value::~Value()
 {
 если (type = = Tag:: text) s.~string (); / / явное уничтожение
 }

##### Принуждение

???

### <a name= "Ru-pun" ><a name= "Ru-pun">< / a > C. 183: Не используйте ' union` для каламбура типа

##### Причина

Это неопределенное поведение, чтобы прочитать` union ' член с другим типом от того, с которым он был написан.
Такой каламбур невидим, или, по крайней мере, его труднее обнаружить, чем использовать именованный бросок.
Тип каламбура с использованием "союза" является источником ошибок.

##### Пример, плохо

 Союз каламбура {
 int x;
 unsigned char c[sizeof(int)];
 };

Идея "каламбура" заключается в том, чтобы иметь возможность смотреть на символьное представление "int".

 пустота плохая(каламбур& u)
 {
 u. x = 'x';
 cout < < u. c[0] <
 }

Если вы хотите видеть байты 'int', используйте (именованное) приведение:

 void if_you_must_pun(int& x)
 {
 auto p = reinterpret_cast<unsigned char*>(&x);
 cout << p[0] <
 // ...
 }

Доступ к результату 'reinterpret_cast' к другому типу из объявленного типа объектов определяется поведением (даже если 'reinterpret_cast' не рекомендуется),
но, по крайней мере, мы можем видеть, что происходит что-то хитрое.

##### Записка

К сожалению, ' union обычно используются для каламбуров типа.
Мы не считаем, что "иногда это работает так, как ожидалось" сильный аргумент.

C++17 ввел отдельный тип 'std:: byte' для облегчения операций над представлением необработанных объектов. Используйте этот тип вместо 'unsigned char' или 'char' для этих операций.

##### Принуждение

???



# <a name= "S-enum"><a name= "S-enum" >< / a>Enum: перечисления

Перечисления используются для определения наборов целочисленных значений и для определения типов для таких наборов значений.
Существует два вида перечислений:" простые "перечисления и " классовые перечисления".

Сводка правил перечисления:

* [Перечисление.1: предпочтение перечислений над макросами] (#Renum-macro)
* [Перечисление.2: Используйте перечисления для представления наборов связанных именованных констант] (#Renum-set)
* [Перечисление.3: предпочитайте 'enum class'es вместо" plain " enum's] (#Renum-class)
* [Перечисление.4: определение операций над перечислениями для безопасного и простого использования] (#Renum-oper)
* [Перечисление.5: Не используйте 'ALL_CAPS' для перечислителей] (#Renum-caps)
* [Перечисление.6: Избегайте неназванных перечислений] (#Renum-безымянный)
* [Перечисление.7: укажите базовый тип перечисления только в случае необходимости](#Renum-базовый тип)
* [Перечисление.8: укажите значения перечислителя только при необходимости] (#Renum-value)

### <a name= "Renum-macro"><a name="Renum-macro" ></a>перечисление.1: предпочтение перечислений над макросами

##### Причина

Макросы не подчиняются правилам области и типа. Кроме того, имена макросов удаляются во время предварительной обработки и поэтому обычно не отображаются в таких инструментах, как отладчики.

##### Образец

Сначала какой-то старый плохой код:

 // webcolors.h (заголовок третьей стороны)
 #определить красный 0xFF0000
 #определить зеленый 0x00FF00
 #определите синий 0x0000FF

 // productinfo.х
 // Ниже приведены определения подтипов продуктов на основе цвета
 #определить красный 0
 #определить фиолетовый 1
 #определить синий 2

 int webby = синий; / / webby == 2; вероятно, не то, что было желательно

Вместо этого используйте ' enum`:

 enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
 enum class Product_info { red = 0, purple = 1, blue = 2 };

 int webby = синий; / / ошибка: быть конкретным
 Web_color webby = Web_color:: синий;

Мы использовали класс enum, чтобы избежать столкновения имен.

##### Принуждение

Флаг макросы, которые определяют целочисленные значения.


### <a name= "Renum-set"><a name="Renum-set" ></a>Enum.2: Используйте перечисления для представления наборов связанных именованных констант

##### Причина

Перечисление показывает, что перечислители должны быть связаны и могут быть именованным типом.



##### Образец

 enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };


##### Записка

Включение перечисления является распространенным явлением, и компилятор может предупреждать о необычных шаблонах меток регистра. Например:

 enum class Product_info { red = 0, purple = 1, blue = 2 };

 void print(Product_info inf)
 {
 переключатель (inf) {
 case Product_info:: red: cout <;
 case Product_info:: purple: cout <;
 }
 }

Такие off-by-one `switch` - операторы часто являются результатами добавленного перечислителя и недостаточного тестирования.

##### Принуждение

* Флаг 'switch' - операторы, где ' дело охватывает большинство, но не все перечислители перечисления.
* Флаг 'switch' - операторы, где ' case охватывает несколько перечислителей перечисления, но не имеет `default`.


### <a name= "Renum-class"><a name="Renum-class" ></a>перечисление.3: предпочтите перечисления класса над" простыми " перечислениями

##### Причина

Чтобы свести к минимуму сюрпризы: традиционные перечисления слишком легко преобразуются в int.

##### Образец

 void Print_color(int color);

 enum Web_color { красный = 0xFF0000, зеленый = 0x00FF00, синий = 0x0000FF };
 enum Product_info { красный = 0, фиолетовый = 1, синий = 2 };

 Web_color webby = Web_color:: синий;

 // Очевидно, что по крайней мере один из этих вызовов является багги.
 Print_color(webby);
 Print_color(Product_info:: blue);

Вместо этого используйте `enum class`:

 void Print_color(int color);

 enum class Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF };
 enum class Product_info { red = 0, purple = 1, blue = 2 };

 Web_color webby = Web_color:: синий;
 Print_color(webby); / / ошибка: не удается преобразовать Web_color в int.
 Print_color(Product_info:: red); / / ошибка: не удается преобразовать Product_info в int.

##### Принуждение

(Простой) предупредите о любом неклассовом определении "перечисления".

### <a name= "Renum-oper"><a name="Renum-oper" ></a>Enum.4: определение операций над перечислениями для безопасного и простого использования

##### Причина

Удобство использования и избежание ошибок.

##### Образец

 перечислять день { пн, вт, ср, чт, пт, сб, вс };

 День и оператор++(Day& d)
 {
 возвращение d = (D == Day::sun) ? День:: пн: static_cast<Day > (static_cast<Day > <int>(d)+1);
 }

 День сегодня = День:: СБ;
 День завтра = ++сегодня;

Использование " static_cast` не очень красиво, но

 День и оператор++(Day& d)
 {
 возвращение d = (D == Day::sun) ? День:: пн: день{++d}; / / ошибка
 }

это бесконечная рекурсия, и написание ее без приведения, используя "переключатель" на всех случаях является многословным.


##### Принуждение

Флаг повторяющиеся выражения отбрасываются обратно в перечисление.


### <a name= "Renum-caps"><a name="Renum-caps" ></a>перечисление.5: Не используйте ' ALL_CAPS` для перечислителей

##### Причина

Избегайте столкновений с макросами.

##### Пример, плохо

 // webcolors.h (заголовок третьей стороны)
 #определить красный 0xFF0000
 #определить зеленый 0x00FF00
 #определите синий 0x0000FF

 // productinfo.х
 // Ниже приведены определения подтипов продуктов на основе цвета

 enum class Product_info { RED, PURPLE, BLUE}; / / синтаксическая ошибка

##### Принуждение

Отметьте перечислители ALL_CAPS.

### <a name= "Renum-unnamed"></a>Enum.6: Избегайте неназванных перечислений

##### Причина

Если вы не можете назвать перечисление, значения не связаны

##### Пример, плохо

 перечисление { red = 0xFF0000, scale = 4, is_signed = 1 };

Такой код не является редкостью в коде, написанном до того, как появились удобные альтернативные способы задания целочисленных констант.

##### Альтернатива

Вместо этого используйте значения `constexpr`. Например:

 constexpr int red = 0xFF0000;
 constexpr short scale = 4;
 constexpr bool is_signed = true;

##### Принуждение

Флаг безымянные перечисления.


### <a name= "Renum-underlying"></a>Enum.7: укажите базовый тип перечисления только в случае необходимости

##### Причина

Значение по умолчанию является самым простым для чтения и записи.
'int' является целочисленным типом по умолчанию.
'int' совместим с C ' enum.

##### Образец

 перечисление класс направление : char { n, s, e, w,
 ne, nw, se, sw}; / / базовый тип экономит место

 enum class Web_color: int32_t { red = 0xFF0000,
 зеленый = 0x00FF00,
 синий = 0x0000FF }; / / базовый тип является избыточным

##### Записка

Указание базового типа необходимо в прямых объявлениях перечислений:

 enum флаги : char;

 void f (флаги);

 // ....

 флаги enum: char { / * ... */ };


##### Принуждение

????


### <a name= "Renum-value"><a name="Renum-value" ></a>Enum.8: укажите значения перечислителя только при необходимости

##### Причина

Это самое простое.
Это позволяет избежать дублирования значений перечислителя.
Значение по умолчанию дает последовательный набор значений, который хорош для реализаций оператора`switch ' -statement.

##### Образец

 enum class Col1 { красный, желтый, синий };
 enum class Col2 { красный = 1, желтый = 2, синий = 2 }; / / опечатка
 enum class Month { jan = 1, feb, mar, apr, may, jun,
 Июль, Август, Сентябрь, Октябрь, Ноябрь, Декабрь }; / / начиная с 1 условно
 enum class Base_flag { dec = 1, oct = dec << 1, hex = dec <

Указание значений необходимо для соответствия обычным значениям (например, ' месяц`)
и где последовательные значения нежелательны (например, чтобы получить отдельные биты, как в `Base_flag`).

##### Принуждение

* Флаг повторяющиеся значения перечислителя
* Флаг явно указаны все последовательные значения перечислителя


# <a name= "s-resource" ><a name= "S-resource" >< / a>R: управление ресурсами

Этот раздел содержит правила, связанные с ресурсами.
Ресурс-это все, что должно быть получено и (явно или неявно) освобождено, например память, дескрипторы файлов, сокеты и блокировки.
Причина, по которой он должен быть выпущен, как правило, заключается в том, что он может быть в дефиците, поэтому даже отсроченный выпуск может нанести вред.
Основная цель состоит в том, чтобы убедиться, что мы не утечка каких-либо ресурсов и что мы не держим ресурс дольше, чем это необходимо.
Сущность, ответственная за высвобождение ресурса, называется владельцем.

Есть несколько случаев, когда утечки могут быть приемлемыми или даже оптимальными:
Если вы пишете программу, которая просто производит вывод на основе входного сигнала, и объем необходимой памяти пропорционален размеру входного сигнала, оптимальной стратегией (для производительности и простоты программирования) иногда просто никогда ничего не удалять.
Если у вас достаточно памяти для обработки вашего самого большого входного сигнала, утечка, но не забудьте дать хорошее сообщение об ошибке, если вы ошибаетесь.
Здесь мы игнорируем такие случаи.

* Свод правил управления ресурсами:

 * [R. 1: автоматическое управление ресурсами с помощью дескрипторов ресурсов и RAII (инициализация сбора ресурсов)] (#Rr-raii)
 * [R. 2: в интерфейсах используйте необработанные указатели для обозначения отдельных объектов (только)] (#Rr-use-ptr)
 * [R. 3: необработанный указатель (a ' T*) не является владельцем] (#Rr-ptr)
 * [R. 4: необработанная ссылка (a `T&`) не является собственностью] (#Rr-ref)
 * [R. 5: предпочитайте объекты с областью действия, не создавайте ненужную кучу] (#Rr-область действия)
 * [R. 6: Избегайте не - 'const' глобальных переменных] (#Rr-global)

* Резюме правил распределения и освобождения средств:

 * [R. 10: избегайте `malloc () ' и ' free ()`] (#Rr-mallocfree)
 * [R. 11: избегайте вызова` new `и` delete ' явно] (#Rr-newdelete)
 * [R. 12: немедленно дайте результат явного выделения ресурсов объекту диспетчера] (#Rr-immediate-alloc)
 * [R. 13: Выполните не более одного явного выделения ресурсов в одном операторе выражения] (#Rr-single-alloc)
 * [R. 14: избегайте параметров ` []', предпочитайте 'span'] (#Rr-ap)
 * [R. 15: всегда перегружайте сопрягаемые пары распределения / deallocation] (#RR-pair)

* <a name= "Rr-summary-smartptrs" ><a name="Rr-summary-smartptrs" ></a>правило интеллектуального указателя резюме:

 * [R. 20: используйте `unique_ptr ' или 'shared_ptr' для представления права собственности] (#RR-owner)
 * [R. 21: предпочтите `unique_ptr " над "shared_ptr", если вам не нужно делиться собственностью] (#Rr-unique)
 * [R. 22: используйте ' make_shared ()', чтобы сделать ' shared_ptr's] (#Rr-make_shared)
 * [R. 23: используйте ' make_unique ()', чтобы сделать ' unique_ptr's] (#Rr-make_unique)
 * [R. 24: используйте 'std:: weak_ptr' для разрыва циклов ' shared_ptr's] (#Rr-weak_ptr)
 * [R. 30: возьмите интеллектуальные указатели в качестве параметров только для явного выражения семантики времени жизни] (#Rr-smartptrparam)
 * [R. 31: Если у вас есть не - ` std 'смарт-указатели, следуйте основной шаблон из 'std'] (#Rr-smart)
 * [R. 32: возьмите параметр ' unique_ptr<widget>', чтобы выразить, что функция принимает владение 'виджетом'] (#Rr-uniqueptrparam)
 * [R. 33: возьмите параметр ' unique_ptr<widget>&', чтобы выразить, что функция повторно устанавливает 'widget'] (#Rr-reseat)
 * [R. 34: возьмите параметр ' shared_ptr<widget>', чтобы выразить, что функция является частичным владельцем] (#Rr-sharedptrparam-owner)
 * [R. 35: возьмите параметр ' shared_ptr<widget>&', чтобы выразить, что функция может повторно установить общий указатель] (#Rr-sharedptrparam)
 * [R. 36: возьмите параметр` const shared_ptr<widget>&', чтобы выразить, что он может сохранить количество ссылок на объект ???] (#Rr-sharedptrparam-const)
 * [R. 37: не передавайте указатель или ссылку, полученную из псевдонимного смарт-указателя] (#Rr-smartptrget)

### <a name= "Rr-raii" ><a name= "Rr-raii" >< / a>R. 1: автоматическое управление ресурсами с помощью дескрипторов ресурсов и RAII (получение ресурсов инициализируется)

##### Причина

Чтобы избежать утечек и сложности ручного управления ресурсами.
Симметрия конструктора / деструктора языка C++отражает симметрию, присущую парам функций получения/освобождения ресурсов, таким как "fopen" / "fclose", "lock" / "unlock" и " new " / "delete".
Всякий раз, когда вы имеете дело с ресурсом, который нуждается в сопряженных вызовах функции acquire/release, инкапсулируйте этот ресурс в объект, который принудительно выполняет сопряжение для вас-получите ресурс в его конструкторе и освободите его в своем деструкторе.

##### Пример, плохо

Считать:

 void send(X* x, cstring_span destination)
 {
 auto port = open_port (место назначения);
 my_mutex.замок();
 // ...
 отправить(порт, x);
 // ...
 my_mutex.открывать();
 close_port(порт);
 удалить x;
 }

В этом коде вы должны помнить, чтобы "разблокировать", "close_port" и "удалить" на всех путях, и сделать каждый ровно один раз.
Далее, если какой-либо код отмечен `...'создает исключение, затем` x' пропускается и `my_mutex ' остается заблокированным.

##### Образец

Считать:

 void send(unique_ptr<X> x, назначение cstring_span) / / x владеет X
 {
 Port port{destination}; / / port владеет Портландом
 lock_guard<mutex > guard{my_mutex}; / / guard владеет замком
 // ...
 отправить(порт, x);
 // ...
 } / / автоматически разблокирует my_mutex и удаляет указатель в x

Теперь вся очистка ресурсов происходит автоматически, выполняется один раз по всем путям независимо от наличия исключения. В качестве бонуса функция теперь объявляет, что она берет на себя владение указателем.

Что такое "порт"? Удобная оболочка, которая инкапсулирует ресурс:

 порт класса {
 Порт PortHandle;
 Публично:
 Порт (назначение cstring_span): порт{open_port (назначение)} { }
 ~Port () { close_port(port); }
 оператор PortHandle () { возвратный порт; }

 // дескрипторы портов обычно не могут быть клонированы, поэтому при необходимости отключите копирование и назначение
 Port (const Port&) = удалить;
 Port & operator=(const Port&) = удалить;
 };

##### Записка

Если ресурс "плохо себя ведет" в том смысле, что он не представлен в виде класса с деструктором, оберните его в класс или используйте ['finally'] (#Re-finally)

** Смотрите также**: [RAII](#Rr-raii)

### <a name= "Rr-use-ptr" ><a name= "Rr-use-ptr" >< / a>R. 2: в интерфейсах используйте необработанные указатели для обозначения отдельных объектов (только)

##### Причина

Массивы лучше всего представлены типом контейнера (например, "вектор" (владелец)) или "span" (не являющийся владельцем).
Такие контейнеры и представления содержат достаточно информации для выполнения проверки диапазона.

##### Пример, плохо

 void f (int* p, int n) / / n - число элементов в p[]
 {
 // ...
 p[2] = 7; / / bad: подстрочный необработанный указатель
 // ...
 }

Компилятор не читает комментарии, и без чтения другого кода Вы не знаете, действительно ли `p` указывает на `N` элементов.
Вместо этого используйте "span".

##### Образец

 void g(int* p, int fmt) / / print *p с использованием формата #fmt
 {
 // ... использует только *p и p[0]...
 }

##### Исключение

Строки в стиле C передаются в виде одиночных указателей на последовательность символов, заканчивающуюся нулем.
Используйте `zstring 'вместо' char*', чтобы указать, что вы полагаетесь на это соглашение.

##### Записка

Многие текущие применения указателей на один элемент могут быть ссылками.
Однако, если "nullptr" является возможным значением, ссылка не может быть разумной альтернативой.

##### Принуждение

* Арифметика указателя флага (включая `++`) на указателе, который не является частью контейнера, представления или итератора.
 Это правило будет генерировать огромное количество ложных срабатываний, если применить его к более старой базе кода.
* Имена флаговых массивов передаются как простые указатели

### <a name= "Rr-ptr" ><a name= "Rr-ptr" >< / a>R. 3: необработанный указатель (a ' T*) не является владельцем

##### Причина

Нет ничего (в стандарте C++ или в большинстве кодов), чтобы сказать иначе, и большинство необработанных указателей не являются владельцами.
Мы хотим, чтобы указатели были идентифицированы, чтобы мы могли надежно и эффективно удалять объекты, на которые указывают указатели.

##### Образец

 пустота f()
 {
 int* p1 = new int{7}; / / bad: raw-указатель владельца
 auto p2 = make_unique<int>(7); / / OK: int принадлежит уникальному указателю
 // ...
 }

'Unique_ptr' защищает от утечек, гарантируя удаление своего объекта (даже при наличии исключений). А вот "Т*" - нет.

##### Образец

 шаблон<typename T>
 класс X {
 Публично:
 T* p; / / плохо: неясно, является ли p владельцем или нет
 T* q; / / bad: неясно, является ли q владельцем или нет
 // ...
 };

Мы можем решить эту проблему, сделав явным право собственности:

 шаблон<typename T>
 класс X2 {
 Публично:
 владелец<T*> p; / / OK: P является владельцем
 T* q; / / OK: q не является владельцем
 // ...
 };

##### Исключение

Основным классом исключений является унаследованный код, особенно код, который должен оставаться компилируемым как C или интерфейс с C и C-style C++ через ABIs.
Тот факт, что существуют миллиарды строк кода, которые нарушают это правило против владения `T*`S, нельзя игнорировать.
Мы хотели бы видеть инструменты преобразования программ, превращающие 20-летний "унаследованный" код в блестящий современный код,
мы поощряем разработку, развертывание и использование таких инструментов,
мы надеемся, что руководящие принципы помогут в разработке таких инструментов,
и мы даже внесли свой вклад (и вносим свой вклад) в научные исследования и разработки в этой области.
Однако на это потребуется время: "унаследованный код" генерируется быстрее, чем мы можем восстановить старый код, и так будет в течение нескольких лет.

Этот код не может быть переписан полностью (даже при условии хорошего программного обеспечения для преобразования кода), особенно не скоро.
Эта проблема не может быть решена (в масштабе) путем преобразования всех указателей владельца в 'unique_ptr и' shared_ptr,
отчасти потому, что нам нужно/использовать владение "сырыми указателями", а также простыми указателями в реализации наших основных дескрипторов ресурсов.
Например, общие реализации "вектор" имеют один собственный указатель и два не являющихся владельцами указателей.
Многие ABI (и по существу все интерфейсы к коду C) используют `T*`s, некоторые из них владеющие.
Некоторые интерфейсы не могут быть просто аннотированы с " владельцем`, потому что они должны оставаться компилируемыми как C
(хотя это было бы редким хорошим использованием для макроса, который расширяется до "владельца" только в режиме C++).

##### Записка

'owner<T*>' не имеет семантики по умолчанию за пределами `T*'. Его можно использовать без изменения любого кода, используя его и не затрагивая ABIs.
Это просто индикатор для программистов и инструментов анализа.
Например, если 'владелец<T*>' является членом класса, этот класс лучше иметь деструктор, который ' удаляет его.

##### Пример, плохо

Возврат указателя (raw) накладывает неопределенность управления временем жизни на вызывающий объект; то есть, кто удаляет объект, на который указывает?

 Гаджет * make_gadget(int n)
 {
 auto p = новый гаджет{n};
 // ...
 возврат p;
 }

 void caller(int n)
 {
 auto p = make_gadget (n); / / не забудьте удалить p
 // ...
 удалить p;
 }

В дополнение к страданию от проблемы с [утечкой] (#???), это добавляет ложную операцию выделения и освобождения и является излишне многословным. Если гаджет дешев для перемещения из функции (т. е. мал или имеет эффективную операцию перемещения), просто верните его "по значению"(см. ["out" return values] (#Rf-out)):

 Гаджет make_gadget(int n)
 {
 Гаджет g{n};
 // ...
 возврат g;
 }

##### Записка

Это правило применяется к функциям фабрики.

##### Записка

Если требуется семантика указателя (например, потому что тип возвращаемого значения должен ссылаться на базовый класс иерархии классов (интерфейс)), верните "умный указатель"."

##### Принуждение

* (Простой) предупреждает об удалении необработанного указателя, который не является владельцем<T>.
* (Moderate) предупреждает о невозможности либо "сбросить", либо явно "удалить" указатель "владелец<T>" на каждом пути кода.
* (Простой) предупреждает, если возвращаемое значение `new` назначено необработанному указателю.
* (Простой) предупреждает, если функция возвращает объект, который был выделен внутри функции, но имеет конструктор перемещения.
 Вместо этого предложите рассмотреть возможность возврата его по значению.

### <a name= "Rr-ref" ><a name= "Rr-ref" >< / a>R. 4: необработанная ссылка (a `T&`) не является владельцем

##### Причина

Нет ничего (в стандарте C++ или в большинстве кодов), чтобы сказать иначе, и большинство необработанных ссылок не являются владельцами.
Мы хотим, чтобы владельцы были идентифицированы, чтобы мы могли надежно и эффективно удалять объекты, на которые указывают владельцы указателей.

##### Образец

 пустота f()
 {
 int& r = * new int{7}; / / bad: Ссылка на владение raw
 // ...
 удалить & r; // плохо: нарушено правило удаления необработанных указателей
 }

**Смотрите также**: [правило необработанного указателя](#Rr-ptr)

##### Принуждение

Смотрите [правило необработанного указателя] (#Rr-ptr)

### <a name= "Rr-scoped" ><a name="Rr-scoped" >< / a>R. 5: предпочитайте объекты с областью видимости, не выделяйте ненужную кучу

##### Причина

Объект с областью действия является локальным объектом, глобальным объектом или членом.
Это означает, что не существует отдельной стоимости распределения и освобождения сверх той, которая уже используется для содержащей области или объекта.
Члены объекта с областью действия сами являются областями действия, а конструктор и деструктор объекта с областью действия управляют временем жизни членов.

##### Образец

Следующий пример неэффективен (потому что он имеет ненужное выделение и освобождение), уязвим для бросков исключений и возвращает в `...'часть (ведущая к утечкам), и многословно:

 void f(int n)
 {
 auto p = новый гаджет{n};
 // ...
 удалить p;
 }

Вместо этого используйте локальную переменную:

 void f(int n)
 {
 Гаджет g{n};
 // ...
 }

##### Принуждение

* (Умеренный) предупреждает, если объект выделен, а затем освобожден по всем путям внутри функции. Предположим, что это должен быть локальный объект стека "auto" вместо этого.
* (Простой) предупреждает, если локальный ' Unique_pointer `или` Shared_pointer `не перемещается, не копируется, не переназначается и не сбрасывается до окончания срока его действия.

### <a name= "Rr-global" ><a name= "Rr-global" >< / a>R. 6: Избегайте не - 'const' глобальных переменных

Смотрите [I. 2] (#Ri-global)

## <a name= "SS-alloc" ><a name= "SS-alloc" >< / a>R. alloc: выделение и освобождение

### <a name= "Rr-mallocfree" ><a name= "Rr-mallocfree" >< / a > R. 10: избегайте `malloc () ' и ' free()`

##### Причина

 'malloc ()' и 'free () `не поддерживают строительство и разрушение, и не смешиваются хорошо с` new `и`delete'.

##### Образец

 запись класса {
 int id;
 строковое имя;
 // ...
 };

 пустое использование()
 {
 // p1 может быть nullptr
 // * p1 не инициализируется; в частности,
 // эта строка не строка, а строка размером с мешок битов
 Запись * p1 = static_cast<запись*>(malloc (sizeof (Record)));

 auto p2 = новая запись;

 // если не возникнет исключение, * P2 инициализируется по умолчанию
 auto p3 = новая (nothrow) запись;
 // p3 может быть nullptr; если нет, то * P3 инициализируется по умолчанию

 // ...

 удалить p1; / / ошибка: не удается удалить объект, выделенный malloc()
 free (p2); / / ошибка: не удается освободить () объект, выделенный новым
 }

В некоторых реализациях, которые 'delete' и 'free ()' могут работать, или, возможно, они вызовут ошибки во время выполнения.

##### Исключение

Существуют приложения и разделы кода, в которых исключения недопустимы.
Некоторые из лучших таких примеров находятся в жизненно важном жестком коде реального времени.
Будьте осторожны, что многие запреты на использование исключений основаны на суеверии (плохо)
или заботами о старых кодовых базах с бессистемным управлением ресурсами (к сожалению, но иногда необходимым).
В таких случаях рассмотрим "nothrow" версии `new".

##### Принуждение

Флаг явного использования `malloc`и 'free'.

### <a name= "Rr-newdelete" ><a name= "Rr-newdelete" >< / a>R. 11: избегайте вызова` new `и` delete ' явно

##### Причина

Указатель, возвращаемый параметром 'new`, должен принадлежать дескриптору ресурса (который может вызывать функцию`delete').
Если указатель, возвращаемый параметром 'new', назначен обычному / голому указателю, то объект может быть утечка.

##### Записка

В большой программе голый 'delete' (то есть 'удалить' в коде приложения, а не часть кода, посвященного управлению ресурсами)
это вероятная ошибка: если у вас есть N ' delete, как вы можете быть уверены, что вам не нужно N+1 или N-1?
Ошибка может быть скрытой: она может появиться только во время технического обслуживания.
Если у вас есть голый "Новый", вам, вероятно, нужно голое "удалить" где-то, поэтому у вас, вероятно, есть ошибка.

##### Принуждение

(Просто) предупреждайте о любом явном использовании `new " и "delete". Предложите вместо этого использовать `make_unique'.

### <a name= "Rr-immediate-alloc" ><a name= "Rr-immediate-alloc">< / a>R. 12: немедленно дайте результат явного выделения ресурсов объекту диспетчера

##### Причина

Если вы этого не сделаете, исключение или возврат могут привести к утечке.

##### Пример, плохо

 void f(const string& name)
 {
 Файл* f = fopen (имя, "r"); / / откройте файл
 вектор < char> buf(1024);
 auto _ = finally ([f] { fclose(f);}); / / не забудьте закрыть файл
 // ...
 }

Выделение ' buf ' может завершиться ошибкой и привести к утечке дескриптора файла.

##### Образец

 void f(const string& name)
 {
 ifstream f{name}; / / откройте файл
 вектор < char> buf(1024);
 // ...
 }

Использование дескриптора файла (в 'ifstream') является простым, эффективным и безопасным.

##### Принуждение

* Флаг явных распределений, используемых для инициализации указателей (проблема: сколько прямых распределений ресурсов мы можем распознать?)

### <a name= "Rr-single-alloc" ><a name= "Rr-single-alloc" >< / a>R. 13: Выполните не более одного явного выделения ресурсов в одном операторе выражения

##### Причина

При выполнении двух явных распределений ресурсов в одном операторе возможна утечка ресурсов, поскольку порядок вычисления многих вложенных выражений, включая аргументы функции, не определен.

##### Образец

 void fun(shared_ptr < Widget> sp1, shared_ptr<Widget > <Widget > sp2);

Это " веселье` можно назвать так:

 // Плохо: потенциальная утечка
 fun (shared_ptr<виджет>(новый виджет (a, b)), shared_ptr<виджет > <виджет>(новый виджет (c, d)));

Это исключение-небезопасно, поскольку компилятор может переупорядочить два выражения, построив два аргумента функции.
В частности, компилятор может чередовать выполнение двух выражений:
Выделение памяти (путем вызова оператора new) может быть сделано сначала для обоих объектов, а затем попытки вызвать два конструктора виджета.
Если один из вызовов конструктора вызывает исключение, то память другого объекта никогда не будет освобождена!

Эта тонкая проблема имеет простое решение: никогда не выполняйте более одного явного выделения ресурсов в одном операторе выражения.
Например:

 shared_ptr<Widget > sp1 (новый виджет (a, b)); / / лучше, но грязно
 fun (sp1, новый виджет (c, d));

Лучшее решение-это полностью избегать явного выделения использовать заводские функции, возвращающие объекты-владельцы:

 fun (make_shared < Widget>(a, b), make_shared<Widget><Widget>(c, d)); / / Best

Напишите свою собственную заводскую обертку, если ее еще нет.

##### Принуждение

* Выражения флагов с несколькими явными распределениями ресурсов (проблема: сколько прямых распределений ресурсов мы можем распознать?)

### <a name= "Rr-ap" ><a name= "Rr-ap" >< / a>R. 14: избегайте параметров ' []', предпочитайте ' span`

##### Причина

Массив распадается на указатель, тем самым теряя свой размер, открывая возможность для ошибок диапазона.
Используйте 'span' для сохранения информации о размере.

##### Образец

 void f (int []); / / не рекомендуется

 void f (int*); / / не рекомендуется для нескольких объектов
 // (указатель должен указывать на один объект, не подписывать)

 void f(gsl:: span<int>); / / хорошо, рекомендуется

##### Принуждение

Флаг ` [] ' параметры. Используйте вместо этого слово "span".

### <a name= "Rr-pair" ><a name= "Rr-pair" >< / a>R. 15: всегда перегружайте соответствующие пары выделения / освобождения

##### Причина

В противном случае вы получите несоответствующие операции и хаос.

##### Образец

 класс X {
 // ...
 void * оператор new(size_t s);
 оператор void удалить(void*);
 // ...
 };

##### Записка

Если вам нужна память, которую нельзя освободить, `=delete` операция освобождения.
Не оставляйте его незаявленным.

##### Принуждение

Флаг неполных пар.

## <a name= "SS-smart"><a name= "SS-smart">< / a>R. smart: интеллектуальные указатели

### <a name= "Rr-owner" ><a name="Rr-owner" >< / a>R. 20: используйте `unique_ptr ' или 'shared_ptr' для представления права собственности

##### Причина

Они могут предотвратить утечку ресурсов.

##### Образец

Считать:

 пустота f()
 {
 X x;
 X * p1 { new X }; / / Смотрите также ???
 unique_ptr<T> p2 { new X }; / / уникальное владение; см. Также ???
 shared_ptr<T> p3 { new X }; / / совместное владение; см. Также ???
 auto p4 = make_unique<X > (); / / unique_ownership, предпочтительно явное использование "new"
 auto p5 = make_shared<X > (); / / совместное владение, предпочтительно явное использование "new"
 }

Это приведет к утечке объекта, используемого для инициализации `p1 ' (только).

##### Принуждение

(Простой) предупреждает, если возвращаемое значение `new` или вызов функции с возвращаемым значением типа указателя назначается необработанному указателю.

### <a name= "Rr-unique" ><a name="Rr-unique" >< / a>R. 21: предпочтите "unique_ptr" над "shared_ptr", если вам не нужно совместно владеть

##### Причина

'Unique_ptr' концептуально проще и предсказуемее (вы знаете, когда происходит разрушение) и быстрее (вы неявно поддерживаете счетчик использования).

##### Пример, плохо

Это без необходимости добавляет и поддерживает счетчик ссылок.

 пустота f()
 {
 shared_ptr<Base > base = make_shared<Base > <Derived>();
 // используйте базу локально, не копируя ее -- refcount никогда не превышает 1
 } / / уничтожить базу

##### Образец

Это более эффективно:

 пустота f()
 {
 unique_ptr<Base > base = make_unique<Base > <Derived>();
 // использовать базу локально
 } / / уничтожить базу

##### Принуждение

(Простой) предупреждает, если функция использует 'Shared_pointer' с объектом, выделенным внутри функции, но никогда не возвращает `Shared_pointer` или передает его в функцию, требующую `Shared_pointer&`. Вместо этого рекомендуется использовать `unique_ptr`.

### <a name= "Rr-make_shared" ><a name= "Rr-make_shared">< / a>R. 22: используйте ' make_shared ()', чтобы сделать ' shared_ptr

##### Причина

Если вы сначала создадите объект, а затем передадите его конструктору `shared_ptr`, вы (скорее всего) сделаете еще одно выделение (и позднее освобождение), чем если бы вы использовали `make_shared ()`, потому что счетчики ссылок должны быть выделены отдельно от объекта.

##### Образец

Считать:

 shared_ptr<X> p1 { new X{2} }; / / плохо
 auto p = make_shared<X > (2); / / хорошо

Версия 'make_shared () `упоминает` X `только один раз, поэтому обычно она короче (а также быстрее), чем версия с явным`новым'.

##### Принуждение

(Простой) предупредите, если "shared_ptr" создается из результата "new", а не "make_shared".

### <a name= "Rr-make_unique" ><a name= "Rr-make_unique" >< / a>R. 23: используйте ' make_unique ()', чтобы сделать ' unique_ptr

##### Причина

Для удобства и согласованности с `shared_ptr'.

##### Записка

'make_unique ()' - это C++14, но широко доступный (а также Простой в написании).

##### Принуждение

(Простой) предупредите, если "unique_ptr" создается из результата "new", а не "make_unique".

### <a name= "Rr-weak_ptr" ><a name= "Rr-weak_ptr" >< / a>R. 24: используйте 'std:: weak_ptr' для разрыва циклов ' shared_ptr

##### Причина

 'shared_ptr' s полагается на подсчет использования, и подсчет использования для циклической структуры никогда не идет к нулю, поэтому нам нужен механизм, чтобы
уметь разрушать циклическую структуру.

##### Образец

 #включить <память>

 класс бар;

 класс фу
 {
 Публично:
 явный foo(const std:: shared_ptr<bar>& forward_reference)
 : forward_reference_(forward_reference)
 { }
 Частное:
 std:: shared_ptr<bar> forward_reference_;
 };

 класс бар
 {
 Публично:
 явный бар(const std:: weak_ptr<foo>& back_reference)
 : back_reference_(back_reference)
 { }
 void do_something()
 {
 if (auto shared_back_reference = back_reference_.замок()) {
 // Использовать * shared_back_reference
 }
 }
 Частное:
 std:: weak_ptr<foo> back_reference_;
 };

##### Записка

 ??? (HS: многие люди говорят "чтобы разорвать циклы", в то время как я думаю, что "временное совместное владение" более уместно.)
???(BS: прерывание циклов - это то, что вы должны делать; временное совместное владение-это то, как вы это делаете.
Вы можете "временно разделить собственность", просто используя другой `shared_ptr`.)

##### Принуждение

??? наверное, это невозможно. Если бы мы могли статически обнаруживать циклы, нам не нужен был бы " weak_ptr`

### <a name= "Rr-smartptrparam" ><a name= "Rr-smartptrparam">< / a>R. 30: возьмите интеллектуальные указатели в качестве параметров только для явного выражения семантики времени жизни

##### Причина

Принятие интеллектуального указателя на "виджет" неверно, если функция просто нуждается в самом "виджете".
Он должен быть в состоянии принять любой объект "виджет", а не только те, чье время жизни управляется определенным типом интеллектуального указателя.
Функция, которая не управляет временем жизни, должна принимать необработанные указатели или ссылки вместо этого.

##### Пример, плохо

 // вызываемый
 void f(shared_ptr<widget > & w)
 {
 // ...
 use(*w); / / только использование w -- срок службы не используется вообще
 // ...
 };

 // абонент
 shared_ptr<виджет > my_widget =/*... */;
 f(my_widget);

 виджет stack_widget;
 f (stack_widget); / / ошибка

##### Пример, хорошо

 // вызываемый
 void f (виджет& w)
 {
 // ...
 использование(w);
 // ...
 };

 // абонент
 shared_ptr<виджет > my_widget =/*... */;
 f(*my_widget);

 виджет stack_widget;
 f(stack_widget); / / ok -- теперь это работает

##### Принуждение

* (Simple) предупреждает, если функция принимает параметр типа интеллектуального указателя (который перегружает "operator ->" или " operator*"), который можно скопировать, но функция вызывает только любое из: "operator*", "operator ->>" или " get ()".
 Предложите использовать вместо этого букву "T*" или " T&".
* Отметьте параметр типа интеллектуального указателя (тип, который перегружает "оператор ->" или " оператор*"), который копируется/перемещается, но никогда не копируется/перемещается из тела функции, и который никогда не изменяется, и который не передается другой функции, которая могла бы сделать это. Это означает, что семантика владения не используется.
 Предложите использовать вместо этого букву "T*" или " T&".

### <a name= "Rr-smart" ><a name= "Rr-smart">< / a>R. 31: Если у вас есть не` std 'смарт-указатели, следуйте основной шаблон из' std`

##### Причина

Правила в следующем разделе также работают для других видов сторонних и пользовательских смарт-указателей и очень полезны для диагностики распространенных ошибок смарт-указателя, которые вызывают проблемы производительности и корректности.
Вы хотите, чтобы правила работали на всех интеллектуальных указателях, которые вы используете.

Любой тип (включая первичный шаблон или специализацию), который перегружает унарные `*` и` ->`, считается интеллектуальным указателем:

* Если он может быть скопирован, он распознается как ссылка с подсчетом 'shared_ptr'.
* Если он не может быть скопирован, он распознается как уникальный `unique_ptr`.

##### Образец

 // используйте функцию Boost intrusive_ptr
 #включить ТЭЦ>
 void f(boost:: intrusive_ptr<widget> p) / / ошибка под правилом 'sharedptrparam'
 {
 p - >foo();
 }

 // используйте Ccomptr от Microsoft
 #включить ч>
 void f (CComPtr<widget> p) / / ошибка под правилом 'sharedptrparam'
 {
 p - >foo();
 }

Оба случая являются ошибкой в соответствии с руководящими принципами ['sharedptrparam'] (#Rr-smartptrparam):
`p '- это 'Shared_pointer', но здесь ничего не говорится о его sharedness, и передача его по значению является молчаливой пессимизацией;
эти функции должны принимать смарт-указатель только в том случае, если они должны участвовать в управлении временем жизни виджета. В противном случае они должны принять " виджет*", если это может быть "nullptr". В противном случае, и в идеале, функция должна принимать " виджет&".
Эти интеллектуальные указатели соответствуют концепции "Shared_pointer", поэтому эти правила применения руководящих принципов работают над ними из коробки и подвергают эту общую пессимизацию.

### <a name= "Rr-uniqueptrparam" ><a name= "Rr-uniqueptrparam">< / a > R. 32: возьмите параметр 'unique_ptr< / a><widget>, чтобы выразить, что функция принимает владение' виджетом`

##### Причина

Используя 'unique_ptr' таким образом, как документы, так и обеспечивает передачу права собственности вызова функции.

##### Образец

 void sink(unique_ptr<widget>); / / становится владельцем виджета

 void использует (виджет*); // просто использует виджет

##### Пример, плохо

 void thinko (const unique_ptr<widget>&); // обычно не то, что вы хотите

##### Принуждение

* (Простой) предупреждает, если функция принимает параметр 'Unique_pointer<T>' по ссылке lvalue и не назначает ему или не вызывает `reset()` на нем по крайней мере на одном пути кода. Предложите вместо этого взять букву " Т " или " Т&".
* (Simple) ((Foundation)) предупреждает, если функция принимает параметр `Unique_pointer<T>` со ссылкой на `const`. Предложите вместо этого взять `const T*` или `const T&`.

### <a name= "Rr-reseat" ><a name="Rr-reseat" >< / a>R. 33: возьмите параметр ' unique_ptr< / a><widget>&', чтобы выразить, что функция повторно вводит ' widget`

##### Причина

Используя 'unique_ptr' таким образом, как документы, так и принудительно выполняет семантику повторного заполнения вызова функции.

##### Записка

"reseat" означает " создание указателя или интеллектуального указателя, ссылающегося на другой объект."

##### Образец

 void reseat (unique_ptr<widget>&); / / указатель "will" или "might" reseat

##### Пример, плохо

 void thinko (const unique_ptr<widget>&); // обычно не то, что вы хотите

##### Принуждение

* (Простой) предупреждает, если функция принимает параметр 'Unique_pointer<T>' по ссылке lvalue и не назначает ему или не вызывает `reset()` на нем по крайней мере на одном пути кода. Предложите вместо этого взять букву " Т " или " Т&".
* (Simple) ((Foundation)) предупреждает, если функция принимает параметр `Unique_pointer<T>` со ссылкой на `const`. Предложите вместо этого взять `const T*` или `const T&`.

### <a name= "Rr-sharedptrparam-owner" ><a name= "Rr-sharedptrparam-owner">< / a > R. 34: возьмите параметр ' shared_ptr< / a><widget>, чтобы выразить, что функция является частичным владельцем

##### Причина

Это делает явным совместное использование прав собственности функции.

##### Пример, хорошо

 void share (shared_ptr<widget>); / / share -- "сохранит" refcount

 void may_share (const shared_ptr<widget>&); / / "might" сохранить refcount

 void reseat(shared_ptr<widget>&); / / "might" reseat ptr

##### Принуждение

* (Простой) предупреждает, если функция принимает параметр 'Shared_pointer<T>' по ссылке lvalue и не назначает ему или не вызывает `reset()` на нем по крайней мере на одном пути кода. Предложите вместо этого взять букву " Т " или " Т&".
* (Simple) ((Foundation)) предупреждает, если функция принимает `Shared_pointer<T>` по значению или по ссылке на `const` и не копирует или не перемещает его в другой `Shared_pointer` по крайней мере по одному пути кода. Предложите вместо этого взять букву " Т " или " Т&".
* (Simple) ((Foundation)) предупреждает, если функция принимает `Shared_pointer<T>` по ссылке rvalue. Предлагаю вместо этого взять его по стоимости.

### <a name= "Rr-sharedptrparam" ><a name="Rr-sharedptrparam" >< / a > R. 35: возьмите параметр` shared_ptr</a><widget>&', чтобы выразить, что функция может повторно использовать общий указатель

##### Причина

Это делает повторную установку функции явной.

##### Записка

"reseat" означает " создание ссылки или интеллектуального указателя, ссылающегося на другой объект."

##### Пример, хорошо

 void share (shared_ptr<widget>); / / share -- "сохранит" refcount

 void reseat(shared_ptr<widget>&); / / "might" reseat ptr

 void may_share (const shared_ptr<widget>&); / / "might" сохранить refcount

##### Принуждение

* (Простой) предупреждает, если функция принимает параметр 'Shared_pointer<T>' по ссылке lvalue и не назначает ему или не вызывает `reset()` на нем по крайней мере на одном пути кода. Предложите вместо этого взять букву " Т " или " Т&".
* (Simple) ((Foundation)) предупреждает, если функция принимает `Shared_pointer<T>` по значению или по ссылке на `const` и не копирует или не перемещает его в другой `Shared_pointer` по крайней мере по одному пути кода. Предложите вместо этого взять букву " Т " или " Т&".
* (Simple) ((Foundation)) предупреждает, если функция принимает `Shared_pointer<T>` по ссылке rvalue. Предлагаю вместо этого взять его по стоимости.

### <a name= "Rr-sharedptrparam-const"><a name="Rr-sharedptrparam-const" ></a>R. 36: возьмите параметр `const shared_ptr</a><widget>&`, чтобы выразить, что он может сохранить счетчик ссылок на объект ???

##### Причина

Это и делает функцию такой ??? явный.

##### Пример, хорошо

 void share (shared_ptr<widget>); / / share -- "сохранит" refcount

 void reseat(shared_ptr<widget>&); / / "might" reseat ptr

 void may_share (const shared_ptr<widget>&); / / "might" сохранить refcount

##### Принуждение

* (Простой) предупреждает, если функция принимает параметр 'Shared_pointer<T>' по ссылке lvalue и не назначает ему или не вызывает `reset()` на нем по крайней мере на одном пути кода. Предложите вместо этого взять букву " Т " или " Т&".
* (Simple) ((Foundation)) предупреждает, если функция принимает `Shared_pointer<T>` по значению или по ссылке на `const` и не копирует или не перемещает его в другой `Shared_pointer` по крайней мере по одному пути кода. Предложите вместо этого взять букву " Т " или " Т&".
* (Simple) ((Foundation)) предупреждает, если функция принимает `Shared_pointer<T>` по ссылке rvalue. Предлагаю вместо этого взять его по стоимости.

### <a name= "Rr-smartptrget" ><a name= "Rr-smartptrget" >< / a>R. 37: не передавайте указатель или ссылку, полученные из псевдонимного смарт-указателя

##### Причина

Нарушение этого правила является причиной номер один потери отсчетов ссылок и нахождения себя с оборванным указателем.
Функции должны предпочитать передавать необработанные указатели и ссылки вниз по цепочкам вызовов.
В верхней части дерева вызовов, где вы получаете необработанный указатель или ссылку от смарт-указателя, который поддерживает объект в рабочем состоянии.
Вы должны быть уверены, что интеллектуальный указатель не может быть случайно сброшен или переназначен из дерева вызовов ниже.

##### Записка

Для этого иногда нужно взять локальную копию смарт-указателя, которая надежно сохраняет объект живым на протяжении всей функции и дерева вызовов.

##### Образец

Рассмотрим этот код:

 // global (статический или кучи), или aliased local ...
 shared_ptr<виджет > g_p = ...;

 void f (виджет& w)
 {
 г();
 use (w); / / A
 }

 пустота g()
 {
 g_p = ...; / / oops, если это был последний shared_ptr для этого виджета, уничтожает виджет
 }

Следующее не должно проходить проверку кода:

 void my_code()
 {
 // BAD: передача указателя или ссылки, полученной из нелокального интеллектуального указателя
 // это может быть случайно сброшено где-то внутри f или его абонентов
 f(*g_p);

 // Плохо: та же причина, просто передавая его как указатель " this
 g_p- > func();
 }

Исправление простое - возьмите локальную копию указателя, чтобы "сохранить счетчик ссылок" для вашего дерева вызовов:

 void my_code()
 {
 // дешево: 1 инкремент покрывает всю эту функцию и все деревья вызовов ниже нас
 auto pin = g_p;

 // Хорошо: передача указателя или ссылки, полученной из локального неназначенного интеллектуального указателя
 f (*pin-код);

 // Хорошо: по той же причине
 pin - >func();
 }

##### Принуждение

* (Простой) предупреждает, если указатель или ссылка, полученные из переменной smart pointer (`Unique_pointer` или `Shared_pointer`), которая является нелокальной или локальной, но потенциально псевдонимной, используется в вызове функции. Если смарт-указатель является "Shared_pointer", то предложите взять локальную копию смарт-указателя и вместо этого получить указатель или ссылку на него.

# <a name= "S-expr" ><a name= "S-expr" >< / a>ES: выражения и операторы

Выражения и операторы - это самый низкий и самый прямой способ выражения действий и вычислений. Объявления в локальных областях видимости-это операторы.

Правила именования, комментирования и отступов см. В разделе [NL: Naming and layout](#S-naming).

Общий порядок:

* [ES.1: предпочитайте стандартную библиотеку другим библиотекам и "ручной код"] (#Res-lib)
* [ES.2: предпочитайте подходящие абстракции для прямого использования языковых функций] (#Res-abstr)

Правила декларирования:

* [ES.5: Держите объемы малым] (#Res-scope)
* [ES.6: объявляйте имена в инициализаторах операторов for-statement и условия для ограничения области действия] (#Res-cond)
* [ES.7: держите общие и местные имена короткими, а также держите необычные и нелокальные имена дольше] (#Res-name-length)
* [ES.8: Избегайте похожих имен] (#Res-name-похожие)
* [ES.9: Избегайте имен 'ALL_CAPS'] (#Res-not-CAPS)
* [ES.10: объявите одно имя (только) в объявлении] (#Res-name-one)
* [ES.11: используйте `auto', чтобы избежать избыточного повторения имен типов] (#Res-auto)
* [ES.12: не следует повторно использовать имена во вложенных областях] (#Res-повторное использование)
* [ES.20: всегда инициализировать объект] (#Res-всегда)
* [ES.21: Не вводите переменную (или константу), прежде чем вам нужно будет ее использовать] (#Res-introduct)
* [ES.22: не объявляйте переменную, пока у вас нет значения для ее инициализации с помощью] (#Res-init)
* [ES.23: предпочтите синтаксис `{} ' - инициализатора](#Res-list)
* [ES.24: используйте 'unique_ptr<T>' для удержания указателей] (#Res-unique)
* [ES.25: объявите объект 'const' или` constexpr', если вы не хотите изменить его значение позже] (#Res-const)
* [ES.26: не используйте переменную для двух несвязанных целей] (#Res-recycle)
* [ES.27: используйте 'std:: array' или 'stack_array' для массивов в стеке] (#Res-stack)
* [ES.28: используйте лямбды для комплексной инициализации, особенно переменных `const`] (#Res-lambda-init)
* [ES.30: не используйте макросы для работы с текстом программы] (#Res-macros)
* [ES.31: Не используйте макросы для констант или"функций"] (#Res-macros2)
* [ES.32: используйте ' ALL_CAPS` для всех имен макросов] (#Res-ALL_CAPS)
* [ES.33: Если вы должны использовать макросы, дайте им уникальные имена] (#Res-MACROS)
* [ES.34: не определяйте (C-style) вариативную функцию] (#Res-эллипсы)

Правила выражения:

* [ES.40: избегайте сложных выражений] (#Res-сложный)
* [ES.41: Если вы сомневаетесь в приоритете оператора, заключите его в скобки] (#Res-parens)
* [ES.42: держите использование указателей простым и прямым] (#Res-ptr)
* [ES.43: избегайте выражений с неопределенным порядком оценки] (#Res-порядок)
* [ES.44: не зависит от порядка вычисления аргументов функции] (#Res-order-fct)
* [ES.45: избегайте "магических констант"; используйте символические константы] (#Res-magic)
* [ES.46: избегайте сужения преобразования] (#Res-сужение)
* [ES.47: используйте `nullptr 'вместо' 0 'или`NULL'] (#Res-nullptr)
* [ES.48: избегайте приведений] (#Res-приведения)
* [ES.49: Если вы должны использовать приведение, используйте именованное приведение] (#Res-casts-named)
* [ES.50: не отбрасывайте `const'] (#Res-casts-const)
* [ES.55: избегайте необходимости проверки диапазона] (#Res-range-checking)
* [ES.56: пишите ' std:: move ()` только тогда, когда вам нужно явно переместить объект в другую область] (#Res-move)
* [ES.60: избегайте `новых " и "удалить" функции внешнего управления ресурсами] (#Res-new)
* [ES.61: удалить массивы с помощью 'delete []' и не массивы с помощью 'delete'] (#Res-del)
* [ES.62: не сравнивайте указатели в разных массивах] (#Res-arr2)
* [ES.63: Don't slice](#Res-slice)
* [ES.64: используйте обозначение 'T{e}' для построения] (#Res-construct)
* [ES.65: не разыменовывать недопустимый указатель] (#Res-deref)

Правила выписки:

* [ES.70: предпочтите 'switch' - оператор к`if ' -оператор, когда есть выбор] (#Res-switch-if)
* [ES.71: предпочтите оператор диапазона - ' для '-оператору`для ' - оператора, когда есть выбор] (#Res-for-range)
* [ES.72: предпочитайте оператор " for "- оператору "while", когда существует очевидная переменная цикла] (#Res-for-while)
* [ES.73: предпочтите оператор "while" оператору "for", когда нет очевидной переменной цикла] (#Res-while-for)
* [ES.74: предпочтительно объявить переменную цикла в инициализаторе части оператора`for ' -statement] (#Res-for-init)
* [ES.75: избегайте`do ' -утверждений] (#Res-do)
* [ES.76: избегайте 'goto'] (#Res-goto)
* [ES.77: минимизировать использование 'break' и 'continue' в циклах] (#Res-continue)
* [ES.78: Не полагайтесь на неявное fallthrough в операторах 'switch'] (#Res-break)
* [ES.79: используйте `default` для обработки общих случаев (только)] (#Res-default)
* [ES.84: Не пытайтесь объявить локальную переменную без имени] (#Res-noname)
* [ES.85: сделайте пустые операторы видимыми] (#Res-пустой)
* [ES.86: избегайте изменения переменных управления циклом внутри тела raw for-loops] (#Res-loop-counter)
* [ES.87: не добавляйте избыточные ` = = 'или'!= 'to conditions] (#Res-if)

Арифметические правила:

* [ES.100: не смешивать арифметику со знаком и без знака] (#Res-mix)
* [ES.101: используйте неподписанные типы для битовых манипуляций] (#Res-unsigned)
* [ES.102: используйте подписанные типы для арифметики] (#Res-signed)
* [ES.103: не переполнять] (#Res-overflow)
* [ES.104: Don't underflow] (#Res-underflow)
* [ES.105: Не делите на ноль] (#Res-ноль)
* [ES.106: не пытайтесь избежать отрицательных значений с помощью `unsigned'] (#Res-неотрицательный)
* [ES.107: Не используйте `unsigned 'для индексов, предпочитайте `gsl:: index'] (#Res-индексы)

### <a name= "Res-lib"><a name="Res-lib" ></a>ES.1: предпочитайте стандартную библиотеку другим библиотекам и "ручной код"

##### Причина

Код, использующий библиотеку, может быть гораздо проще написать, чем код, работающий непосредственно с языковыми функциями, гораздо короче, как правило, имеет более высокий уровень абстракции, и код библиотеки, по-видимому, уже протестирован.
Стандартная библиотека ISO C++ является одной из наиболее широко известных и проверенных библиотек.
Он доступен как часть всех реализаций C++.

##### Образец

 auto sum = накопить (начало (a), конец (a), 0.0); / / хорошо

версия диапазона " накапливать` было бы еще лучше:

 auto sum = накопить (v, 0.0); / / лучше

но не надо вручную кодировать хорошо известный алгоритм:

 int max = v. size (); / / bad: verbose, purpose unstated
 двойная сумма = 0,0;
 для (int i = 0; i )
 sum = sum + v[i];

##### Исключение

Большая часть стандартной библиотеки основана на динамическом выделении (свободное хранилище). Эти части, особенно контейнеры, но не алгоритмы, непригодны для некоторых жестких и встроенных приложений реального времени. В таких случаях рассмотрите возможность предоставления / использования аналогичных средств, например, контейнера в стиле стандартной библиотеки, реализованного с помощью распределителя пула.

##### Принуждение

Не легкий. ??? Ищите беспорядочные циклы, вложенные циклы, длинные функции, отсутствие вызовов функций, отсутствие использования не встроенных типов. Цикломатическая сложность?

### <a name= "Res-abstr"><a name="Res-abstr" ></a>ES.2: предпочитайте подходящие абстракции для прямого использования языковых функций

##### Причина

"Подходящая абстракция" (например, библиотека или класс) ближе к концепциям приложений, чем голый язык, приводит к более короткому и ясному коду и, вероятно, будет лучше протестирована.

##### Образец

 вектор < строка> read1 (istream& is) / / Хорошо
 {
 вектор < строка> res;
 для (строка s; is >>> s;)
 рез. push_back(s);
 возврат res;
 }

Более традиционный и низкоуровневый близкий эквивалент длиннее, грязнее, труднее получить правильный и, скорее всего, медленнее:

 char * * read2(istream& is, int maxelem, int maxstring, int* nread) / / плохо: подробный и неполный
 {
 auto res = новый символ*[maxelem];
 int elemcount = 0;
 while (is & & elemcount ) {
 auto s = новый символ [maxstring];
 является.читать(s, maxstring);
 res[elemcount++] = s;
 }
 nread = & elemcount;
 возврат res;
 }

После того, как была добавлена проверка переполнения и обработки ошибок, этот код становится довольно грязным, и есть проблема с запоминанием "удаления" возвращенного указателя и строк C-стиля, которые содержит массив.

##### Принуждение

Не легкий. ??? Ищите беспорядочные циклы, вложенные циклы, длинные функции, отсутствие вызовов функций, отсутствие использования не встроенных типов. Цикломатическая сложность?

## ES.dcl: декларации

Декларация - это утверждение. Объявление вводит имя в область видимости и может вызвать построение именованного объекта.

### <a name= "Res-scope"><a name="Res-scope" ></a>ES.5: Держите объемы малым

##### Причина

Удобочитаемость. Минимизировать удержание ресурсов. Избегайте случайного злоупотребления ценностью.

** Альтернативная формулировка**: не объявляйте имя в излишне большом объеме.

##### Образец

 пустое использование()
 {
 int i; / / bad: я бесполезно доступен после цикла
 ибо (i = 0; i .. */ }
 // нет предполагаемого использования i здесь
 для (int i = 0; i .. * / } / / хорошо: i является локальным для for-loop

 if(auto pc = dynamic_cast<Circle*>(ps)) { // хорошо: ПК является локальным для оператора if-
 // ... разберись с кругом ...
 }
 еще {
 // ... обработайте ошибку ...
 }
 }

##### Пример, плохо

 использование void(const string & name)
 {
 строка fn = name + ".формат txt";
 ifstream равен {fn};
 Запись r;
 is >>> r;
 // ... 200 строк кода без предполагаемого использования fn или is ...
 }

Эта функция по большей части слишком длинна в любом случае, но дело в том, что ресурсы, используемые `fn ' и дескриптор файла, удерживаемый `is`
сохраняются гораздо дольше, чем это необходимо, и что непредвиденное использование " is " и " fn " может произойти позже в функции.
В этом случае, возможно, было бы хорошей идеей разложить прочитанное:

 Запись load_record(const string & name)
 {
 строка fn = name + ".формат txt";
 ifstream равен {fn};
 Запись r;
 is >>> r;
 возврат r;
 }

 использование void(const string & name)
 {
 Запись r = load_record(имя);
 // ... 200 строк кода ...
 }

##### Принуждение

* Переменная Flag loop объявлена вне цикла и не используется после цикла
* Флаг, когда дорогостоящие ресурсы, такие как дескрипторы файлов и блокировки, не используются для N-строк (для некоторых подходящих N)

### <a name= "Res-cond"><a name="Res-cond" ></a>ES.6: объявляйте имена в инициализаторах операторов for-statement и условия для ограничения области действия

##### Причина

Удобочитаемость. Минимизировать удержание ресурсов.

##### Образец

 пустое использование()
 {
 для (строка s; cin >>> s;)
 v. push_back(s);

 для (int i = 0; i 
 // ...
 }

 if(auto pc = dynamic_cast<Circle*>(ps)) { // хорошо: ПК является локальным для оператора if-
 // ... разберись с кругом ...
 }
 еще {
 // ... обработайте ошибку ...
 }
 }

##### Принуждение

* Переменные цикла флагов, объявленные до цикла и не используемые после цикла
* (жесткие) переменные цикла флагов, объявленные до цикла и используемые после цикла для несвязанных целей.

##### C++17 и C++20 пример

Примечание: C++17 и C++20 также добавляют операторы инициализатора` if`,`switch` и range- 'for'. Для этого требуется поддержка C++17 и C++20.

 map<int, string> mymap;

 if (auto result = mymap.вставить (значение); результат.второй) {
 // вставить успешно, и результат будет действителен для этого блока
 использование(результат.во-первых); / / ok
 // ...
 } / / результат здесь уничтожен

##### Принудительное применение C++17 и C++20 (при использовании компилятора C++17 или C++20)

* Выбор флага/переменные цикла, объявленные перед телом и не используемые после тела
* (жесткий) выбор флага/переменные цикла, объявленные перед телом и используемые после тела для несвязанных целей.



### <a name= "Res-name-length"></a>ES.7: держите общие и местные имена короткими, и держите необычные и нелокальные имена дольше

##### Причина

Удобочитаемость. Снижение вероятности столкновений между несвязанными нелокальными именами.

##### Образец

Обычные короткие, местные названия повышают читабельность:

 шаблон<typename T> / / хорошо
 void print(ostream & os, const vector<T>& v)
 {
 для (gsl:: индекс i = 0; i )
 os < < v[i] <;
 }

Индекс условно называется "i", и нет никакого намека на значение вектора в этой общей функции, поэтому " v " - такое же хорошее имя, как и любое другое. Сравнить

 template<typename Element_type> / / bad: подробный, трудно читаемый
 void print(ostream& target_stream, const vector<Element_type>& current_vector)
 {
 для (gsl:: индекс current_element_index = 0;
 current_element_index размер();
 ++current_element_index
 )
 target_stream < < current_vector[current_element_index] <;
 }

Да, это карикатура, но мы видели и похуже.

##### Образец

Нетрадиционные и короткие нелокальные названия непонятный код:

 void use1(const string& s)
 {
 // ...
 tt(s); / / bad: что такое tt ()?
 // ...
 }

Лучше, дайте неместным сущностям читаемые имена:

 void use1(const string& s)
 {
 // ...
 trim_tail(s); / / Лучше
 // ...
 }

Здесь есть шанс, что читатель знает, что означает "trim_tail", и что читатель может вспомнить его после просмотра.

##### Пример, плохо

Имена аргументов больших функций де-факто нелокальны и должны иметь смысл:

 void complicated_algorithm(vector<Record>& vr, const vector<Record > <int> & vi, map<int><string, int>& out)
 // чтение из событий в vr (маркировка используемых записей) для индексов в
 // vi размещение пар (имя, индекс) в out
 {
 // ... 500 строк кода с использованием vr, vi и out ...
 }

Мы рекомендуем держать функции короткими, но это правило не соблюдается повсеместно, и именование должно отражать это.

##### Принуждение

Проверьте длину локальных и нелокальных имен. Также учитывайте длину функции.

### <a name= "Res-name-similar"><a name="Res-name-similar" ></a>ES.8: Избегайте похожих имен

##### Причина

Ясность и удобочитаемость кода. Слишком похожие названия замедляют понимание и увеличивают вероятность ошибки.

##### Пример, плохо

 если (читаемый(i1 + l1 + ol + o1 + o0 + ol + o1 + I0 + l0)) сюрприз();

##### Пример, плохо

Не объявляйте не-тип с тем же именем, что и тип в той же области. Это устраняет необходимость разбираться с такими ключевыми словами, как "struct" или "enum". Он также удаляет источник ошибок, так как "struct X" может неявно объявить "X", если поиск завершается неудачей.

 struct foo { int n; };
 struct foo foo (); / / BAD, foo-это тип, уже находящийся в области видимости
 struct foo x = foo (); / / требует уточнения

##### Исключение

Античные заголовочные файлы могут объявлять не-типы и типы с одинаковым именем в одной и той же области.

##### Принуждение

* Проверьте имена против списка известных запутанных букв и цифр комбинаций.
* Флаг объявление переменной, функции или перечислителя, который скрывает класс или перечисление, объявленные в той же области.

### <a name= "Res-not-CAPS"></a>ES.9: Избегайте имен ' ALL_CAPS` 

##### Причина

Такие имена обычно используются для макросов. Таким образом, имя` ALL_CAPS ' уязвимо для непреднамеренной подстановки макросов.

##### Образец

 // где-то в каком-то заголовке:
 #define NE !=

 // где-то еще в каком-то другом заголовке:
 перечисление координат { N, NE, NW, S, SE, SW, E, W };

 // где-то третий у какого-то бедного программиста .СРР:
 переключатель (направление) {
 дело N:
 // ...
 дело NE:
 // ...
 // ...
 }

##### Записка

Не используйте 'ALL_CAPS' для констант только потому, что константы раньше были макросами.

##### Принуждение

Флаг все виды использования всех колпачков. Для более старого кода примите все заглавные буквы для имен макросов и отметьте все имена макросов, отличающиеся от всех заглавных букв.

### <a name= "Res-name-one"><a name="Res-name-one" ></a>ES.10: объявите одно имя (только) в объявлении

##### Причина

Одно объявление в строке повышает читаемость и позволяет избежать ошибок, связанных с
грамматика языка Си / Си++. Это также оставляет место для более описательного конца строки
Комментарий.

##### Пример, плохо

 char *p, c, a[7], *pp[7], * * aa[10]; / / фу!

##### Исключение

Объявление функции может содержать несколько объявлений аргументов функции.

##### Исключение

Структурированная привязка (C++17) специально разработана для введения нескольких переменных:

 auto [iter, inserted] = m. insert_or_assign(k, val);
 если (вставлено) { /* была вставлена новая запись */ }

##### Образец

 шаблон <класс InputIterator, предикат класса>
 bool any_of(inputiterator first, InputIterator last, предикат pred);

или лучше использовать понятия:

 bool any_of(inputiterator first, InputIterator last, предикат pred);

##### Образец

 double scalbn (double x, int n); / / OK: x * pow(FLT_RADIX, n); FLT_RADIX обычно равен 2

или:

 double scalbn (//better: x * pow(FLT_RADIX, n); FLT_RADIX обычно равен 2
 двойное x, / / базовое значение
 int n / / экспонента
 );

или:

 // better: base * pow(FLT_RADIX, exponent); FLT_RADIX обычно равен 2
 double scalbn(двойное основание, показатель степени int);

##### Образец

 int a = 7, b = 9, c, d = 10, e = 3;

В длинном списке деклараторов легко пропустить неинициализированную переменную.

##### Принуждение

Объявления переменной и константы флага с несколькими деклараторами (например, ' int* p, q;`)

### <a name= "Res-auto"><a name="Res-auto" ></a>ES.11: используйте `auto', чтобы избежать избыточного повторения имен типов

##### Причина

* Простое повторение утомительно и подвержено ошибкам.
* При использовании `auto`, имя объявленного объекта находится в фиксированном положении в объявлении, увеличивая читаемость.
* В объявлении функции шаблона тип возвращаемого значения может быть типом элемента.

##### Образец

Считать:

 auto p = v. begin (); / / вектор<int>:: итератор
 авто h = T. будущее();
 auto q = make_unique<int[]>(s);
 auto f = [] (int x){ return x + 10; };

В каждом случае мы сохраняем написание длинноватого, трудно запоминаемого типа, который компилятор уже знает, но программист может ошибиться.

##### Образец

 шаблон<класс T>
 auto Container<T>:: first () - < T>> Iterator; / / Container<T> > <T>:: Iterator

##### Исключение

Избегайте `авто` для списков инициализаторов и в тех случаях, когда вы точно знаете, какой тип вы хотите, и где инициализатор может потребовать преобразования.

##### Образец

 авто lst = { 1, 2, 3 }; // lst-это список инициализаторов
 auto x{1}; / / x-это int (в C++17; initializer_list в C++11)

##### Записка

Когда концепции становятся доступными, мы можем (и должны) быть более конкретными относительно типа, который мы выводим:

 // ...
 Форвардитератор p = algo(x, y, z);

##### Пример (C++17)

 auto [ фактор, остаток] = div (123456, 73); / / вырываются члены результата div_t

##### Принуждение

Флаг избыточного повторения имен типов в объявлении.

### <a name= "Res-reuse"><a name="Res-reuse" ></a>ES.12: не следует повторно использовать имена во вложенных областях

##### Причина

Легко запутаться в том, какая переменная используется.
Может вызвать проблемы с обслуживанием.

##### Пример, плохо

 int d = 0;
 // ...
 если (cond) {
 // ...
 d = 9;
 // ...
 }
 еще {
 // ...
 int d = 7;
 // ...
 d = value_to_be_returned;
 // ...
 }

 возвращение d;

Если это большое утверждение типа "если", то легко упустить из виду, что во внутреннюю область было введено новое "d".
Это известный источник ошибок.
Иногда такое повторное использование имени во внутренней области называется "затенение".

##### Записка

Затенение-это прежде всего проблема, когда функции слишком велики и слишком сложны.

##### Образец

Затенение аргументов функции в самом внешнем блоке не допускается языком:

 пустота f(int x)
 {
 int x = 4; / / ошибка: повторное использование имени аргумента функции

 если (x) {
 int x = 7; / / допустимо, но плохо
 // ...
 }
 }

##### Пример, плохо

Повторное использование имени элемента в качестве локальной переменной также может быть проблемой:

 структура S {
 int m;
 пустота f(int x);
 };

 void S:: f(int x)
 {
 m = 7; / / назначить участнику
 если (x) {
 int m = 9;
 // ...
 m = 99; / / присвоить локальной переменной
 // ...
 }
 }

##### Исключение

Мы часто повторно используем имена функций из базового класса в производном классе:

 структура B {
 void f(int);
 };

 структура D : B {
 void f (double);
 использование B:: f;
 };

Это приводит к ошибкам.
Например, если бы мы забыли объявление using, вызов "d.f(1)" не нашел бы версию " int " для "f".

??? Нужно ли нам конкретное правило о затенении / скрытии в иерархиях классов?

##### Принуждение

* Повторное использование флага имени во вложенных локальных областях
* Флаг повторного использования имени элемента в качестве локальной переменной в функции-члене
* Повторное использование флага глобального имени в качестве локальной переменной или имени элемента
* Флаг повторное использование имени члена базового класса в производном классе (за исключением имен функций)

### <a name= "Res-always"><a name="Res-always" ></a>ES.20: всегда инициализируйте объект

##### Причина

Избегайте ошибок, использованных до установки, и связанного с ними неопределенного поведения.
Избегайте проблем с пониманием сложной инициализации.
Упростите рефакторинг.

##### Образец

 пустое использование(int arg)
 {
 int i; / / bad: неинициализированная переменная
 // ...
 i = 7; / / инициализировать i
 }

Нет, "i = 7" не инициализирует "i"; он присваивает ему. Кроме того, " я "можно прочитать в"...` часть. Лучше:

 пустое использование(int arg) / / OK
 {
 int i = 7; / / OK: инициализировано
 строка s; / / OK: инициализация по умолчанию
 // ...
 }

##### Записка

Правило * always initialize * намеренно сильнее, чем правило* a object, которое должно быть установлено перед используемым правилом * language.
Последнее, более мягкое правило, улавливает технические ошибки, но:

* Это приводит к менее читаемому коду
* Это побуждает людей объявлять имена в большем объеме, чем это необходимо
* Это приводит к более сложному чтению кода
* Это приводит к логическим ошибкам, поощряя сложный код
* Это затрудняет рефакторинг

Правило * always initialize* - это правило стиля, направленное на улучшение ремонтопригодности, а также на защиту от ошибок, использованных до установки.

##### Образец

Вот пример, который часто считается демонстрирующим необходимость более расслабленного правила для инициализации

 widget i; / / "виджет" тип, который дорого инициализировать, возможно, большой стручок
 виджет j;

 if (cond) {//bad: I и j инициализируются " поздно"
 i = f1();
 j = f2();
 }
 еще {
 i = f3();
 j = f4();
 }

Это не может быть тривиально переписано для инициализации `i " и " j " с инициализаторами.
Обратите внимание, что для типов с конструктором по умолчанию попытка отложить инициализацию просто приводит к инициализации по умолчанию с последующим назначением.
Популярная причина для таких примеров - это "эффективность", но компилятор, который может определить, допустили ли мы ошибку, использованную до установки, также может устранить любую избыточную двойную инициализацию.

Предполагая, что существует логическая связь между `i` и 'j', эта связь, вероятно, должна быть выражена в коде:

 пара<виджет, виджет > make_related_widgets(bool x)
 {
 возвращение (x)? {f1 (), f2 ()}: {f3 (), f4() };
 }

 auto [i, j] = make_related_widgets(cond); / / C++17

Если функция make_related_widgets в противном случае является избыточной,
мы можем устранить его с помощью лямбда [ES.28] (#Res-lambda-init):

 auto [i, j] = [x] {return (x) ? пара{f1 (), f2 ()}: пара{f3 (), f4 ()} } (); / / C++17

Использование значения, представляющего собой "неинициализированный", является признаком проблемы, а не решением:

 виджет i = uninit; / / плохо
 виджет j = uninit;

 // ...
 использовать(i); / / возможно, используется до набора
 // ...

 if (cond) {//bad: I и j инициализируются " поздно"
 i = f1();
 j = f2();
 }
 еще {
 i = f3();
 j = f4();
 }

Теперь компилятор не может даже просто обнаружить используемый ранее набор. Кроме того, мы ввели сложность в пространстве состояний для виджета: какие операции допустимы для виджета "Unit", а какие нет?

##### Записка

Сложная инициализация была популярна среди умных программистов на протяжении десятилетий.
Это также было главным источником ошибок и сложностей.
Многие такие ошибки вводятся в течение нескольких лет обслуживания после первоначальной реализации.

##### Образец

Это правило распространяется на переменные-члены.

 класс X {
 Публично:
 X (int i, int ci): m2{i}, cm2{ci} {}
 // ...

 Частное:
 int m1 = 7;
 int m2;
 int m3;

 const int cm1 = 7;
 const int cm2;
 const int cm3;
 };

Компилятор будет отмечать неинициализированный 'cm3', потому что это `const`, но он не поймает отсутствие инициализации `m3`.
Как правило, редкая паразитная инициализация элемента стоит отсутствия ошибок из-за отсутствия инициализации и часто оптимизатора
можно исключить избыточную инициализацию (например, инициализацию, которая происходит непосредственно перед назначением).

##### Исключение

Если вы объявляете объект, который только что был инициализирован из входных данных, инициализация приведет к двойной инициализации.
Однако следует помнить, что это может оставить неинициализированные данные за пределами входных данных-и это было плодотворным источником ошибок и нарушений безопасности:

 constexpr int max = 8 * 1024;
 int buf[max]; / / OK, но подозрительно: неинициализированный
 f. read(buf, max);

Стоимость инициализации этого массива может быть значительной в некоторых ситуациях.
Однако такие примеры имеют тенденцию оставлять неинициализированные переменные доступными, поэтому к ним следует относиться с подозрением.

 constexpr int max = 8 * 1024;
 int buf[max] = {}; / / ноль всех элементов; лучше в некоторых ситуациях
 f. read(buf, max);

Из-за ограничительных правил инициализации для массивов и "std::array" они предлагают наиболее убедительные примеры необходимости этого исключения.

Когда это возможно, используйте функцию библиотеки, которая, как известно, не переполняется. Например:

 строка s; / / s по умолчанию инициализируется в ""
 cin >>> s; / / s раскрывается для удержания строки

Не рассматривайте простые переменные, являющиеся целевыми объектами для операций ввода исключений из этого правила:

 int i; / / плохо
 // ...
 cin >>> i;

В нередком случае, когда цель ввода и операция ввода разделяются (как это не должно быть), открывается возможность использования до установки.

 int i2 = 0; / / лучше, если предположить, что ноль является приемлемым значением для i2
 // ...
 cin >>> i2;

Хороший оптимизатор должен знать о входных операциях и исключить избыточную операцию.


##### Записка

Иногда лямбда-код может использоваться в качестве инициализатора, чтобы избежать неинициализированной переменной:

 error_code ec;
 Значение v = [&] {
 auto p = get_value (); / / get_value () возвращает пару<error_code, Value>
 ec = p. первый;
 возвращение p. second;
 }();

или, может быть:

 Значение v = [] {
 auto p = get_value (); / / get_value () возвращает пару<error_code, Value>
 если (p.first) бросить Bad_value{p. first};
 возвращение p. second;
 }();

** Смотрите также**: [ES.28] (#Res-lambda-init)

##### Принуждение

* Пометить каждую неинициализированную переменную.
 Не помечайте переменные пользовательских типов конструкторами по умолчанию.
* Проверьте, что неинициализированный буфер записывается в *Немедленно* после объявления.
 Передача неинициализированной переменной в качестве ссылки на аргумент non-`const ' можно считать записью в переменную.

### <a name= "Res-introduct"><a name="Res-introduct" ></a>ES.21: Не вводите переменную (или константу) перед ее использованием

##### Причина

Удобочитаемость. Чтобы ограничить область, в которой может использоваться переменная.

##### Образец

 int x = 7;
 // ... здесь нет никакой пользы от X...
 ++икс;

##### Принуждение

Объявления флагов, которые удалены от их первого использования.

### <a name= "Res-init"><a name="Res-init" ></a>ES.22: не объявляйте переменную, пока у вас нет значения для ее инициализации с помощью

##### Причина

Удобочитаемость. Ограничьте область, в которой может использоваться переменная. Не рискуйте использовать-перед-набором. Инициализация часто более эффективна, чем назначение.

##### Пример, плохо

 строка s;
 // ... здесь нет никакой пользы от s ...
 s = " что за расточительство";

##### Пример, плохо

 SomeLargeType var; / / ugly CaMeLcAsEvArIaBlE

 если (cond) / / некоторое нетривиальное условие
 Set(&var);
 иначе если (cond2 || !cond3) {
 var = Set2(3.14);
 }
 еще {
 var = 0;
 для (auto& e: что-то)
 var += e;
 }

 // используйте var; то, что это не делается слишком рано, может быть применено статически только с потоком управления

Это было бы прекрасно, если бы была инициализация по умолчанию для `SomeLargeType`, которая не была слишком дорогой.
В противном случае программист может очень хорошо задаться вопросом, был ли покрыт каждый возможный путь через лабиринт условий.
Если нет, у нас есть ошибка "использовать перед установкой". Это ловушка технического обслуживания.

Для инициализаторов средней сложности, в том числе для переменных` const', рассмотрите возможность использования лямбды для выражения инициализатора; см. [ES.28] (#Res-lambda-init).

##### Принуждение

* Объявления флагов с инициализацией по умолчанию, которые назначаются до их первого чтения.
* Помечать любое сложное вычисление после неинициализированной переменной и до ее использования.

### <a name= "Res-list"><a name="Res-list" ></a>ES.23: предпочтите синтаксис `{} ' - инициализатора

##### Причина

Предпочитать.`}{`  Правила для инициализации '{} ' являются более простыми, более общими, менее двусмысленными и безопасными, чем для других форм инициализации.

Используйте ` = ' только тогда, когда вы уверены, что не может быть никаких сужающих преобразований. Для встроенных арифметических типов используйте ` = 'только с 'auto'.

Избегайте инициализации ` ()`, которая позволяет анализировать неоднозначности.

##### Образец

 int x {f (99)};
 int y = x;
 вектор<int > v = {1, 2, 3, 4, 5, 6};

##### Исключение

Для контейнеров существует традиция использования `{...} 'для списка элементов и `(...)` для размера:

 вектор<int> v1(10); / / вектор из 10 элементов со значением по умолчанию 0
 вектор<int > v2{10}; / / вектор 1 элемента со значением 10

 вектор<int> v3(1, 2); / / вектор 1 элемента со значением 2
 вектор<int> v4{1, 2}; / / вектор элемента 2 со значениями 1 и 2

##### Записка

`{} '- инициализаторы не позволяют сужать преобразования (и это обычно хорошо) и разрешают явные конструкторы (что хорошо, мы намеренно инициализируем новую переменную).

##### Образец

 int x {7.9}; / / ошибка: сужение
 int y = 7.9; / / OK: y становится 7. Надеемся на предупреждение компилятора
 int z = gsl:: narrow_cast<int>(7.9); / / OK: вы просили об этом

##### Записка

инициализация ` {} ' может использоваться почти для всех инициализаций; другие формы инициализации не могут:

 auto p = новый вектор<int> {1, 2, 3, 4, 5}; // инициализированный вектор
 D:: D(int a, int b): M{a, b} { // инициализатор элемента (например, m может быть парой)
 // ...
 };
 X var {}; / / инициализировать var, чтобы он был пустым
 структура S {
 int m {7}; / / инициализатор по умолчанию для элемента
 // ...
 };

По этой причине `{} '- инициализация часто называется " равномерной инициализацией"
(хотя, к сожалению, осталось несколько неровностей).

##### Записка

Инициализация переменной, объявленной с помощью` auto `с одним значением, например,` {v}', имела удивительные результаты вплоть до C++17.
Правила C++17 несколько менее удивительны:

 auto x1 {7}; / / x1-это int со значением 7
 auto x2 = {7}; / / x2-это initializer_list<int> с элементом 7

 auto x11 {7, 8}; / / Ошибка: два инициализатора
 auto x22 = {7, 8}; / / x22-это initializer_list<int> с элементами 7 и 8

Использовать.{=` ..} 'если вы действительно хотите' initializer_list<T>`

 автоматическое fib10 = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55}; // fib10-это список

##### Записка

'={} 'дает инициализацию копирования, тогда как ` {}' дает прямую инициализацию.
Как и различие между копированием-инициализацией и самой прямой инициализацией, это может привести к неожиданностям.
'{} 'принимает' явные 'конструкторы;' = {} ' - нет. Например:

 struct Z { явный Z() {} };

 Z z1 {}; / / OK: прямая инициализация, поэтому мы используем явный конструктор
 Z z2 = {}; / / ошибка: копирование инициализации, поэтому мы не можем использовать явный конструктор

Используйте простую `{} ' - инициализацию, если вы специально не хотите отключить явные конструкторы.

##### Образец

 шаблон<typename T>
 пустота f()
 {
 T x1(1); / / t инициализируется с помощью 1
 T x0 (); / / bad: объявление функции (часто ошибка)

 T y1 {1}; / / t инициализируется с 1
 T y0 {}; / / инициализированный по умолчанию T
 // ...
 }

**Смотрите также**: [обсуждение](#???)

##### Принуждение

* Флаг использует ` = 'для инициализации арифметических типов, где происходит сужение.
* Флаг использует синтаксис инициализации ` ()`, которые на самом деле являются объявлениями. (Многие компиляторы уже должны предупреждать об этом.)

### <a name= "Res-unique"><a name="Res-unique" ></a>ES.24: используйте ' unique_ptr<T>', чтобы удерживать указатели

##### Причина

Использование 'std:: unique_ptr' является самым простым способом избежать утечек. Он надежен, это
делает типовую систему сделать много из работы для того чтобы утвердить безопасность владения, его
повышается читаемость, и он имеет нулевую или почти нулевую стоимость времени выполнения.

##### Образец

 пустое использование(утечка bool)
 {
 auto p1 = make_unique<int > (7); / / OK
 int* p2 = new int{7}; / / плохо: может произойти утечка
 // ... нет присвоения p2 ...
 если (утечка) возвращение;
 // ... нет присвоения p2 ...
 вектор<int> v(7);
 v.at(7) = 0; / / брошено исключение
 // ...
 }

Если 'leak = = true' объект, на который указывает `p2`, протекает, а объект, на который указывает `p1`, нет.
То же самое происходит, когда `at()` бросает.

##### Принуждение

Ищите необработанные указатели, которые являются целями `new`, ' malloc ()', или функции, которые могут возвращать такие указатели.

### <a name= "Res-const"><a name="Res-const" ></a>ES.25: объявите объект 'const' или` constexpr', если вы не хотите изменить его значение позже

##### Причина

Таким образом, вы не можете изменить значение по ошибке. Этот способ может предложить компилятору возможности оптимизации.

##### Образец

 void f(int n)
 {
 const int bufmax = 2 * n + 2; / / Хорошо: мы не можем изменить bufmax случайно
 int xmax = n; / / подозрительно: предполагается ли изменение xmax?
 // ...
 }

##### Принуждение

Посмотрите, действительно ли переменная мутировала, и отметьте ее, если
нет. К сожалению, может быть невозможно обнаружить, когда не - 'const' не было
* намеревался * варьироваться (против, когда он просто не менялся).

### <a name= "Res-recycle"><a name="Res-recycle" ></a>ES.26: не используйте переменную для двух несвязанных целей

##### Причина

Читаемость и безопасность.

##### Пример, плохо

 пустое использование()
 {
 int i;
 ибо (i = 0; i .. */ }
 ибо (i = 0; i .. * / } / / плохо: я переработал
 }

##### Записка

В качестве оптимизации вы можете захотеть повторно использовать буфер в качестве скретч-пэда, но даже тогда предпочитаете максимально ограничить область действия переменной и быть осторожными, чтобы не вызвать ошибки из данных, оставленных в переработанном буфере, поскольку это общий источник ошибок безопасности.

 void write_to_file() {
 std:: string buffer; / / чтобы избежать перераспределений на каждой итерации цикла
 для (auto& o : объектов)
 {
 // Первая часть работы.
 generate_first_string(буфер, o);
 write_to_file (буфер);

 // Вторая часть работы.
 generate_second_string(буфер, o);
 write_to_file (буфер);

 // прием...
 }
 }

##### Принуждение

Флаг переработанных переменных.

### <a name= "Res-stack"><a name="Res-stack" ></a>ES.27: используйте 'std:: array' или 'stack_array' для массивов в стеке

##### Причина

Они читаемы и не обязательно преобразуются в указатели.
Их не путают с нестандартными расширениями встроенных массивов.

##### Пример, плохо

 const int n = 7;
 int m = 9;

 пустота f()
 {
 int a1[n];
 int a2[m]; / / ошибка: не ISO C++
 // ...
 }

##### Записка

Определение `a1 " является юридическим C++ и всегда было таким.
Такого кода существует очень много.
Однако он подвержен ошибкам, особенно когда граница не является локальной.
Кроме того, это "популярный" источник ошибок (переполнение буфера, указатели от распада массива и т. д.).
Определение `a2 " является C, но не C++ и считается угрозой безопасности

##### Образец

 const int n = 7;
 int m = 9;

 пустота f()
 {
 массив<int, n > a1;
 stack_array<int> a2(m);
 // ...
 }

##### Принуждение

* Флаговые массивы с непостоянными границами (C-style VLAs)
* Флаговые массивы с нелокальными границами констант

### <a name= "Res-lambda-init"></a>ES.28: используйте лямбды для комплексной инициализации, особенно переменных `const` 

##### Причина

Он прекрасно инкапсулирует локальную инициализацию, включая очистку переменных нуля, необходимых только для инициализации, без необходимости создавать ненужную нелокальную, но непростимую функцию. Он также работает для переменных, которые должны быть "const", но только после некоторой работы инициализации.

##### Пример, плохо

 виджет x; // должен быть const, но:
 для (auto i = 2; i 
 x += some_obj. do_something_with(i); / / произвольно длинный код
 } / / необходимо инициализировать x
 // отсюда x должен быть const, но мы не можем сказать это в коде в этом стиле

##### Пример, хорошо

 const виджет x = [&]{
 widget val; / / предположим, что виджет имеет конструктор по умолчанию
 для (auto i = 2; i 
 val += some_obj. do_something_with(i); / / произвольно длинный код
 } / / необходимо инициализировать x
 возвращение Валя;
 }();

##### Образец

 строка var = [&]{
 если (!in) возврат "; / / default
 строка s;
 для (char c : in >>> c)
 s += toupper(c);
 возврат s;
 }(); // записка ()

Если это вообще возможно, сведите условия к простому набору альтернатив (например, "перечисление") и не путайте выбор и инициализацию.

##### Принуждение

Трудный. В лучшем случае это эвристика. Найдите неинициализированную переменную, за которой следует цикл, назначенный ей.

### <a name= "Res-macros"><a name="Res-macros" ></a>ES.30: не используйте макросы для обработки текста программы

##### Причина

Макросы являются главным источником ошибок.
Макросы не подчиняются обычным правилам области и типа.
Макросы гарантируют, что человек-читатель видит что-то отличное от того, что видит компилятор.
Макросы усложняют построение инструментов.

##### Пример, плохо

 #define Case break; case / * BAD */

Этот безобидный на вид макрос превращает единственный нижний регистр `c "вместо" C " в плохую ошибку управления потоком.

##### Записка

Это правило не запрещает использование макросов для "управления конфигурацией"использовать в' #ifdef и т.д.

В будущем модули, скорее всего, устранят необходимость в макросах для управления конфигурацией.

##### Записка

Это правило также должно препятствовать использованию ` # ` для стрингификации и ` # # ' для конкатенации.
Как обычно для макросов, есть использование, которое "в основном безвредно", но даже они могут создавать проблемы для инструментов,
такие как автоматические завершители, статические анализаторы и отладчики.
Часто желание использовать причудливые макросы является признаком чрезмерно сложного дизайна.
Кроме того, ` # 'и ` # #' поощряют определение и использование макросов:

 # определите CAT (a, b) a ## b
 #define STRINGIFY (a) #a

 void f(int x, int y)
 {
 строка CAT (x, y) = "asdf"; / / плохо: трудно обрабатывать инструменты (и некрасиво)
 строка sx2 = STRINGIFY(x);
 // ...
 }

Существуют обходные пути для низкоуровневой обработки строк с помощью макросов. Например:

 строка s = "asdf ""lkjh"; / / обычная конкатенация строковых литералов

 перечисление E { a, b };

 шаблон<int x>
 constexpr const char * stringify()
 {
 переключатель (x) {
 случай а: возвращение "а";
 случай b: возвращение "b";
 }
 }

 void f(int x, int y)
 {
 строка sx = stringify<x>();
 // ...
 }

Это не так удобно, как макрос для определения, но так же просто в использовании, имеет нулевые накладные расходы, а также типизирован и область действия.

В будущем статическое отражение, вероятно, устранит последние потребности в препроцессоре для обработки текста программы.

##### Принуждение

Кричите, когда вы видите макрос, который не только используется для управления исходным кодом (например, ' #ifdef`)

### <a name= "Res-macros2"><a name="Res-macros2" ></a>ES.31: Не используйте макросы для констант или " функций"

##### Причина

Макросы являются главным источником ошибок.
Макросы не подчиняются обычным правилам области и типа.
Макросы не подчиняются обычным правилам передачи аргументов.
Макросы гарантируют, что человек-читатель видит что-то отличное от того, что видит компилятор.
Макросы усложняют построение инструментов.

##### Пример, плохо

 #определить PI 3.14
 #определить квадрат (a, b) (a * b)

Даже если бы мы не оставили хорошо известную ошибку в " квадрате` , есть гораздо лучшие варианты поведения; например:

 constexpr double pi = 3,14;
 template<typename T> T square (T a, T b) { return a * b; }

##### Принуждение

Кричите, когда вы видите макрос, который не только используется для управления исходным кодом (например, ' #ifdef`)

### <a name= "Res-ALL_CAPS"><a name="Res-ALL_CAPS" ></a>ES.32: используйте ' ALL_CAPS` для всех имен макросов

##### Причина

Конвенция. Удобочитаемость. Различение макросов.

##### Образец

 #define forever for (;;) / * очень плохо */

 #define FOREVER for (;;) / * все еще зло, но по крайней мере видимое людям */

##### Принуждение

Кричите, когда вы видите нижний регистр макроса.

### <a name= "Res-MACROS"><a name="Res-MACROS" ></a>ES.33: Если необходимо использовать макросы, присвойте им уникальные имена

##### Причина

Макросы не подчиняются правилам области видимости.

##### Образец

 #define MYCHAR / * плохо, в конечном итоге столкнется с чужим MYCHAR*/

 #define ZCORP_CHAR / * по-прежнему зло, но с меньшей вероятностью столкновения */

##### Записка

Избегайте макросов, если это возможно: [ES.30] (#Res-macros), [ES.31] (#Res-macros2), и [ES.32] (#Res-ALL_CAPS).
Однако существуют миллиарды строк кода, заваленных макросами, а также давняя традиция использования и чрезмерного использования макросов.
Если вы вынуждены использовать макросы, используйте длинные имена и предположительно уникальные префиксы (например, имя вашей организации), чтобы снизить вероятность столкновения.

##### Принуждение

Предостерегайте от коротких имен макросов.

### <a name= "Res-эллипсы"><a name="Res-эллипсы" ></a> ES.34: не определяйте (C-style) вариативную функцию

##### Причина

Не тип-сейф.
Требуется грязный литой и макро-нагруженный код, чтобы правильно работать.

##### Образец

 #include <cstdarg>

 // "серьезность" с последующим нулевым завершением списка символов*s; запишите строки C-style в cerr
 ошибка void (int severity ...)
 {
 va_list ap; / / магический тип для удержания аргументов
 va_start(ap, серьезность); / / запуск arg: "серьезность" является первым аргументом ошибки()

 для (;;) {
 // рассматривайте следующий var как символ*; нет проверки: скрытый гипс
 char* p = va_arg(ap, char*);
 если (!p) перерыв;
 cerr << p <;
 }

 va_end(ap); / / ARG cleanup (не забывайте об этом)

 cerr <;
 если (серьезность) выход(серьезность);
 }

 пустое использование()
 {
 error(7, "this", "is", "an", "error", nullptr);
 Ошибка(7); / / сбой
 Ошибка(7, "это", "is", "an", "error"); / / сбой
 const char* is = " is";
 строка an = " an";
 Ошибка(7, "это", "есть", an, "ошибка"); / / сбой
 }

** Альтернатива**: Перегрузка. Шаблоны. Вариадические шаблоны.

 #include <iostream>

 ошибка void(int серьезность)
 {
 std:: cerr <;
 std:: exit(серьезность);
 }

 шаблон .. Ts>
 constexpr void error(int severity, t head, Ts... хвост)
 {
 std:: cerr <;
 ошибка(серьезность, хвост...);
 }

 пустое использование()
 {
 Ошибка(7); / / Нет аварии!
 Ошибка(5, "это", "is", "not", "an", "error"); / / нет аварии!

 std:: строка an = " an";
 Ошибка (7, "это", "есть", "нет", an, "ошибка"); / / Нет аварии!

 Ошибка(5, "О", "нет", nullptr); // ошибка компиляции! Нет необходимости в nullptr.
 }


##### Записка

Это в основном способ реализации "printf".

##### Принуждение

* Определения флагов вариативных функций C-style.
* Флаг '#include <cstdarg> ' и ' #include <cstdarg>ч`>


## ES.expr: выражения

Выражения манипулируют значениями.

### <a name= "Res-complicated"><a name="Res-complicated" ></a>ES.40: избегайте сложных выражений

##### Причина

Сложные выражения подвержены ошибкам.

##### Образец

 // плохо: назначение скрыто в подвыражении
 в то время как ((c = getc()) != -1)

 // bad: две нелокальные переменные, назначенные в суб-выражениях
 в то время как ((cin >>> c1, cin > > > > > > > c2), c1 == c2)

 // лучше, но, возможно, все еще слишком сложно
 для (char c1, c2; cin > > > c1 > > > > > > > c2 && c1 == c2;)

 // OK: если I и j не сглажены
 int x = ++i + ++j;

 // OK: если я != j и я != k
 v[i] = v [j] + v[k];

 // плохо: несколько назначений "скрыты" в подвыражениях
 x = a + (b = f ()) + (c = g ()) * 7;

 // плохо: полагается на часто неправильно понимаемые правила приоритета
 x = a & b + c * d & & e ^ f = = 7;

 // плохо: неопределенное поведение
 x = x++ + x++ + ++x;

Некоторые из этих выражений безусловно плохие (например, они полагаются на неопределенное поведение). Другие просто настолько сложны и / или необычны, что даже хорошие программисты могут неправильно понять их или пропустить проблему, когда торопятся.

##### Записка

C++17 ужесточает правила для порядка проведения оценки
(слева направо, кроме справа налево в назначениях, и порядок вычисления аргументов функции не определен; [см. ES.43] (#Res-order)),
но это не меняет того факта, что сложные выражения потенциально сбивают с толку.

##### Записка

Программист должен знать и использовать основные правила для выражений.

##### Образец

 x = k * y + z; / / OK

 auto t1 = k * y; / / плохо: излишне многословно
 x = t1 + z;

 если (0 <= x && x 

 авто t1 = 0 
 авто t2 = x ;
 если (t1 && t2)//...

##### Принуждение

Хитрый. Насколько сложным должно быть выражение, чтобы его можно было считать сложным? Написание вычислений в виде операторов с одной операцией каждый также запутанно. Есть над чем задуматься:

* побочные эффекты: Побочные эффекты для нескольких нелокальных переменных (для некоторых определений нелокальных) могут быть подозрительными, особенно если побочные эффекты находятся в отдельных подвыражениях
* запись в псевдонимы переменных
* больше, чем N операторов (а каким должен быть N?)
* опора на тонкие правила приоритета
* использует неопределенное поведение (можем ли мы поймать все неопределенное поведение?)
* реализация определенного поведения?
* ???

### <a name= "Res-parens"><a name="Res-parens" ></a>ES.41: Если вы сомневаетесь в приоритете оператора, заключите его в скобки

##### Причина

Во избежание ошибок. Удобочитаемость. Не все помнят таблицу оператора.

##### Образец

 флаг const unsigned int = 2;
 unsigned int a = флаг;

 если (a & флаг != 0) / / плохо: означает a&(флаг != 0)

Примечание: мы рекомендуем программистам знать свою таблицу приоритетов для арифметических операций, логических операций, но рассмотреть возможность смешивания побитовых логических операций с другими операторами, нуждающимися в скобках.

 если ((a & флаг)!= 0) / / OK: работает по назначению

##### Записка

Вы должны знать достаточно, чтобы не нуждаться в скобках для:

 если (a < 0 | / a ) {
 // ...
 }

##### Принуждение

* Комбинации флагов побитовых логических операторов и других операторов.
* Операторы присвоения флагов не являются крайними левыми операторами.
* ???

### <a name= "Res-ptr"><a name="Res-ptr" ></a>ES.42: держите использование указателей простым и прямым

##### Причина

Сложные манипуляции с указателями являются главным источником ошибок.

##### Записка

Вместо этого используйте `gsl::span`.
Указатели должны [ссылаться только на отдельные объекты] (#ri-array).
Указатель арифметика хрупкая и легко ошибиться, источник многих, многих плохих ошибок и нарушений безопасности.
'span' -это проверенный границами безопасный тип для доступа к массивам данных.
Доступ к массиву с известными границами, использующий константу в качестве подстрочного индекса, может быть проверен компилятором.

##### Пример, плохо

 void f(int* p, int count)
 {
 если (подсчет ;

 int* q = p + 1; / / плохо

 ptrdiff_t d;
 int n;
 d = (p - &n); // OK
 d = (q-p); / / OK

 int n = * p++; / / плохо

 если (подсчет ;

 p[4] = 1; / / плохо

 p[count-1] = 2; / / плохо

 use(&p[0], 3); / / плохо
 }

##### Пример, хорошо

 void f (span<int> a) / / BETTER: используйте span в объявлении функции
 {
 если (a. size() ;

 int n = a[0]; / / OK

 span<int > q = A. subspan(1); / / OK

 если (a. size() ;

 a[4] = 1; / / OK

 a[a. размер() - 1] = 2; // окей

 использовать(a. data (), 3); / / OK
 }

##### Записка

Подписка с переменной трудно как для инструментов, так и для людей, чтобы проверить как безопасный.
'span' -это проверенный во время выполнения безопасный тип границ для доступа к массивам данных.
'at ()' - это еще одна альтернатива, которая гарантирует, что единичные обращения проверяются границами.
Если итераторы необходимы для доступа к массиву, используйте итераторы из "промежутка", построенного над массивом.

##### Пример, плохо

 void f (массив<int, 10> a, int pos)
 {
 a[pos / 2] = 1; / / плохо
 a[pos-1] = 2; / / плохо
 a[-1] = 3; / / плохо (но легко ловится инструментами) - нет замены, просто не делайте этого
 a[10] = 4; / / плохо (но легко ловится инструментами) - нет замены, просто не делайте этого
 }

##### Пример, хорошо

Используйте `span`:

 void f1(span<int, 10> a, int pos) / / A1: изменить тип параметра для использования span
 {
 a[pos/ 2] = 1; / / OK
 a[pos-1] = 2; / / OK
 }

 void f2(array<int, 10> arr, int pos) / / A2: добавьте локальный диапазон и используйте его
 {
 span<int> a = {arr.data (), pos};
 a[pos/ 2] = 1; / / OK
 a[pos-1] = 2; / / OK
 }

Используйте `at()`:

 void f3 (array<int, 10> a, int pos) / / альтернатива B: используйте at() для доступа
 {
 at(a, pos / 2) = 1; / / OK
 at(a, pos-1) = 2; / / OK
 }

##### Пример, плохо

 пустота f()
 {
 int arr[COUNT];
 для (int i = 0; i )
 arr[i] = i; / / плохо, нельзя использовать непостоянный индексатор
 }

##### Пример, хорошо

Используйте `span`:

 пустота f1()
 {
 int arr[COUNT];
 span<int> av = arr;
 для (int i = 0; i )
 av[i] = i;
 }

Используйте 'span' и диапазон- ' for`:

 пустота f1a()
 {
 int arr[COUNT];
 span<int, COUNT> av = arr;
 int i = 0;
 для (auto& e: av)
 e = i++;
 }

Используйте `at () ' для доступа:

 пустота f2()
 {
 int arr[COUNT];
 для (int i = 0; i )
 at(arr, i) = i;
 }

Используйте диапазон-`для':

 пустота f3()
 {
 int arr[COUNT];
 int i = 0;
 для (auto& e: arr)
 e = i++;
 }

##### Записка

Инструментарий может предложить перезапись доступа к массиву, которая включает выражения динамического индекса для использования `at()` вместо этого:

 static int a[10];

 void f(int i, int j)
 {
 a[i + j] = 12; / / плохо, можно переписать как...
 at(a, i + j) = 12; / / OK -- bounds-проверено
 }

##### Образец

Превращение массива в указатель (как это делает язык практически всегда) удаляет возможности для проверки, поэтому избегайте его

 void g(int* p);

 пустота f()
 {
 int a[5];
 g (a); / / BAD: мы пытаемся передать массив?
 g(&a[0]); / / OK: передача одного объекта
 }

Если вы хотите передать массив, скажите это:

 void g(int* p, длина size_t); / / старый (опасный) код

 void g1 (span<int> av); // BETTER: get g () changed.

 пустота f2()
 {
 int a[5];
 span<int> av = a;

 g(av.data (), av.размер ()); / / OK, если у вас нет выбора
 g1(a); / / OK -- здесь нет распада, вместо этого используйте неявный span ctor
 }

##### Принуждение

* Отметьте любую арифметическую операцию над выражением типа указателя, которая приводит к значению типа указателя.
* Помечает любое выражение индексирования для выражения или переменной типа массива (либо статический массив, либо` std::array`), где индексатор не является выражением константы времени компиляции со значением между` 0 ' и верхней границей массива.
* Помечает любое выражение, которое будет зависеть от неявного преобразования типа массива в тип указателя.

Это правило является частью профиля безопасности [bounds-safety] (#SS-bounds).


### <a name= "Res-order"><a name="Res-order" ></a>ES.43: избегайте выражений с неопределенным порядком вычисления

##### Причина

Вы понятия не имеете, что делает такой код. Портативность.
Даже если он делает что-то разумное для вас, он может сделать что-то другое на другом компиляторе (например, в следующем выпуске вашего компилятора) или с другой настройкой оптимизатора.

##### Записка

C++17 ужесточает правила для порядка проведения оценки:
слева направо, за исключением справа налево в назначениях, и порядок вычисления аргументов функции не определен.

Однако помните, что ваш код может быть скомпилирован с помощью компилятора pre-C++17 (например, через cut-and-paste), поэтому не будьте слишком умны.

##### Образец

 v[i] = ++i; / / результат не определен

Хорошее эмпирическое правило состоит в том, что вы не должны читать значение дважды в выражении, где вы его записываете.

##### Принуждение

Может быть обнаружен хорошим анализатором.

### <a name= "Res-order-fct"></a>ES.44: не зависит от порядка вычисления аргументов функции

##### Причина

Потому что этот порядок не определен.

##### Записка

C++17 ужесточает правила для порядка вычисления, но порядок вычисления аргументов функции все еще не определен.

##### Образец

 int i = 0;
 f (++i, ++i);

Вызов, скорее всего, будет "f(0, 1)" или " f(1, 0)", но вы не знаете, какой именно.
Технически, поведение не определено.
В C++17 этот код не имеет неопределенного поведения, но все еще не определено, какой аргумент вычисляется первым.

##### Образец

Перегруженные операторы могут привести к порядку проблем оценки:

 f1 () - >m (f2 ()); / / m (f1 (), f2())
 cout < < f1 () < < f2 (); / / operator<<(operator<())

В C++17 эти примеры работают должным образом (слева направо) и назначения оцениваются справа налево (так же, как привязка = ' S является справа налево)

 f1 () = f2 (); / / неопределенное поведение в C++14; в C++17, f2 () оценивается перед f1()

##### Принуждение

Может быть обнаружен хорошим анализатором.

### <a name= "Res-magic"><a name="Res-magic" ></a>ES.45: избегайте "магических констант"; используйте символические константы

##### Причина

Неназванные константы, встроенные в выражения, легко пропускаются и часто трудно понять:

##### Образец

 для (int m = 1; m 
 cout < < месяц[m] <;

Нет, мы не все знаем, что есть 12 месяцев, пронумерованных 1..12, через год. Лучше:

 // месяцы проиндексированы на 1..12
 constexpr int first_month = 1;
 constexpr int last_month = 12;

 для (int m = first_month; m 
 cout < < месяц[m] <;

А еще лучше, не выставляйте константы:

 для (auto m: месяц)
 cout << m <;

##### Принуждение

Флаговые литералы в коде. Дайте пропуск к `0`, `1`, `nullptr`, ` \n`, '"" и другим в положительном списке.

### <a name= "Res-сужение"><a name="Res-сужение" ></a>ES.46: избегайте потерь (сужение, усечение) арифметических преобразований

##### Причина

Сужающее преобразование уничтожает информацию, часто неожиданно.

##### Пример, плохо

Ключевым примером является базовое сужение:

 двойной d = 7,9;
 int i = d; / / bad: сужение: i становится 7
 i = (int) d; / / bad: мы собираемся утверждать, что это все еще недостаточно ясно

 пустота f(int x, long y, double d)
 {
 char c1 = x; / / bad: сужение
 char c2 = y; / / bad: сужение
 char c3 = d; / / bad: сужение
 }

##### Записка

Библиотека поддержки руководящих принципов предлагает операцию 'narrow_cast' для указания того, что сужение допустимо, и 'узкий' ("узкий, Если"), который создает исключение, если сужение отбрасывает информацию:

 i = narrow_cast<int>(d); / / OK (вы просили об этом): сужение: i становится 7
 i = узкий<int>(d); / / OK: броски narrowing_error

Мы также включаем арифметические приведения с потерями, такие как от отрицательного типа с плавающей запятой до беззнакового интегрального типа:

 двойной d = -7,9;
 без знака u = 0;

 u = d; / / плохо
 u = narrow_cast<unsigned>(d); / / OK (вы просили об этом): u становится 4294967289
 u = узкий<без знака>(d); / / OK: выбрасывает ошибку narrowing_error

##### Принуждение

Хороший анализатор может обнаружить все сужающие преобразования. Однако пометка всех сужающих преобразований приведет к большому количеству ложных срабатываний. Предложения:

* Отметьте все преобразования с плавающей запятой в целочисленные (возможно, только 'float' - > 'char' и 'double` - >>`int'. Здесь будут драконы! нам нужны данные).
* Флаг all 'long' - > 'char' (я подозреваю, что 'int' - >> 'char' очень распространен. Здесь будут драконы! нам нужны данные).
* Рассмотрите возможность сужения преобразований для аргументов функций, особенно подозрительных.

### <a name= "Res-nullptr"><a name="Res-nullptr"></a>ES.47: используйте `nullptr 'вместо `0' или ' NULL`

##### Причина

Удобочитаемость. Минимизировать сюрпризы: `nullptr ' нельзя спутать с Ан
`int.` `nullptr ' также имеет четко определенный (очень ограничительный) тип, и таким образом
работает в других сценариях, где дедукция типа может сделать неправильную вещь на ' NULL`
или `0'.

##### Образец

Считать:

 void f(int);
 пустота f(char*);
 f (0); / / вызов f (int)
 f (nullptr); / / вызов f (char*)

##### Принуждение

Флаг использует `0` и 'NULL' для указателей. Преобразованию может помочь простое преобразование программы.

### <a name= "Res-casts"><a name="Res-casts" ></a>ES.48: избегайте слепков

##### Причина

Слепки-это хорошо известный источник ошибок. Сделайте некоторые оптимизации ненадежными.

##### Пример, плохо

 двойной d = 2;
 auto p = (long*)&d;
 auto q = (long long*)&d;
 cout << d < < ''< < * p < < '' < < q <;

Как вы думаете, что этот фрагмент отпечатки? Результат в лучшем случае определяется реализацией. Я получил

 2 0 4611686018427387904

Добавление

 * q = 666;
 cout << d < < ''< < * p < < '' < < q <;

Я получил

 3.29048 e-321 666 666

- Удивлен? Я просто рад, что не сломал программу.

##### Записка

Программисты, которые пишут касты, обычно предполагают, что они знают, что они делают,
или что написание актерского состава делает программу "легче читать".
На самом деле, они часто отключают общие правила для использования значений.
Разрешение перегрузки и создание экземпляра шаблона обычно выбирают правильную функцию, если есть правильная функция для выбора.
Если его нет, возможно, он должен быть, а не применять локальное исправление (приведение).

##### Записка

Приведения необходимы в системном языке программирования. Например, как же иначе
получим ли мы адрес регистра устройства в указатель? Однако, бросает
они серьезно злоупотребляют, а также являются главным источником ошибок.

##### Записка

Если вы чувствуете потребность в большом количестве слепков, может возникнуть фундаментальная проблема проектирования.

##### Исключение

Приведение к `(void) `является стандартным санкционированным способом отключения` [[nodiscard]] ' предупреждений. Если вы вызываете функцию с` [[nodiscard]] 'return и намеренно хотите отказаться от результата, сначала подумайте о том, действительно ли это хорошая идея (обычно есть веская причина, по которой автор функции или используемый тип возврата `[[nodiscard]]`), но если вы все еще считаете, что это уместно, и ваш рецензент кода соглашается, напишите" (void)", чтобы отключить предупреждение.

##### Альтернативы

Широко используются слепки (mis). Современный C++ имеет правила и конструкции, которые устраняют необходимость приведения во многих контекстах, таких как

* Использовать шаблоны
* Используйте ' std:: variant`
* Полагайтесь на четко определенные, безопасные, неявные преобразования между типами указателей

##### Принуждение

* Принудительно отмените приведения в стиле C, за исключением функции с возвращением` [[nodiscard]]'.
* Предупредите, если существует много функциональных стилей слепков (существует очевидная проблема в количественной оценке "многих").
* Профиль [type] (#Pro-type-reinterpretcast) запрещает `reinterpret_cast`.
* Предупреждать о [приведении идентификаторов] (#Pro-type-identitycast) между типами указателей, где исходные и целевые типы одинаковы (#Pro-type-identitycast).
* Предупреждать, если приведение указателя может быть [неявным](#Pro-type-implicitpointercast).

### <a name= "Res-casts-named"><a name="Res-casts-named" ></a>ES.49: Если необходимо использовать приведение, используйте именованное приведение

##### Причина

Удобочитаемость. Предотвращение ошибок.
Именованные приведения более специфичны, чем c-стиль или функциональное приведение, что позволяет компилятору перехватывать некоторые ошибки.

Названные касты являются:

* 'static_cast`
* 'const_cast`
* 'reinterpret_cast`
* 'dynamic_cast`
* 'std:: move' / / 'move(x)' является ссылкой rvalue на `x`
* 'std:: forward' / / 'forward<T>(x)' является ссылкой rvalue или lvalue на `x ' в зависимости от `T`
* 'gsl:: narrow_cast' / / 'narrow_cast<T>(x) ` - это' static_cast<T><T>(x)`
* 'gsl:: narrow' / / 'narrow<T>(x) '- это ' static_cast<T><T>(x)', если 'static_cast<T > <T>(x) == x' или он выбрасывает ' narrowing_error`

##### Образец

 класс B { /* ... */ };
 класс D { /* ... */ };

 шаблон<typename D> D * upcast(B * pb)
 {
 D * pd0 = pb; / / ошибка: нет неявного преобразования из B* В D*
 D * pd1 = (D*)pb; / / законно, но что делается?
 D * pd2 = static_cast<D*>(pb); / / ошибка: D не является производным от B
 D * pd3 = reinterpret_cast<D*>(pb); / / OK: пусть это будет на вашей голове!
 D * pd4 = dynamic_cast<D*>(pb); / / OK: возврат nullptr
 // ...
 }

Пример был синтезирован из реальных ошибок, где `D "раньше производилось от "B", но кто-то изменил иерархию.
C-style cast опасен, потому что он может делать любые преобразования, лишая нас любой защиты от ошибок (сейчас или в будущем).

##### Записка

При преобразовании между типами без потери информации (например, от 'float' до
'double' или` int64 ' от 'int32'), инициализация скобки может использоваться вместо этого.

 double d {some_float};
 int64_t i {some_int32};

Это позволяет понять, что преобразование типа было предназначено, а также предотвращает
преобразования между типами, которые могут привести к потере точности. (Это a
ошибка компиляции, чтобы попытаться инициализировать 'float' из 'double' таким образом,
например.)

##### Записка

'reinterpret_cast' может быть существенным, но основные виды использования (например, превращение адреса машины в указатель) не являются типобезопасными:

 auto p = reinterpret_cast<Device_register>(0x800); / / по своей сути опасно


##### Принуждение

* Флаг C-стиль и функциональные слепки.
* Профиль [type] (#Pro-type-reinterpretcast) запрещает `reinterpret_cast`.
* Профиль [type] (#Pro-type-arithmeticcast) предупреждает при использовании "static_cast" между арифметическими типами.

### <a name= "Res-casts-const"></a>ES.50: не отбрасывайте `const`

##### Причина

Это делает ложь из 'const'.
Если переменная фактически объявлена `const`, изменение ее приводит к неопределенному поведению.

##### Пример, плохо

 void f(const int& x)
 {
 const_cast<int&>(x) = 42; / / плохо
 }

 статический int i = 0;
 статический const int j = 0;

 f (i); / / молчаливый побочный эффект
 f (j); / / неопределенное поведение

##### Образец

Иногда может возникнуть соблазн прибегнуть к `const_cast`, чтобы избежать дублирования кода, например, когда две функции доступа, различающиеся только в `const`-ness, имеют схожие реализации. Например:

 класс бар;

 класс Фу {
 Публично:
 // Плохо, дублирует логику
 Бар & get_bar() {
 / * сложная логика вокруг получения не-const ссылки на my_bar */
 }

 const Bar& get_bar_ () const {
 / * та же сложная логика вокруг получения ссылки const на my_bar */
 }
 Частное:
 Бар my_bar;
 };

Вместо этого предпочитайте совместно использовать реализации. Обычно, вы можете просто иметь функцию не - 'const', вызывающую функцию 'const'. Однако при наличии сложной логики это может привести к следующему шаблону, который все еще прибегает к ' const_cast`:

 класс Фу {
 Публично:
 // не очень большой, не-const вызывает версию const, но прибегает к const_cast
 Бар & get_bar() {
 возврат const_cast<Bar&>(static_cast<Bar&><const Foo&>(*this).get_bar());
 }
 const Bar& get_bar_ () const {
 /* сложная логика вокруг получения ссылки const на my_bar */
 }
 Частное:
 Бар my_bar;
 };

Хотя этот шаблон безопасен при правильном применении, потому что вызывающий объект должен был иметь не`const` объект для начала, это не идеально, потому что безопасность трудно применить автоматически в качестве правила проверки.

Вместо этого предпочтите поместить общий код в общую вспомогательную функцию-и сделать его шаблоном, чтобы он выводил "const". Это не использует никакой 'const_cast' вообще:

 класс Фу {
 общественное благо
 Bar& get_bar () { return get_bar_impl(*this); }
 const Bar& get_bar () const { return get_bar_impl(*this); }
 Частное:
 Бар my_bar;

 шаблон<класс T> / / хорошо, выводит ли T является const или не-const
 статический автоматический get_bar_impl (T& t) - > decltype (t. get_bar())
 {/*сложная логика вокруг получения возможной-const ссылки на my_bar */ }
 };

##### Исключение

Возможно, вам придется отбросить `const` при вызове `const`-неправильные функции.
Предпочтите обернуть такие функции во встроенную 'const' - правильную оболочку, чтобы инкапсулировать приведение в одном месте.

##### Образец

Иногда "отбросить ' const' - это позволить обновить некоторую временную информацию о другом неизменяемом объекте.
Примерами являются кэширование, запоминание и предварительное вычисление.
Такие примеры часто обрабатываются также или лучше с помощью "изменяемой" или косвенной передачи, чем с помощью "const_cast".

Рассмотрите возможность сохранения ранее вычисленных результатов для дорогостоящей операции:

 int compute(int x); / / вычислите значение для x; предположим, что это дорого

 Class Cache {//некоторый тип, реализующий кэш для операции int - >int
 Публично:
 pair<bool, int > find (int x) const; // существует ли значение для x?
 void set(int x, int v); / / сделать y значение для x
 // ...
 Частное:
 // ...
 };

 класс X {
 Публично:
 int get_val(int x)
 {
 auto p = кэш.Найти(x);
 если (p.first) возвратите p. second;
 int val = вычислить(x);
 Кэш.установить (x, val); / / вставить значение для x
 возвращение Валя;
 }
 // ...
 Частное:
 Кэш-кеш;
 };

Здесь 'get_val () `логически постоянен, поэтому мы хотели бы сделать его членом` const'.
Для этого нам все еще нужно мутировать 'cache', поэтому люди иногда прибегают к ' const_cast`:

 класс X {//подозрительное решение на основе литья
 Публично:
 int get_val (int x) const
 {
 auto p = кэш.Найти(x);
 если (p.first) возвратите p. second;
 int val = вычислить(x);
 const_cast<Cache&>(кэш).set(x, val); / / ugly
 возвращение Валя;
 }
 // ...
 Частное:
 Кэш-кеш;
 };

К счастью, есть лучшее решение:
Укажите, что` cache 'является изменяемым даже для объекта' const:

 класс X {//лучшее решение
 Публично:
 int get_val (int x) const
 {
 auto p = кэш.Найти(x);
 если (p.first) возвратите p. second;
 int val = вычислить(x);
 Кэш.set(x, val);
 возвращение Валя;
 }
 // ...
 Частное:
 изменяемый кэш-кеш;
 };

Альтернативным решением было бы хранить указатель на " кэш`:

 класс X {//OK, но немного более запутанное решение
 Публично:
 int get_val (int x) const
 {
 auto p = кэш - > Найти(x);
 если (p.first) возвратите p. second;
 int val = вычислить(x);
 кэш- > set(x, val);
 возвращение Валя;
 }
 // ...
 Частное:
 unique_ptr<кэш> кэш;
 };

Это решение является наиболее гибким, но требует явного построения и уничтожения "кэша".
(скорее всего, в конструкторе и деструкторе `X`).

В любом варианте мы должны остерегаться гонки данных на " кэш "в многопоточном коде, возможно, с использованием "std:: mutex".

##### Принуждение

* Флаг ' const_cast's.
* Это правило является частью профиля [type-safety profile] (#Pro-type-constcast) для соответствующего профиля.

### <a name= "Res-range-checking"></a>ES.55: избегайте необходимости проверки диапазона

##### Причина

Конструкции, которые не могут переполняться, не переполняются (и обычно выполняются быстрее):

##### Образец

 для (auto& x : v) // печать всех элементов v
 cout << x <;

 auto p = найти (v, x); // Найти x в v

##### Принуждение

Ищите явные проверки диапазона и эвристически предлагайте альтернативы.

### <a name= "Res-move"><a name="Res-move" ></a>ES.56: напишите 'std:: move ()' только тогда, когда вам нужно явно переместить объект в другую область

##### Причина

Мы перемещаемся, а не копируем, чтобы избежать дублирования и повысить производительность.

Движение обычно оставляет за собой пустой объект ([C. 64] (#Rc-move-semantic)), который может быть удивительным или даже опасным, поэтому мы стараемся избегать перемещения из lvalues (они могут быть доступны позже).

##### Примечания

Перемещение выполняется неявно, когда источником является значение rvalue (например, значение в обработке "return" или результат функции), поэтому не бессмысленно усложнять код в этих случаях, явно записывая "перемещение". Вместо этого напишите короткие функции, которые возвращают значения, и как возврат функции, так и принятие вызывающей стороной возврата будут оптимизированы естественным образом.

В целом, следуя рекомендациям в этом документе (в том числе не делая области видимости переменных неоправданно большими, записывая короткие функции, возвращающие значения, возвращающие локальные переменные) помогает устранить большую часть необходимости в явном "std::move".

Явное " перемещение "необходимо для явного перемещения объекта в другую область, в частности для передачи его в функцию" приемника " и в реализациях самих операций перемещения (конструктор перемещения, оператор назначения перемещения) и операций подкачки.

##### Пример, плохо

 пустая раковина (X&& x); / / раковина принимает владение x

 void пользователь()
 {
 X x;
 // ошибка: не удается привязать значение lvalue к ссылке rvalue
 раковина(x);
 // OK: раковина принимает содержимое x, теперь x должен считаться пустым
 раковина (std:: move (x));

 // ...

 // наверное, это ошибка
 использовать(x);
 }

Обычно аргумент` std::move () ` используется в качестве аргумента для параметра`&&'.
А после этого предположите, что объект был перемещен из (см. [C. 64] (#Rc-move-semantic)) и не считывайте его состояние снова, пока вы сначала не зададите ему новое значение.

 пустота f() {
 строка s1 = " supercalifragilisticexpialid замечательный";

 строка s2 = s1; / / ok, принимает копию
 assert(s1 = = "supercalifragilisticexpialidocious"); / / замечательный

 // плохо, если вы хотите продолжать использовать значение s1
 строка s3 = переместить(s1);

 // плохо, утверждение, скорее всего, потерпит неудачу, S1, вероятно, изменился
 assert(s1 = = " supercalifragilisticexpialidocio замечательный");
 }

##### Образец

 void sink (unique_ptr<widget> p); / / передайте право собственности p на раковину()

 пустота f() {
 auto w = make_unique<виджет>();
 // ...
 раковина (std:: move (w)); / / ok, дайте утонуть()
 // ...
 раковина (w); / / ошибка: unique_ptr тщательно разработан так, что вы не можете скопировать его
 }

##### Примечания

'std:: move () ` является приведением к ` & &' в маскировке; он сам ничего не перемещает, но отмечает именованный объект как кандидата, который может быть перемещен.
Язык уже знает общие случаи, когда объекты могут быть перемещены из, особенно при возврате значений из функций, поэтому не усложняйте код с избыточными `std::move()`s.

Никогда не пишите 'std:: move ()' только потому, что вы слышали "это более эффективно."
В общем, не верьте утверждениям об "эффективности" без данных (???).
В общем, не усложняйте свой код без причины (??).
Никогда не записывайте 'std:: move ()' на объекте const, он автоматически преобразуется в копию (см. пункт 23 в [Meyers15] (#Meyers15))

##### Пример, плохо

 вектор < int> make_vector() {
 вектор<int > результат;
 // ... загрузить результат с данными
 return std:: move (result); / / bad; просто напишите "return result;"
 }

Никогда не пишите ' return move (local_variable);`, потому что язык уже знает, что переменная является кандидатом на перемещение.
Написание ' move` в этом коде не поможет, и фактически может быть вредным, потому что на некоторых компиляторах он мешает RVO (оптимизации возвращаемого значения), создавая дополнительный ссылочный псевдоним к локальной переменной.


##### Пример, плохо

 вектор<int> v = std:: move(make_vector ()); / / плохо; std:: move полностью избыточен

Никогда не записывайте 'move' на возвращаемом значении, таком как` x = move(f ());`, где` f ' возвращает значение.
Язык уже знает, что возвращаемое значение является временным объектом, из которого можно перемещаться.

##### Образец

 движитель пустоты(X& & x) {
 call_something(std:: move (x)); / / ok
 call_something(std:: forward<X>(x)); / / плохо, не std:: forward ссылка rvalue
 call_something(x); / / подозрительно, почему бы не std::move?
 }

 шаблон<класс T>
 void forwarder(T&& t) {
 call_something(std:: move(t)); / / плохо, не std:: переместить ссылку переадресации
 call_something(std:: forward<T>(t)); / / ok
 call_something(t); / / подозрительно, почему бы не std::forward?
 }

##### Принуждение

* Использование флага ' std:: move(x)`, где `x` является rvalue, или язык уже будет рассматривать его как rvalue, включая `return std::move(local_variable);` и `std::move (f ())` на функции, которая возвращает значение.
* Флаговые функции, принимающие параметр ' S&&', если нет перегрузки ' const S&', чтобы заботиться о lvalues.
* Флаг a 'std::move аргумент передается параметру, за исключением тех случаев, когда тип параметра является ссылкой` X&&' rvalue или тип является только для перемещения и параметр передается по значению.
* Флаг, когда` std::move ' применяется к ссылке пересылки ('T&&', где ' T ' - тип параметра шаблона). Вместо этого используйте `std::forward`.
* Флаг, когда "std::move" применяется к другим, чем ссылка rvalue на non-const. (Более общий случай предыдущего правила для охвата случаев, не связанных с пересылкой.)
* Флаг, когда` std::forward 'применяется к ссылке rvalue (`X&&`, где` X' - конкретный тип). Вместо этого используйте `std::move`.
* Флаг, когда "std:: forward" применяется к другим, чем ссылка переадресации. (Более общий случай предыдущего правила для охвата непереходных случаев.)
* Флаг, когда объект потенциально перемещается из и следующая операция является операцией `const`; сначала должна быть промежуточная операция не`const`, в идеале назначение, чтобы сначала сбросить значение объекта.

### <a name= "Res-new"><a name="Res-new" ></a>ES.60: избегайте `новых " и "удалить" функции внешнего управления ресурсами

##### Причина

Прямое управление ресурсами в коде приложения подвержено ошибкам и утомительно.

##### Записка

Это также известно как правило "нет голых 'новых'!"

##### Пример, плохо

 void f(int n)
 {
 auto p = новый X[n]; / / n построенный по умолчанию Xs
 // ...
 исключить[] p;
 }

Там может быть код в `...'часть, которая заставляет "удалить" никогда не произойдет.

**Смотрите также**: [R: управление ресурсами](#s-resource)

##### Принуждение

Флаг голый 'новые и голые' удалить В.

### <a name= "Res-del"><a name="Res-del" ></a>ES.61: удалить массивы с помощью 'delete []' и не массивы с помощью`delete'

##### Причина

Именно это требует язык, и ошибки могут привести к ошибкам выпуска ресурсов и/или повреждению памяти.

##### Пример, плохо

 void f(int n)
 {
 auto p = новый X[n]; / / n построенный по умолчанию Xs
 // ...
 удалить p; / / ошибка: просто удалите объект p, а не удалить массив p[]
 }

##### Записка

Этот пример не только нарушает правило [no naked `new`] (#Res-new), как и в предыдущем примере, у него есть еще много проблем.

##### Принуждение

* Если "новый" и "удалить" находятся в одной области, ошибки могут быть помечены.
* Если "новый" и "удалить" находятся в паре конструктор/деструктор, ошибки могут быть помечены.

### <a name= "Res-arr2"><a name="Res-arr2" ></a>ES.62: не сравнивайте указатели в разных массивах

##### Причина

Результат этого не определен.

##### Пример, плохо

 пустота f()
 {
 int a1[7];
 int a2[9];
 если (&a1[5] 
 если (0 
 }

##### Записка

Этот пример имеет гораздо больше проблем.

##### Принуждение

???

### <a name= "Res-slice"><a name="Res-slice" ></a>ES.63: Не режьте

##### Причина

Нарезка-то есть копирование только части объекта с помощью назначения или инициализации-чаще всего приводит к ошибкам, потому что
объект должен был рассматриваться как единое целое.
В редких случаях, когда нарезка была преднамеренной, код может быть удивительным.

##### Образец

 форма класса { /* ... */ };
 круг класса: общественная форма { / * ... * / Точка c; int r; };

 Круг c {{0, 0}, 42};
 Форма s {c}; / / копировать построить только часть формы круга
 s = c; / / или копировать присвоить только фигуру части круга

 void assign(const Shape & src, Shape& dest) {
 dest = src;
 }
 Круг c2 {{1, 1}, 43};
 назначить(c, c2); / / oops, не все состояние передается
 assert(c == c2); // если мы поставляем копирование, мы также должны обеспечить сравнение,
 // но это, скорее всего, вернет false

Результат будет бессмысленным, потому что центр и радиус не будут скопированы из `c` в `s`.
Первая защита от этого заключается в том, чтобы [определить базовый класс 'Shape', чтобы не допустить этого] (#Rc-copy-virtual).

##### Альтернатива

Если вы хотите срезать, определите явную операцию для этого.
Это избавляет читателей от путаницы.
Например:

 класс смайлик: общественный круг {
 Публично:
 Круг copy_circle();
 // ...
 };

 Smiley sm { / * ... */ };
 Окружность c1 {sm}; / / идеально предотвращается определением окружности
 Круг c2 {sm.copy_circle()};

##### Принуждение

Предупреждать против нарезки.

### <a name= "Res-construct"><a name="Res-construct" ></a>ES.64: используйте обозначение 'T{e}' для построения

##### Причина

Синтаксис конструкции 'T{e}' делает его явным, что конструкция желательна.
Синтаксис конструкции 'T{e}' не позволяет сужаться.
`T{e} 'является единственным безопасным и общим выражением для построения значения типа 'T `из выражения`e'.
Литые обозначения "T (e)" и "T) e" не являются ни безопасными, ни общими.

##### Образец

Для встроенных типов, обозначение конструкции защищает против суживать и переинтерпретации

 пустое использование(char ch, int i, double d, char* p, long long lng)
 {
 int x1 = int{ch}; / / ОК, но избыточно
 int x2 = int{d}; / / ошибка: double - >int сужение; используйте приведение, если вам нужно
 int x3 = int{p}; / / ошибка: указатель на->int; используйте reinterpret_cast, если вам действительно нужно
 int x4 = int{lng}; / / ошибка: long long - >int сужение; используйте приведение, если вам нужно

 int y1 = int (ch); / / ОК, но избыточно
 int y2 = int (d); / / bad: double - >int сужение; используйте литье, если вам нужно
 int y3 = int (p); / / bad: указатель на->int; используйте reinterpret_cast, если вам действительно нужно
 int y4 = int (lng); / / bad: long long - >int сужение; используйте литье, если вам нужно

 int z1 = (int)ch; / / OK, но избыточно
 int z2 = (int)d; / / bad: double - >int сужение; используйте литье, если вам нужно
 int z3 = (int)p; / / bad: указатель на->int; используйте reinterpret_cast, если вам действительно нужно
 int z4 = (int)lng; / / bad: long long - >int сужение; используйте литье, если вам нужно
 }

Целочисленные преобразования указателя в/из определяются при использовании обозначений` T(e) `или` (T)e ' и непереносимых
между платформами с различными целочисленными и указательными размерами.

##### Записка

[Избегайте приведений] (#Res-приведения) (явное преобразование типов) и если вы должны [предпочесть именованные приведения] (#Res-приведения-именованные).

##### Записка

Когда он однозначен, то " T "можно исключить из" T{e}".

 complex<double > f (complex<double > <double>);

 auto z = f ({2*pi, 1});

##### Записка

Нотация конструкции является наиболее общей [нотация инициализатора] (#Res-list).

##### Исключение

'std:: vector' и другие контейнеры были определены до того, как мы получили `{}` в качестве обозначения для построения.
Считать:

 вектор<string > vs {10}; / / десять пустых строк
 вектор < int> vi1 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // десять элементов 1..10
 вектор < int> vi2 {10}; / / один элемент со значением 10

Как мы получаем "вектор" из 10 инициализированных по умолчанию 'int'?

 вектор<int> v3(10); / / десять элементов со значением 0

Использование ` () 'вместо' {} ' Для количества элементов является обычным (начиная с начала 1980-х годов), трудно изменить, но все же
ошибка проектирования: для контейнера, в котором тип элемента может быть перепутан с числом элементов, у нас есть неопределенность, что
должен решаться.
Обычное разрешение состоит в том, чтобы интерпретировать "{10} "как список одного элемента и использовать" (10) " для различения размера.

Эту ошибку не нужно повторять в новом коде.
Мы можем определить тип для представления количества элементов:

 struct Count { int n; };

 шаблон<typename T>
 вектор класса {
 Публично:
 Вектор (количество n); / / n по умолчанию-инициализированные элементы
 Вектор (initializer_list<T> init); / / init.размер () элементов
 // ...
 };

 Вектор<int > v1{10};
 Вектор<int > v2{Count{10}};
 Вектор<Count > v3{Count{10}}; / / да, есть еще очень незначительная проблема

Основная оставшаяся проблема-найти подходящее название для 'Count'.

##### Принуждение

Установите флажки C-style `(T)e` и functional-style `T(e)`.


### <a name= "Res-deref"><a name="Res-deref" ></a>ES.65: не разыменовывайте недопустимый указатель

##### Причина

Разыменование недопустимого указателя, такого как "nullptr", является неопределенным поведением, обычно приводящим к немедленным сбоям,
неправильные результаты или повреждение памяти.

##### Записка

Это правило является очевидным и хорошо известным языковым правилом, но может быть трудно следовать.
Это требует хорошего стиля кодирования, поддержки библиотек и статического анализа, чтобы устранить нарушения без серьезных накладных расходов.
Это основная часть обсуждения модели [C++для безопасности типов и ресурсов](#Stroustrup15).

**Смотреть также**:

* Используйте [RAII] (#Rr-raii), чтобы избежать пожизненных проблем.
* Используйте [unique_ptr] (#Rf-unique_ptr), чтобы избежать пожизненных проблем.
* Используйте [shared_ptr] (#Rf-shared_ptr), чтобы избежать пожизненных проблем.
* Используйте [ссылки] (#Rf-ptr-ref), когда `nullptr` не является возможным.
* Используйте [not_null] (#Rf-not_null), чтобы поймать неожиданный `nullptr` рано.
* Используйте профиль [bounds](#SS-bounds), чтобы избежать ошибок диапазона.


##### Образец

 пустота f()
 {
 int x = 0;
 int* p = &x;

 если (условие()) {
 int y = 0;
 p = &y;
 } / / делает недействительным p

 *p = 42; / / плохо, p может быть недействительным, если ветка была взята
 }

Чтобы решить эту проблему, либо продлите срок службы объекта, на который должен ссылаться указатель, либо сократите срок службы указателя (переместите разыменование до окончания срока службы объекта, на который указывает указатель).

 пустота f1()
 {
 int x = 0;
 int* p = &x;

 int y = 0;
 если (условие()) {
 p = &y;
 }

 *p = 42; / / OK, P указывает на x или y, и оба они все еще находятся в области видимости
 }

К сожалению, большинство проблем с недопустимым указателем труднее обнаружить и труднее исправить.

##### Образец

 void f(int* p)
 {
 int x = *p; / / BAD: откуда мы знаем, что p допустимо?
 }

Существует огромное количество такого кода.
Большинство работ - после большого количества испытаний - но в изоляции невозможно сказать, Может ли " p "быть " nullptr".
Следовательно, это также является главным источником ошибок.
Существует множество подходов к решению этой потенциальной проблемы:

 void f1(int* p) / / deal with nullptr
 {
 если (!п) {
 // deal with nullptr (выделять, возвращать, бросать, заставлять p указывать на что - то, что угодно
 }
 int x = * p;
 }

Существует две потенциальные проблемы с тестированием для `nullptr`:

* не всегда очевидно, что делать, если мы найдем `nullptr`
* тест может быть избыточным и / или относительно дорогим
* не очевидно, является ли тест защитой от нарушения или частью требуемой логики.

<!-- комментарий, необходимый для блока кода после списка -->
 void f2 (int* p) // заявить, что p не должен быть nullptr
 {
 assert(p);
 int x = * p;
 }

Это будет стоить только тогда, когда проверка утверждений была включена, и даст компилятору/анализатору полезную информацию.
Это будет работать еще лучше, если / когда C++ получает прямую поддержку для контрактов:

 void f3 (int* p) // заявить, что p не должен быть nullptr
 [[ожидает: p]]
 {
 int x = * p;
 }

Кроме того, мы могли бы использовать `gsl::not_null`, чтобы гарантировать, что `p` не является `nullptr`.

 void f(not_null<int*> p)
 {
 int x = * p;
 }

Эти средства защиты заботятся только о "nullptr".
Помните, что есть и другие способы получения недопустимого указателя.

##### Образец

 void f (int* p) / / старый код, не использует владельца
 {
 удалить p;
 }

 void g () / / старый код: использует голый новый
 {
 auto q = new int{7};
 f(q);
 int x = * q; / / BAD: разыменование недопустимого указателя
 }

##### Образец

 пустота f()
 {
 вектор<int > v(10);
 int* p = &v[5];
 v. push_back(99); / / может перераспределить элементы v
 int x = *p; / / BAD: разыменование потенциально недопустимого указателя
 }

##### Принуждение

Это правило является частью профиля безопасности [lifetime safety profile] (#SS-lifetime)

* Отметьте разыменование указателя, указывающего на объект, который вышел за пределы области видимости
* Пометить разыменование указателя, которое может быть признано недействительным путем присвоения `nullptr`
* Пометить разыменование указателя, которое может быть признано недействительным с помощью ' delete`
* Помечает разыменование указателя на элемент контейнера, который может быть признан недействительным при разыменовании


## ES.stmt: заявления

Операторы управляют потоком управления (за исключением вызовов функций и бросков исключений, которые являются выражениями).

### <a name= "Res-switch-if"><a name="Res-switch-if" ></a>ES.70: предпочтите 'switch' - оператор к`if ' -оператор, когда есть выбор

##### Причина

* Удобочитаемость.
* Эффективность: "переключатель" сравнивается с константами и обычно лучше оптимизируется, чем серия тестов в цепочке "если" - "тогда" - "еще".
* "Переключатель" включает некоторую эвристическую проверку согласованности. Например, были ли покрыты все значения "перечисления"? Если нет, есть ли "дефолт"?

##### Образец

 пустое использование(int n)
 {
 switch (n) {//хорошо
 дело 0:
 // ...
 ломать;
 дело 7:
 // ...
 ломать;
 По умолчанию:
 // ...
 ломать;
 }
 }

вместо того чтобы:

 void use2(int n)
 {
 if (n == 0) / / bad: сравнение цепи if-then-else с набором констант
 // ...
 иначе если (n = = 7)
 // ...
 }

##### Принуждение

Флаг " if " - "then" - "else" цепочки, которые проверяют по константам (только).

### <a name= "Res-for-range"><a name="Res-for-range" ></a>ES.71: предпочитайте диапазон-`для '- утверждение к`для ' -утверждение, когда есть выбор

##### Причина

Удобочитаемость. Предотвращение ошибок. Эффективность.

##### Образец

 для (gsl:: индекс i = 0; i 
 cout << v[i] <;

 для (auto p = v. begin (); p != v. end (); ++p) / / плохо
 cout << *p <;

 для (auto& x : v) / / OK
 cout << x <;

 для (gsl:: индекс i = 1; i 
 cout << v[i] + v[i-1] <;

 для (gsl:: индекс i = 0; i 
 cout << f(v, &v[i]) <;

 для (gsl:: индекс i = 0; i 
 если (i % 2 = = 0)
 продолжить; / / пропустить даже элементы
 еще
 cout << v[i] <;
 }

Человек или хороший статический анализатор может определить, что действительно нет побочного эффекта на `v " в " f(v, &v[i])", так что цикл можно переписать.

"Возиться с переменной цикла" в теле цикла, как правило, лучше избегать.

##### Записка

Не используйте дорогостоящие копии переменной цикла диапазона - ` для ' цикла:

 для (строка s: vs)//...

Это скопирует все элементы 'vs `в`s'. Лучше:

 для (string& s: vs)//...

Еще лучше, если переменная цикла не будет изменена или скопирована:

 for (const string& s: vs)//...

##### Принуждение

Посмотрите на циклы, если традиционный цикл просто смотрит на каждый элемент последовательности, и нет никаких побочных эффектов на то, что он делает с элементами, перепишите цикл в цикл ranged-`for`.

### <a name= "Res-for-while"><a name="Res-for-while"></a>ES.72: предпочтите оператор " for "оператору " while", когда существует очевидная переменная цикла

##### Причина

Удобочитаемость: полная логика цикла видна "спереди". Область действия переменной цикла может быть ограничена.

##### Образец

 для (gsl:: индекс i = 0; i size (); i++) {
 // делать работу
 }

##### Пример, плохо

 int i = 0;
 в то время как (я размер()) {
 // делать работу
 я++;
 }

##### Принуждение

???

### <a name= "Res-while-for"><a name="Res-while-for" ></a>ES.73: предпочитайте оператор "while" оператору "for", когда нет очевидной переменной цикла

##### Причина

Удобочитаемость.

##### Образец

 int events = 0;
 for (; wait_for_event (); ++events) {//bad, confusing
 // ...
 }

"Цикл событий" вводит в заблуждение, потому что счетчик "события" не имеет никакого отношения к условию цикла (`wait_for_event ()`).
Лучше

 int events = 0;
 while (wait_for_event ()) {//better
 ++события;
 // ...
 }

##### Принуждение

Отмечайте действия в`for '-инициализаторах и`for '-инкрементах, которые не относятся к условию`for'.

### <a name= "Res-for-init"><a name="Res-for-init"></a>ES.74: предпочитайте объявлять переменную цикла в инициализаторе части оператора`for ' -statement

##### Причина

Ограничьте видимость переменной цикла областью действия цикла.
Избегайте использования переменной цикла для других целей после цикла.

##### Образец

 для (int i = 0; i 
 // ...
 }

##### Например, не надо

 int j; / / BAD: j виден вне петли
 для (j = 0; j ) {
 // ...
 }
 // j по-прежнему виден здесь и не требуется

**Смотрите также**: [не используйте переменную для двух несвязанных целей] (#Res-recycle)

##### Образец

 для (строка s; cin >>> s; ) {
 cout << s <;
 }

##### Принуждение

Предупреждать, когда переменная, измененная внутри оператора`for ' -statement, объявляется вне цикла и не используется вне цикла.

** Обсуждение**: определение области видимости переменной цикла для тела цикла также значительно помогает оптимизаторам кода. Признавая, что индукционная переменная
доступно только в теле петли разблокирует оптимизирования как поднимать, уменьшение прочности, петл-инвариантное движение кода, etc.

### <a name= "Res-do"><a name="Res-do" ></a>ES.75: избегайте "делать" -заявления

##### Причина

Читабельность, избегание ошибок.
Условие завершения находится в конце (где оно может быть пропущено), и условие не проверяется в первый раз.

##### Образец

 int x;
 делать {
 cin > > > x;
 // ...
 } в то время как (x );

##### Записка

Да, есть подлинные примеры, когда " do " -оператор является четким утверждением решения, но также и много ошибок.

##### Принуждение

Флаг ' do ' - заявления.

### <a name= "Res-goto"><a name="Res-goto" ></a>ES.76: избегайте `Гото`

##### Причина

Читабельность, избегание ошибок. Есть лучшие структуры управления для людей; "Гото" - это для машинного кода.

##### Исключение

Выход из вложенного цикла.
В этом случае всегда прыгайте вперед.

 для (int i = 0; i )
 для (int j = 0; j ) {
 если (a[i][j] > elem_max) готово;
 // ...
 }
 ЗАКОНЧЕННЫЕ:
 // ...

##### Пример, плохо

Существует изрядное количество использования идиомы c goto-exit:

 пустота f()
 {
 // ...
 Гото выход;
 // ...
 Гото выход;
 // ...
 выход:
 // ... общий код очистки ...
 }

Это специальная симуляция деструкторов.
Объявите свои ресурсы с дескрипторами с деструкторами, которые очищают.
Если по какой-то причине вы не можете обрабатывать все очистки с деструкторами для используемых переменных,
рассматривайте `gsl:: finally () ' как более чистую и надежную альтернативу `goto exit`

##### Принуждение

* Флаг 'goto'. Еще лучше отмечать все ' goto'ы, которые не переходят из вложенного цикла В оператор сразу после гнезда циклов.

### <a name= "Res-continue"><a name="Res-continue" ></a>ES.77: сведите к минимуму использование 'break' и 'continue' в циклах

##### Причина

 В нетривиальном теле цикла легко пропустить "перерыв" или "продолжение".

 "Перерыв" в цикле имеет резко отличающееся значение, чем "перерыв" в "переключении" -заявлении
 (и вы можете иметь`switch '-заявление в петле и петлю в`switch ' -случае).

##### Образец

 переключатель(x){
 дело 1 :
 в то время как (/*некоторые условия */){
 //...
 ломать;
 } / /Ой! выключатель перерыва или перерыв пока предназначенный?
 дело 2 :
 //...
 ломать;
 }

##### Альтернатива

Часто цикл, требующий "разрыва", является хорошим кандидатом на функцию (алгоритм), и в этом случае "разрыв" становится "возвращением".

 // Первоначальный код: пролом внутри петли
 пустое использование1(){
 std:: vector<T> vec = {/*initialized with some values */};
 Значение T;
 для (пункт const T: vec){
 если (/*некоторые условия*/){
 value = товар;
 ломать;
 }
 }
 / * затем сделайте что-то с ценностью */
 }
 
 //BETTER: создание функции и возврат внутри цикла
 T search(const std:: vector<T> &vec){
 для (const T & item : vec){
 если (/*какое-то условие*/) вернуть товар;
 }
 возврат T (); / / значение по умолчанию
 }
 
 void use2(){
 std:: vector<T> vec = {/*initialized with some values */};
 Значение T = поиск(vec);
 / * затем сделайте что-то с ценностью */
 }

Часто цикл, который использует "continue", может эквивалентно и так же ясно выражаться с помощью оператора "if".

 for (int item: vec) {//BAD
 если (пункт%2 == 0) ПРОДОЛЖИТЬ;
 если (пункт == 5) продолжить;
 если (пункт > 10) продолжить;
 / * сделайте что-нибудь с предметом */
 }
 
 for (int item: vec) {//GOOD
 если(пункт%2 != 0 & & пункт != 5 && пункт ){
 / * сделайте что-нибудь с предметом */
 }
 }

##### Записка

Если вам действительно нужно разорвать цикл, то 'break' обычно лучше, чем такие альтернативы, как [изменение переменной цикла] (#Res-loop-counter) или ['goto'] (#Res-goto):


##### Принуждение

???

### <a name= "Res-break"><a name="Res-break" ></a>ES.78: не полагайтесь на неявное прохождение в операторах switch

##### Причина

Всегда заканчивайте непустой "случай" с "перерывом". Случайно упуская "перерыв" является довольно распространенной ошибкой.
Преднамеренное выпадение может представлять опасность для обслуживания и должно быть редким и явным.

##### Образец

 переключатель (тип события) {
 информация по делу:
 update_status_bar();
 ломать;
 предупреждение случая:
 write_event_log();
 // Bad-неявное прохождение
 ошибка случая:
 display_error_window();
 ломать;
 }

Несколько меток case одного оператора-это нормально:

 переключатель (x) {
 дело "а":
 дело "б":
 дело "f":
 do_something(x);
 ломать;
 }

Инструкции Return в метке case также в порядке:
 переключатель (x) {
 дело "а":
 возвращение 1;
 дело "б":
 возвращение 2;
 дело "с":
 возвращение 3;
 }

##### Исключения

В редких случаях, если fallthrough считается подходящим, будьте явными и используйте аннотацию " [[fallthrough]]:

 переключатель (тип события) {
 информация по делу:
 update_status_bar();
 ломать;
 предупреждение случая:
 write_event_log();
 [[fallthrough]];
 ошибка случая:
 display_error_window();
 ломать;
 }

##### Записка

##### Принуждение

Флаг все неявные fallthroughs из непустых 'case'.


### <a name= "Res-default"><a name="Res-default" ></a>ES.79: используйте `default` для обработки общих случаев (только)

##### Причина

 Ясность кода.
 Улучшены возможности для обнаружения ошибок.

##### Образец

 перечисление E { a, b, c, d };

 пустота f1(E x)
 {
 переключатель (x) {
 дело а:
 сделать нечто();
 ломать;
 дело b:
 do_something_else();
 ломать;
 По умолчанию:
 take_the_default_action();
 ломать;
 }
 }

Здесь ясно, что есть действие по умолчанию и что случаи " a " и " b " являются особыми.

##### Образец

Но что делать, если нет никакого действия по умолчанию, и Вы имеете в виду, чтобы обрабатывать только конкретные случаи?
В этом случае имейте пустое значение по умолчанию, иначе невозможно узнать, намеревались ли вы обрабатывать все случаи:

 пустота f2(E x)
 {
 переключатель (x) {
 дело а:
 сделать нечто();
 ломать;
 дело b:
 do_something_else();
 ломать;
 По умолчанию:
 // ничего не делайте для остальных случаев
 ломать;
 }
 }

Если вы оставите `по умолчанию`, сопровождающий и / или компилятор может разумно предположить, что вы намеревались обрабатывать все случаи:

 пустота f2(E x)
 {
 переключатель (x) {
 дело а:
 сделать нечто();
 ломать;
 дело b:
 дело c:
 do_something_else();
 ломать;
 }
 }

Может быть, вы забыли случай "d"или намеренно оставили его?
Забывание случая обычно происходит, когда случай добавляется к перечислению, и человек, делая это, не может добавить его к каждому
переключитесь на перечислители.

##### Принуждение

Флаг 'switch' - операторы над перечислением, которые не обрабатывают все перечислители и не имеют `default`.
Это может привести к слишком большому количеству ложных срабатываний в некоторых кодовых базах; если это так, флаг только ' switch'es, которые обрабатывают большинство, но не все случаи
(это была стратегия самого первого компилятора C++).

### <a name= "Res-noname"><a name="Res-noneame" ></a>ES.84: Не пытайтесь объявить локальную переменную без имени

##### Причина

Такого просто не существует.
То, что для человека выглядит как переменная без имени, для компилятора является операцией, состоящей из временного оператора, который немедленно выходит за пределы области видимости.

##### Пример, плохо

 пустота f()
 {
 блокировка<мьютекс > {mx}; / / плохо
 // ...
 }

Это объявляет безымянный объект` lock', который немедленно выходит из области действия в точке с запятой.
Это не такая уж редкая ошибка.
В частности, этот конкретный пример может привести к труднодоступным расовым условиям.

##### Записка

Безымянные аргументы функции хороши.

##### Принуждение

Операторы флага, которые являются только временными.

### <a name= "Res-пустой"><a name="Res-пустой" ></a>ES.85: сделайте пустые операторы видимыми

##### Причина

Удобочитаемость.

##### Образец

 ибо (i = 0; i 
 v[i] = f (v[i]);

 для (auto x : v) {//лучше
 // ничего
 }
 v[i] = f (v[i]);

##### Принуждение

Флаг пустые операторы, которые не являются блоками и не содержат комментариев.

### <a name= "Res-loop-counter"></a>ES.86: избегайте изменения переменных управления циклом внутри тела необработанных for-loops

##### Причина

Управление циклом спереди должно позволить правильно рассуждать о том, что происходит внутри цикла. Изменение счетчиков циклов как в итерационном выражении, так и внутри тела цикла является постоянным источником сюрпризов и ошибок.

##### Образец

 для (int i = 0; i ) {
 // нет обновлений для i -- ok
 }

 для (int i = 0; i ) {
 //
 если (/*что-то */) ++i; / / плохо
 //
 }

 bool skip = false;
 для (int i = 0; i ) {
 if (skip) { пропустить = false; продолжить; }
 //
 if (/*something */) skip = true; / / Better: использование двух переменных для двух понятий.
 //
 }

##### Принуждение

Переменные флага, которые потенциально обновляются (имеют не-`const` использование) как в итерации-выражении управления циклом, так и в теле цикла.


### <a name= "Res-if"><a name="Res-if" ></a>ES.87: не добавляйте избыточные ` = = 'или'!=` обусловить

##### Причина

Это позволяет избежать многословия и исключает некоторые возможности для ошибок.
Помогает сделать стиль последовательным и обычным.

##### Образец

По определению, условие в " if "-утверждении, "while" -утверждении или " for "-утверждении выбирает между "true" и "false".
Числовое значение сравнивается с `0`, а значение указателя-с`nullptr'.

 // Все это означает "если `p' не является ' nullptr`"
 если (p) {... } // хороший
 если (p != 0) { ... } / / избыточно `!=0`; плохо: не используйте 0 для указателей
 если (p != nullptr) { ... } / / избыточно `!=nullptr`, не рекомендуется

Часто `if (p) 'читается как" if` p 'is valid", что является прямым выражением намерения программистов,
тогда как `если (p != nullptr) ' было бы многословным обходным путем.

##### Образец

Это правило особенно полезно, когда объявление используется в качестве условия

 if(auto pc = dynamic_cast<Circle>(ps)) { ... } / / выполнить, если ps указывает на своего рода круг, хорошо

 если (auto pc = dynamic_cast<Circle>(ps); pc != nullptr) { ... } / / не рекомендуется

##### Образец

Обратите внимание, что неявные преобразования в bool применяются в условиях.
Например:

 для (строка s; cin >>> s;) v. push_back(s);

Это вызывает `istream ' s ' оператор bool()`.

##### Записка

Явное сравнение целого числа с `0 ' в общем случае не является избыточным.
Причина заключается в том, что (в отличие от указателей и булевых значений) целое число часто имеет более двух разумных значений.
Кроме того, " 0 " (ноль) часто используется для обозначения успеха.
Следовательно, лучше всего быть конкретным о сравнении.

 пустота f(int i)
 {
 если (i) // подозреваемый
 // ...
 если (i == успех) / / возможно лучше
 // ...
 }

Всегда помните, что целое число может иметь более двух значений.

##### Пример, плохо

Было отмечено, что

 if (strcmp (p1, p2)) { ... } / / являются ли две строки C-стиля равными? (ошибка!)

это распространенная ошибка начинающих.
Если вы используете строки в стиле C, вы должны хорошо знать функции `<cstring>'.
Быть многословным и писать

 если (strcmp (p1, p2)!= 0) { ... } / / являются ли две строки C-стиля равными? (ошибка!)

сам по себе он тебя не спасет.

##### Записка

Противоположное условие наиболее легко выражается с помощью отрицания:

 // Все они означают "если `p' - это ' nullptr`"
 если (!p) { ... } // хороший
 если (p = = 0) {... } / / redundant '= = 0'; bad: не используйте `0 ' для указателей
 если (p = = nullptr) {... } / / redundant '= = nullptr', не рекомендуется

##### Принуждение

Легко, просто проверьте для избыточного использования `!= 'и' = = ' в условиях.



## <a name= "SS-numbers" ><a name="SS-numbers" ></a>арифметика

### <a name= "Res-mix"><a name="Res-mix" ></a>ES.100: не смешивайте арифметику со знаком и без знака

##### Причина

Избегайте неверных результатов.

##### Образец

 int x = -3;
 unsigned int y = 7;

 cout << x-y <
 cout < < x + y <
 cout << x * y <

На более реалистичных примерах эту проблему обнаружить сложнее.

##### Записка

К сожалению, C++ использует целые числа со знаком для индексов массива, а стандартная библиотека использует целые числа без знака для индексов контейнера.
Это исключает последовательность. Используйте` gsl::index ' для нижних индексов; [см. ES.107] (#Res-индексы).

##### Принуждение

* Компиляторы уже знают и иногда предупреждают.
* (Чтобы избежать шума) не отмечайте смешанное сравнение со знаком/без знака, где одним из аргументов является "sizeof" или вызов контейнера.size () 'и другой - это 'ptrdiff_t'.


### <a name= "Res-unsigned"><a name="Res-unsigned" ></a>ES.101: используйте неподписанные типы для битовой манипуляции

##### Причина

Неподписанные типы поддерживают битовую манипуляцию без сюрпризов от знаковых битов.

##### Образец

 неподписанный символ x = 0b1010 ' 1010;
 неподписанный символ y = ~x; / / y = = 0b0101'0101;

##### Записка

Беззнаковые типы также могут быть полезны для арифметики по модулю.
Однако, если вы хотите по модулю арифметики добавить
комментирует По мере необходимости отмечая зависимость от wraparound поведения, как такового кода
может быть удивительным для многих программистов.

##### Принуждение

* Практически невозможно в целом из-за использования неподписанных индексов в стандартной библиотеке
* ???

### <a name= "Res-signed"><a name="Res-signed" ></a>ES.102: используйте знаковые типы для арифметики

##### Причина

Потому что большая часть арифметики предполагается подписанной;
`x-y 'дает отрицательное число, когда' y > x ' за исключением редких случаев, когда вы действительно хотите арифметику по модулю.

##### Образец

Беззнаковая арифметика может дать удивительные результаты, если вы ее не ожидаете.
Это еще более верно для смешанной арифметики со знаком и без знака.

 шаблон<typename T, typename T2>
 T вычитание(T x, T2 y)
 {
 возврат x-y;
 }

 испытание на пустоту()
 {
 int s = 5;
 unsigned int us = 5;
 cout < < вычесть(s, 7) <
 cout < < вычесть(us, 7u) <
 cout < < вычесть(s, 7u) <
 cout < < subtract(us, 7) <
 cout < < вычесть(s, us + 2) <
 cout < < вычесть(us, s + 2) <
 }

Здесь мы были очень откровенны о том, что происходит,
но если бы вы видели ' us - (s + 2)` или `s += 2; ...; us-s', Вы бы достоверно подозревали, что результат будет напечатан как "4294967294"?

##### Исключение

Используйте беззнаковые типы, если вы действительно хотите арифметику по модулю-добавить
комментарии по мере необходимости отмечая зависимость от поведения переполнения, как такой код
это будет удивительно для многих программистов.

##### Образец

Стандартная библиотека использует для индексов беззнаковые типы.
Встроенный массив использует подписанные типы для индексов.
Это делает сюрпризы (и ошибки) неизбежными.

 int a[10];
 для (int i = 0; i ;
 вектор<int > v(10);
 // сравнивает подписанное с неподписанным; некоторые компиляторы предупреждают, но мы не должны
 для (gsl:: индекс i = 0; i ;

 int a2[-2]; / / ошибка: отрицательный размер

 // Хорошо, но число ints (4294967294) настолько велико, что мы должны получить исключение
 вектор<int> v2(-2);

 Используйте` gsl::index ' для нижних индексов; [см. ES.107] (#Res-индексы).

##### Принуждение

* Флаг смешанная арифметика со знаком и без знака
* Помечать результаты беззнаковой арифметики, присвоенные или напечатанные как подписанные.
* Помечайте отрицательные литералы (например, `-2`), используемые в качестве индексов контейнера.
* (Чтобы избежать шума) не отмечайте смешанное сравнение со знаком/без знака, где одним из аргументов является "sizeof" или вызов контейнера.size () 'и другой - это 'ptrdiff_t'.


### <a name= "Res-overflow"><a name="Res-overflow" ></a>ES.103: Не переполняйте

##### Причина

Переполнение обычно делает ваш числовой алгоритм бессмысленным.
Увеличение значения сверх максимального значения может привести к повреждению памяти и неопределенному поведению.

##### Пример, плохо

 int a[10];
 a[10] = 7; / / плохо

 int n = 0;
 while (n++ )
 a[n-1] = 9; / / плохо (дважды)

##### Пример, плохо

 int n = numeric_limits<int>:: max();
 int m = n + 1; / / плохо

##### Пример, плохо

 int area (int h, int w) { return h * w; }

 auto a = площадь(10'000'000, 100'000'000); // плохо

##### Исключение

Используйте беззнаковые типы, если вам действительно нужна арифметика по модулю.

** Альтернатива**: для критических приложений, которые могут позволить себе некоторые накладные расходы, используйте целочисленный и/или тип с плавающей запятой, проверяемый диапазоном.

##### Принуждение

???

### <a name= "Res-underflow"></a>ES.104: не underflow

##### Причина

Уменьшение значения сверх минимального значения может привести к повреждению памяти и неопределенному поведению.

##### Пример, плохо

 int a[10];
 a[-2] = 7; / / плохо

 int n = 101;
 в то время как (n--)
 a[n-1] = 9; / / плохо (дважды)

##### Исключение

Используйте беззнаковые типы, если вам действительно нужна арифметика по модулю.

##### Принуждение

???

### <a name= "Res-zero"><a name="Res-zero" ></a>ES.105: не делите на ноль

##### Причина

Результат не определен и, вероятно, сбой.

##### Записка

Это также относится и к"%".

##### Пример, плохо

 двойное деление(int a, int b) {
 // Плохо, должно быть проверено (например, в предварительном условии)
 возврат a / b;
 }

##### Пример, хорошо

 двойное деление(int a, int b) {
 // хорошо, обратитесь через предварительное условие (и замените контрактами, как только C++ получит их)
 Ожидает(б != 0);
 возврат a / b;
 }

 двойное деление(int a, int b) {
 // хорошо, адрес через проверку
 возвращение б ? a / b: quiet_NaN<double>();
 }

** Альтернатива**: для критических приложений, которые могут позволить себе некоторые накладные расходы, используйте целочисленный и/или тип с плавающей запятой, проверяемый диапазоном.

##### Принуждение

* Деление флага на целочисленное значение, которое может быть равно нулю


### <a name= "Res-nonnegative"><a name="Res-nonnegative" ></a>ES.106: не пытайтесь избежать отрицательных значений, используя `unsigned`

##### Причина

Выбор 'unsigned' подразумевает множество изменений в обычном поведении целых чисел, включая арифметику по модулю,
может подавлять предупреждения, связанные с переполнением,
и открывает дверь для ошибок, связанных с подписанными / неподписанными миксами.
Использование `unsigned ' фактически не устраняет возможность отрицательных значений.

##### Образец

 unsigned int u1 = -2; / / Valid: значение u1 равно 4294967294
 int i1 = -2;
 unsigned int u2 = i1; / / Valid: значение u2 равно 4294967294
 int i2 = u2; / / допустимо: значение i2 равно -2

Эти проблемы с такими (совершенно законными) конструкциями трудно обнаружить в реальном коде и являются источником многих реальных ошибок.
Считать:

 unsigned area (unsigned height, unsigned width) { return height * width;} / / [Смотрите также] (#Ri-ожидает)
 // ...
 int высота;
 cin > > > высота;
 auto a = площадь (высота, 2); // если входной сигнал равен -2 a, то получается 4294967292

Помните, что `-1` при назначении `unsigned int` становится самым большим `unsigned int`.
Кроме того, поскольку беззнаковая арифметика является арифметикой по модулю, умножение не переполнялось, оно обернулось вокруг.

##### Образец

 unsigned max = 100000; / / "случайная опечатка", я имею в виду 10 ' 000
 беззнаковое короткое x = 100;
 в то время как (x 

Если бы `x 'было подписано 'short', мы могли бы предупредить о неопределенном поведении при переполнении.

##### Альтернативы

* используйте целые числа со знаком и проверьте `x >= 0`
* используйте положительный целочисленный тип
* используйте целочисленный тип поддиапазона
* 'Assert(-1 

Например

 структура положительная {
 int val;
 Positive(int x): val{x} { Assert(0 ); }
 оператор int () { return val; }
 };

 int f (Positive arg) { return arg; }

 int r1 = f(2);
 int r2 = f (-2); // броски

##### Записка

???

##### Принуждение

Смотрите ES.100 силовиков.


### <a name= "Res-subscripts"><a name="Res-subscripts" ></a>ES.107: Не используйте `unsigned ' для индексов, предпочитайте `gsl:: index`

##### Причина

Чтобы избежать путаницы со знаком / без знака.
Чтобы включить лучшую оптимизацию.
Чтобы включить лучшее обнаружение ошибок.
Чтобы избежать подводных камней с `auto " и "int".

##### Пример, плохо

 вектор<int> vec =/*...*/;

 для (int i = 0; i размер (); i += 2) / / может быть недостаточно большим
 cout < < vec[i] <;
 для (Без знака i = 0; i размер (); i += 2) / / обертка риска
 cout < < vec[i] <;
 для (auto i = 0; i размер (); i += 2) / / может быть недостаточно большим
 cout < < vec[i] <;
 for (vector<int>:: size_type i = 0; i <int>size (); i += 2) / / verbose
 cout < < vec[i] <;
 для (auto i = vec.size () -1; i >= 0; i - = 2) / / ошибка
 cout < < vec[i] <;
 для (int i = vec.size () -1; i >= 0; i - = 2) / / может быть недостаточно большим
 cout < < vec[i] <;

##### Пример, хорошо

 вектор<int> vec =/*...*/;

 для (gsl:: индекс i = 0; i размер (); i += 2) / / ok
 cout < < vec[i] <;
 для (gsl:: индекс i = vec.size () -1; i >= 0; i - = 2) / / ok
 cout < < vec[i] <;

##### Записка

Встроенный массив использует подписанные индексы.
Контейнеры стандартной библиотеки используют неподписанные нижние индексы.
Таким образом, никакое идеальное и полностью совместимое решение не возможно (если и до тех пор, пока контейнеры стандартной библиотеки не изменятся, чтобы использовать подписанные подстрочные индексы когда-нибудь в будущем).
Учитывая известные проблемы с беззнаковыми и знаковыми/беззнаковыми смесями, лучше придерживаться (знаковых) целых чисел достаточного размера, что гарантируется "GSL::index".

##### Образец

 шаблон<typename T>
 struct My_container {
 Публично:
 // ...
 Оператор T& [] (gsl:: index i); / / не без знака
 // ...
 };

##### Образец

 ??? продемонстрировать улучшенную генерацию кода и потенциал для обнаружения ошибок ???

##### Альтернативы

Альтернативы для пользователей

* используемый алгоритм
* используйте ряд-для
* использовать итераторы / указатели

##### Принуждение

* Очень сложно, пока контейнеры стандартной библиотеки получают его неправильно.
* (Чтобы избежать шума) не отмечайте смешанное сравнение со знаком/без знака, где одним из аргументов является "sizeof" или вызов контейнера.size () 'и другой - это 'ptrdiff_t'.




# <a name= "S-performance"><a name="S-performance" ></a>Per: Performance

??? должен ли этот раздел быть в главном руководстве???

Этот раздел содержит правила для людей, которым требуется высокая производительность или низкая задержка.
То есть это правила, которые касаются того, как использовать как можно меньше времени и как можно меньше ресурсов, чтобы достичь поставленной задачи за предсказуемо короткое время.
Правила в этом разделе являются более ограничительными и навязчивыми, чем то, что необходимо для многих (большинства) приложений.
Не пытайтесь слепо следовать им в общем коде: достижение целей с низкой задержкой требует дополнительной работы.

Сводка правил производительности:

* [По.1: не оптимизируйте без причины] (#Rper-причина)
* [По.2: не оптимизируйте преждевременно] (#Rper-Knuth)
* [По.3: не оптимизируйте что-то, что не критично для производительности] (#rper-critical)
* [По.4: Не предполагайте, что сложный код обязательно быстрее простого кода] (#Rper-simple)
* [По.5: Не предполагайте, что низкоуровневый код обязательно быстрее, чем высокоуровневый код] (#Rper-low)
* [По.6: Не делайте заявлений о производительности без измерений] (#Rper-measure)
* [По.7: Дизайн для включения оптимизации] (#Rper-эффективность)
* [По.10: полагайтесь на систему статического типа] (#Rper-type)
* [По.11: перемещение вычислений из времени выполнения во время компиляции] (#Rper-Comp)
* [По.12: устранение избыточных псевдонимов] (#Rper-alias)
* [По.13: устранение избыточных косвенных операций] (#Rper-косвенные)
* [По.14: минимизировать количество выделений и освобождений] (#Rper-alloc)
* [По.15: не выделять на критической ветви] (#Rper-alloc0)
* [По.16: использование компактных структур данных] (#Rper-compact)
* [По.17: сначала объявите наиболее используемый элемент критической по времени структуры] (#Rper-struct)
* [По.18: пространство - это время] (#Rper-space)
* [По.19: доступ к памяти предсказуемо] (#Rper-access)
* [По.30: избегайте переключений контекста на критическом пути] (#rper-context)

### <a name= "Rper-reason"><a name="Rper-reason" ></a>Per.1: не оптимизируйте без причины

##### Причина

Если нет необходимости в оптимизации, то главным результатом усилий будет больше ошибок и более высокие затраты на техническое обслуживание.

##### Записка

Некоторые люди оптимизируют по привычке или потому, что это весело.

???

### <a name= "Rper-Knuth"><a name="Rper-Knuth" ></a>Per.2: не оптимизируйте преждевременно

##### Причина

Тщательно оптимизированный код обычно больше и сложнее изменить, чем неоптимизированный код.

???

### <a name= "Rper-critical"><a name="Rper-critical" ></a>Per.3: не оптимизируйте то, что не является критичным для производительности

##### Причина

Оптимизация непроизводительной части программы не оказывает никакого влияния на производительность системы.

##### Записка

Если ваша программа проводит большую часть своего времени в ожидании интернета или человека, оптимизация вычислений в памяти, вероятно, бесполезна.

Иначе говоря: если ваша программа тратит 4% своего времени обработки делает
вычисление A и 40% своего времени делая вычисление B, улучшение 50% на A
только как impactful как улучшение 5% на B. (Если вы даже не знаете, сколько
время тратится на A или B, см. <a href="#Rper-reason">Per.1< / a > и < / a>
href= "#Rper-Knuth " >Per.2< / a>.)

### <a name= "Rper-simple"><a name="Rper-simple" ></a>Per.4: Не предполагайте, что сложный код обязательно быстрее, чем простой код

##### Причина

Простой код может быть очень быстрым. Оптимизаторы иногда делают чудеса с простым кодом

##### Пример, хорошо

    // clear expression of intent, fast execution

    vector<uint8_t> v(100000);

    for (auto& c : v)
        c = ~c;

##### Example, bad

    // intended to be faster, but is often slower

    vector<uint8_t> v(100000);

    for (size_t i = 0; i < v.size(); i += sizeof(uint64_t))
    {
        uint64_t& quad_word = *reinterpret_cast<uint64_t*>(&v[i]);
        quad_word = ~quad_word;
    }

##### Note

???

???

### <a name="Rper-low"></a>Per.5: Don't assume that low-level code is necessarily faster than high-level code

##### Reason

Low-level code sometimes inhibits optimizations. Optimizers sometimes do marvels with high-level code.

##### Note

???

???

### <a name="Rper-measure"></a>Per.6: Don't make claims about performance without measurements

##### Reason

The field of performance is littered with myth and bogus folklore.
Modern hardware and optimizers defy naive assumptions; even experts are regularly surprised.

##### Note

Getting good performance measurements can be hard and require specialized tools.

##### Note

A few simple microbenchmarks using Unix `time` or the standard-library `<chrono>` can help dispel the most obvious myths.
If you can't measure your complete system accurately, at least try to measure a few of your key operations and algorithms.
A profiler can help tell you which parts of your system are performance critical.
Often, you will be surprised.

???

### <a name="Rper-efficiency"></a>Per.7: Design to enable optimization

##### Reason

Because we often need to optimize the initial design.
Because a design that ignores the possibility of later improvement is hard to change.

##### Example

From the C (and C++) standard:

    void qsort (void* base, size_t num, size_t size, int (*compar)(const void*, const void*));

When did you even want to sort memory?
Really, we sort sequences of elements, typically stored in containers.
A call to `qsort` throws away much useful information (e.g., the element type), forces the user to repeat information
already known (e.g., the element size), and forces the user to write extra code (e.g., a function to compare `double`s).
This implies added work for the programmer, is error-prone, and deprives the compiler of information needed for optimization.

    double data[100];
    // ... fill a ...

    // 100 chunks of memory of sizeof(double) starting at
    // address data using the order defined by compare_doubles
    qsort(data, 100, sizeof(double), compare_doubles);

From the point of view of interface design is that `qsort` throws away useful information.

We can do better (in C++98)

    template<typename Iter>
        void sort(Iter b, Iter e);  // sort [b:e)

    sort(data, data + 100);

Here, we use the compiler's knowledge about the size of the array, the type of elements, and how to compare `double`s.

With C++11 plus [concepts](#SS-concepts), we can do better still

    // Sortable specifies that c must be a
    // random-access sequence of elements comparable with <
    void sort(Sortable& c);

    sort(c);

The key is to pass sufficient information for a good implementation to be chosen.
In this, the `sort` interfaces shown here still have a weakness:
They implicitly rely on the element type having less-than (`<`) defined.
To complete the interface, we need a second version that accepts a comparison criteria:

    // compare elements of c using p
    void sort(Sortable& c, Predicate<Value_type<Sortable>> p);

The standard-library specification of `sort` offers those two versions,
but the semantics is expressed in English rather than code using concepts.

##### Note

Premature optimization is said to be [the root of all evil](#Rper-Knuth), but that's not a reason to despise performance.
It is never premature to consider what makes a design amenable to improvement, and improved performance is a commonly desired improvement.
Aim to build a set of habits that by default results in efficient, maintainable, and optimizable code.
In particular, when you write a function that is not a one-off implementation detail, consider

* Information passing:
Prefer clean [interfaces](#S-interfaces) carrying sufficient information for later improvement of implementation.
Note that information flows into and out of an implementation through the interfaces we provide.
* Compact data: By default, [use compact data](#Rper-compact), such as `std::vector` and [access it in a systematic fashion](#Rper-access).
If you think you need a linked structure, try to craft the interface so that this structure isn't seen by users.
* Function argument passing and return:
Distinguish between mutable and non-mutable data.
Don't impose a resource management burden on your users.
Don't impose spurious run-time indirections on your users.
Use [conventional ways](#Rf-conventional) of passing information through an interface;
unconventional and/or "optimized" ways of passing data can seriously complicate later reimplementation.
* Abstraction:
Don't overgeneralize; a design that tries to cater for every possible use (and misuse) and defers every design decision for later
(using compile-time or run-time indirections) is usually a complicated, bloated, hard-to-understand mess.
Generalize from concrete examples, preserving performance as we generalize.
Do not generalize based on mere speculation about future needs.
The ideal is zero-overhead generalization.
* Libraries:
Use libraries with good interfaces.
If no library is available build one yourself and imitate the interface style from a good library.
The [standard library](#S-stdlib) is a good first place to look for inspiration.
* Isolation:
Isolate your code from messy and/or old-style code by providing an interface of your choosing to it.
This is sometimes called "providing a wrapper" for the useful/necessary but messy code.
Don't let bad designs "bleed into" your code.

##### Example

Consider:

    template <class ForwardIterator, class T>
    bool binary_search(ForwardIterator first, ForwardIterator last, const T& val);

`binary_search(begin(c), end(c), 7)` will tell you whether `7` is in `c` or not.
However, it will not tell you where that `7` is or whether there are more than one `7`.

Sometimes, just passing the minimal amount of information back (here, `true` or `false`) is sufficient, but a good interface passes
needed information back to the caller. Therefore, the standard library also offers

    template <class ForwardIterator, class T>
    ForwardIterator lower_bound(ForwardIterator first, ForwardIterator last, const T& val);

`lower_bound` returns an iterator to the first match if any, otherwise to the first element greater than `val`, or `last` if no such element is found.

However, `lower_bound` still doesn't return enough information for all uses, so the standard library also offers

    template <class ForwardIterator, class T>
    pair<ForwardIterator, ForwardIterator>
    equal_range(ForwardIterator first, ForwardIterator last, const T& val);

`equal_range` returns a `pair` of iterators specifying the first and one beyond last match.

    auto r = equal_range(begin(c), end(c), 7);
    for (auto p = r.first; p != r.second; ++p)
        cout << *p << '\n';

Obviously, these three interfaces are implemented by the same basic code.
They are simply three ways of presenting the basic binary search algorithm to users,
ranging from the simplest ("make simple things simple!")
to returning complete, but not always needed, information ("don't hide useful information").
Naturally, crafting such a set of interfaces requires experience and domain knowledge.

##### Note

Do not simply craft the interface to match the first implementation and the first use case you think of.
Once your first initial implementation is complete, review it; once you deploy it, mistakes will be hard to remedy.

##### Note

A need for efficiency does not imply a need for [low-level code](#Rper-low).
High-level code does not imply slow or bloated.

##### Note

Things have costs.
Don't be paranoid about costs (modern computers really are very fast),
but have a rough idea of the order of magnitude of cost of what you use.
For example, have a rough idea of the cost of
a memory access,
a function call,
a string comparison,
a system call,
a disk access,
and a message through a network.

##### Note

If you can only think of one implementation, you probably don't have something for which you can devise a stable interface.
Maybe, it is just an implementation detail - not every piece of code needs a stable interface - but pause and consider.
One question that can be useful is
"what interface would be needed if this operation should be implemented using multiple threads? be vectorized?"

##### Note

This rule does not contradict the [Don't optimize prematurely](#Rper-Knuth) rule.
It complements it encouraging developers enable later - appropriate and non-premature - optimization, if and where needed.

##### Enforcement

Tricky.
Maybe looking for `void*` function arguments will find examples of interfaces that hinder later optimization.

### <a name="Rper-type"></a>Per.10: Rely on the static type system

##### Reason

Type violations, weak types (e.g. `void*`s), and low-level code (e.g., manipulation of sequences as individual bytes) make the job of the optimizer much harder. Simple code often optimizes better than hand-crafted complex code.

???

### <a name="Rper-Comp"></a>Per.11: Move computation from run time to compile time

##### Reason

To decrease code size and run time.
To avoid data races by using constants.
To catch errors at compile time (and thus eliminate the need for error-handling code).

##### Example

    double square(double d) { return d*d; }
    static double s2 = square(2);    // old-style: dynamic initialization

    constexpr double ntimes(double d, int n)   // assume 0 <= n
    {
            double m = 1;
            while (n--) m *= d;
            return m;
    }
    constexpr double s3 {ntimes(2, 3)};  // modern-style: compile-time initialization

Code like the initialization of `s2` isn't uncommon, especially for initialization that's a bit more complicated than `square()`.
However, compared to the initialization of `s3` there are two problems:

* we suffer the overhead of a function call at run time
* `s2` just might be accessed by another thread before the initialization happens.

Note: you can't have a data race on a constant.

##### Example

Consider a popular technique for providing a handle for storing small objects in the handle itself and larger ones on the heap.

    constexpr int on_stack_max = 20;

    template<typename T>
    struct Scoped {     // store a T in Scoped
            // ...
        T obj;
    };

    template<typename T>
    struct On_heap {    // store a T on the free store
            // ...
            T* objp;
    };

    template<typename T>
    using Handle = typename std::conditional<(sizeof(T) <= on_stack_max),
                        Scoped<T>,      // first alternative
                        On_heap<T>      // second alternative
                   >::type;

    void f()
    {
        Handle<double> v1;                   // the double goes on the stack
        Handle<std::array<double, 200>> v2;  // the array goes on the free store
        // ...
    }

Assume that `Scoped` and `On_heap` provide compatible user interfaces.
Here we compute the optimal type to use at compile time.
There are similar techniques for selecting the optimal function to call.

##### Note

The ideal is {not} to try execute everything at compile time.
Obviously, most computations depend on inputs so they can't be moved to compile time,
but beyond that logical constraint is the fact that complex compile-time computation can seriously increase compile times
and complicate debugging.
It is even possible to slow down code by compile-time computation.
This is admittedly rare, but by factoring out a general computation into separate optimal sub-calculations it is possible to render the instruction cache less effective.

##### Enforcement

* Look for simple functions that might be constexpr (but are not).
* Look for functions called with all constant-expression arguments.
* Look for macros that could be constexpr.

### <a name="Rper-alias"></a>Per.12: Eliminate redundant aliases

???

### <a name="Rper-indirect"></a>Per.13: Eliminate redundant indirections

???

### <a name="Rper-alloc"></a>Per.14: Minimize the number of allocations and deallocations

???

### <a name="Rper-alloc0"></a>Per.15: Do not allocate on a critical branch

???

### <a name="Rper-compact"></a>Per.16: Use compact data structures

##### Reason

Performance is typically dominated by memory access times.

???

### <a name="Rper-struct"></a>Per.17: Declare the most used member of a time-critical struct first

???

### <a name="Rper-space"></a>Per.18: Space is time

##### Reason

Performance is typically dominated by memory access times.

???

### <a name="Rper-access"></a>Per.19: Access memory predictably

##### Reason

Performance is very sensitive to cache performance and cache algorithms favor simple (usually linear) access to adjacent data.

##### Example

    int matrix[rows][cols];

    // bad
    for (int c = 0; c < cols; ++c)
        for (int r = 0; r < rows; ++r)
            sum += matrix[r][c];

    // good
    for (int r = 0; r < rows; ++r)
        for (int c = 0; c < cols; ++c)
            sum += matrix[r][c];

### <a name="Rper-context"></a>Per.30: Avoid context switches on the critical path

???

# <a name="S-concurrency"></a>CP: Concurrency and parallelism

We often want our computers to do many tasks at the same time (or at least appear to do them at the same time).
The reasons for doing so vary (e.g., waiting for many events using only a single processor, processing many data streams simultaneously, or utilizing many hardware facilities)
and so do the basic facilities for expressing concurrency and parallelism.
Here, we articulate principles and rules for using the ISO standard C++ facilities for expressing basic concurrency and parallelism.

Threads are the machine-level foundation for concurrent and parallel programming.
Threads allow running multiple sections of a program independently, while sharing
the same memory. Concurrent programming is tricky,
because protecting shared data between threads is easier said than done.
Making existing single-threaded code execute concurrently can be
as trivial as adding `std::async` or `std::thread` strategically, or it can
necessitate a full rewrite, depending on whether the original code was written
in a thread-friendly way.

The concurrency/parallelism rules in this document are designed with three goals
in mind:

* To help in writing code that is amenable to being used in a threaded
  environment
* To show clean, safe ways to use the threading primitives offered by the
  standard library
* To offer guidance on what to do when concurrency and parallelism aren't giving
  the performance gains needed

It is also important to note that concurrency in C++ is an unfinished
story. C++11 introduced many core concurrency primitives, C++14 and C++17 improved on
them, and there is much interest in making the writing of
concurrent programs in C++ even easier. We expect some of the library-related
guidance here to change significantly over time.

This section needs a lot of work (obviously).
Please note that we start with rules for relative non-experts.
Real experts must wait a bit;
contributions are welcome,
but please think about the majority of programmers who are struggling to get their concurrent programs correct and performant.

Concurrency and parallelism rule summary:

* [CP.1: Assume that your code will run as part of a multi-threaded program](#Rconc-multi)
* [CP.2: Avoid data races](#Rconc-races)
* [CP.3: Minimize explicit sharing of writable data](#Rconc-data)
* [CP.4: Think in terms of tasks, rather than threads](#Rconc-task)
* [CP.8: Don't try to use `volatile` for synchronization](#Rconc-volatile)
* [CP.9: Whenever feasible use tools to validate your concurrent code](#Rconc-tools)

**See also**:

* [CP.con: Concurrency](#SScp-con)
* [CP.par: Parallelism](#SScp-par)
* [CP.mess: Message passing](#SScp-mess)
* [CP.vec: Vectorization](#SScp-vec)
* [CP.free: Lock-free programming](#SScp-free)
* [CP.etc: Etc. concurrency rules](#SScp-etc)

### <a name="Rconc-multi"></a>CP.1: Assume that your code will run as part of a multi-threaded program

##### Reason

It's hard to be certain that concurrency isn't used now or won't be used sometime in the future.
Code gets reused.
Libraries not using threads may be used from some other part of a program that does use threads.
Note that this rule applies most urgently to library code and least urgently to stand-alone applications.
However, over time, code fragments can turn up in unexpected places.

##### Example, bad

    double cached_computation(double x)
    {
        // bad: these two statics cause data races in multi-threaded usage
        static double cached_x = 0.0;
        static double cached_result = COMPUTATION_OF_ZERO;
        double result;

        if (cached_x == x)
            return cached_result;
        result = computation(x);
        cached_x = x;
        cached_result = result;
        return result;
    }

Although `cached_computation` works perfectly in a single-threaded environment, in a multi-threaded environment the two `static` variables result in data races and thus undefined behavior.

There are several ways that this example could be made safe for a multi-threaded environment:

* Delegate concurrency concerns upwards to the caller.
* Mark the `static` variables as `thread_local` (which might make caching less effective).
* Implement concurrency control, for example, protecting the two `static` variables with a `static` lock (which might reduce performance).
* Have the caller provide the memory to be used for the cache, thereby delegating both memory allocation and concurrency concerns upwards to the caller.
* Refuse to build and/or run in a multi-threaded environment.
* Provide two implementations, one which is used in single-threaded environments and another which is used in multi-threaded environments.

##### Exception

Code that is never run in a multi-threaded environment.

Be careful: there are many examples where code that was "known" to never run in a multi-threaded program
was run as part of a multi-threaded program, often years later.
Typically, such programs lead to a painful effort to remove data races.
Therefore, code that is never intended to run in a multi-threaded environment should be clearly labeled as such and ideally come with compile or run-time enforcement mechanisms to catch those usage bugs early.

### <a name="Rconc-races"></a>CP.2: Avoid data races

##### Reason

Unless you do, nothing is guaranteed to work and subtle errors will persist.

##### Note

In a nutshell, if two threads can access the same object concurrently (without synchronization), and at least one is a writer (performing a non-`const` operation), you have a data race.
For further information of how to use synchronization well to eliminate data races, please consult a good book about concurrency.

##### Example, bad

There are many examples of data races that exist, some of which are running in
production software at this very moment. One very simple example:

    int get_id() {
      static int id = 1;
      return id++;
    }

The increment here is an example of a data race. This can go wrong in many ways,
including:

* Thread A loads the value of `id`, the OS context switches A out for some
  period, during which other threads create hundreds of IDs. Thread A is then
  allowed to run again, and `id` is written back to that location as A's read of
  `id` plus one.
* Thread A and B load `id` and increment it simultaneously.  They both get the
  same ID.

Local static variables are a common source of data races.

##### Example, bad:

    void f(fstream&  fs, regex pattern)
    {
        array<double, max> buf;
        int sz = read_vec(fs, buf, max);            // read from fs into buf
        gsl::span<double> s {buf};
        // ...
        auto h1 = async([&]{ sort(std::execution::par, s); });     // spawn a task to sort
        // ...
        auto h2 = async([&]{ return find_all(buf, sz, pattern); });   // spawn a task to find matches
        // ...
    }

Here, we have a (nasty) data race on the elements of `buf` (`sort` will both read and write).
All data races are nasty.
Here, we managed to get a data race on data on the stack.
Not all data races are as easy to spot as this one.

##### Example, bad:

    // code not controlled by a lock

    unsigned val;

    if (val < 5) {
        // ... other thread can change val here ...
        switch (val) {
        case 0: // ...
        case 1: // ...
        case 2: // ...
        case 3: // ...
        case 4: // ...
        }
    }

Now, a compiler that does not know that `val` can change will  most likely implement that `switch` using a jump table with five entries.
Then, a `val` outside the `[0..4]` range will cause a jump to an address that could be anywhere in the program, and execution would proceed there.
Really, "all bets are off" if you get a data race.
Actually, it can be worse still: by looking at the generated code you may be able to determine where the stray jump will go for a given value;
this can be a security risk.

##### Enforcement

Some is possible, do at least something.
There are commercial and open-source tools that try to address this problem,
but be aware that solutions have costs and blind spots.
Static tools often have many false positives and run-time tools often have a significant cost.
We hope for better tools.
Using multiple tools can catch more problems than a single one.

There are other ways you can mitigate the chance of data races:

* Avoid global data
* Avoid `static` variables
* More use of value types on the stack (and don't pass pointers around too much)
* More use of immutable data (literals, `constexpr`, and `const`)

### <a name="Rconc-data"></a>CP.3: Minimize explicit sharing of writable data

##### Reason

If you don't share writable data, you can't have a data race.
The less sharing you do, the less chance you have to forget to synchronize access (and get data races).
The less sharing you do, the less chance you have to wait on a lock (so performance can improve).

##### Example

    bool validate(const vector<Reading>&);
    Graph<Temp_node> temperature_gradiants(const vector<Reading>&);
    Image altitude_map(const vector<Reading>&);
    // ...

    void process_readings(const vector<Reading>& surface_readings)
    {
        auto h1 = async([&] { if (!validate(surface_readings)) throw Invalid_data{}; });
        auto h2 = async([&] { return temperature_gradiants(surface_readings); });
        auto h3 = async([&] { return altitude_map(surface_readings); });
        // ...
        h1.get();
        auto v2 = h2.get();
        auto v3 = h3.get();
        // ...
    }

Without those `const`s, we would have to review every asynchronously invoked function for potential data races on `surface_readings`.
Making `surface_readings` be `const` (with respect to this function) allow reasoning using only the function body.

##### Note

Immutable data can be safely and efficiently shared.
No locking is needed: You can't have a data race on a constant.
See also [CP.mess: Message Passing](#SScp-mess) and [CP.31: prefer pass by value](#Rconc-data-by-value).

##### Enforcement

???


### <a name="Rconc-task"></a>CP.4: Think in terms of tasks, rather than threads

##### Reason

A `thread` is an implementation concept, a way of thinking about the machine.
A task is an application notion, something you'd like to do, preferably concurrently with other tasks.
Application concepts are easier to reason about.

##### Example

    void some_fun() {
        std::string msg, msg2;
        std::thread publisher([&] { msg = "Hello"; });       // bad: less expressive
                                                             //      and more error-prone
        auto pubtask = std::async([&] { msg2 = "Hello"; });  // OK
        // ...
        publisher.join();
    }

##### Note

With the exception of `async()`, the standard-library facilities are low-level, machine-oriented, threads-and-lock level.
This is a necessary foundation, but we have to try to raise the level of abstraction: for productivity, for reliability, and for performance.
This is a potent argument for using higher level, more applications-oriented libraries (if possibly, built on top of standard-library facilities).

##### Enforcement

???

### <a name="Rconc-volatile"></a>CP.8: Don't try to use `volatile` for synchronization

##### Reason

In C++, unlike some other languages, `volatile` does not provide atomicity, does not synchronize between threads,
and does not prevent instruction reordering (neither compiler nor hardware).
It simply has nothing to do with concurrency.

##### Example, bad:

    int free_slots = max_slots; // current source of memory for objects

    Pool* use()
    {
        if (int n = free_slots--) return &pool[n];
    }

Here we have a problem:
This is perfectly good code in a single-threaded program, but have two threads execute this and
there is a race condition on `free_slots` so that two threads might get the same value and `free_slots`.
That's (obviously) a bad data race, so people trained in other languages may try to fix it like this:

    volatile int free_slots = max_slots; // current source of memory for objects

    Pool* use()
    {
        if (int n = free_slots--) return &pool[n];
    }

This has no effect on synchronization: The data race is still there!

The C++ mechanism for this is `atomic` types:

    atomic<int> free_slots = max_slots; // current source of memory for objects

    Pool* use()
    {
        if (int n = free_slots--) return &pool[n];
    }

Now the `--` operation is atomic,
rather than a read-increment-write sequence where another thread might get in-between the individual operations.

##### Alternative

Use `atomic` types where you might have used `volatile` in some other language.
Use a `mutex` for more complicated examples.

##### See also

[(rare) proper uses of `volatile`](#Rconc-volatile2)

### <a name="Rconc-tools"></a>CP.9: Whenever feasible use tools to validate your concurrent code

Experience shows that concurrent code is exceptionally hard to get right
and that compile-time checking, run-time checks, and testing are less effective at finding concurrency errors
than they are at finding errors in sequential code.
Subtle concurrency errors can have dramatically bad effects, including memory corruption and deadlocks.

##### Example

    ???

##### Note

Thread safety is challenging, often getting the better of experienced programmers: tooling is an important strategy to mitigate those risks.
There are many tools "out there", both commercial and open-source tools, both research and production tools.
Unfortunately people's needs and constraints differ so dramatically that we cannot make specific recommendations,
but we can mention:

* Static enforcement tools: both [clang](http://clang.llvm.org/docs/ThreadSafetyAnalysis.html)
and some older versions of [GCC](https://gcc.gnu.org/wiki/ThreadSafetyAnnotation)
have some support for static annotation of thread safety properties.
Consistent use of this technique turns many classes of thread-safety errors into compile-time errors.
The annotations are generally local (marking a particular member variable as guarded by a particular mutex),
and are usually easy to learn. However, as with many static tools, it can often present false negatives;
cases that should have been caught but were allowed.

* dynamic enforcement tools: Clang's [Thread Sanitizer](http://clang.llvm.org/docs/ThreadSanitizer.html) (aka TSAN)
is a powerful example of dynamic tools: it changes the build and execution of your program to add bookkeeping on memory access,
absolutely identifying data races in a given execution of your binary.
The cost for this is both memory (5-10x in most cases) and CPU slowdown (2-20x).
Dynamic tools like this are best when applied to integration tests, canary pushes, or unittests that operate on multiple threads.
Workload matters: When TSAN identifies a problem, it is effectively always an actual data race,
but it can only identify races seen in a given execution.

##### Enforcement

It is up to an application builder to choose which support tools are valuable for a particular applications.

## <a name="SScp-con"></a>CP.con: Concurrency

This section focuses on relatively ad-hoc uses of multiple threads communicating through shared data.

* For parallel algorithms, see [parallelism](#SScp-par)
* For inter-task communication without explicit sharing, see [messaging](#SScp-mess)
* For vector parallel code, see [vectorization](#SScp-vec)
* For lock-free programming, see [lock free](#SScp-free)

Concurrency rule summary:

* [CP.20: Use RAII, never plain `lock()`/`unlock()`](#Rconc-raii)
* [CP.21: Use `std::lock()` or `std::scoped_lock` to acquire multiple `mutex`es](#Rconc-lock)
* [CP.22: Never call unknown code while holding a lock (e.g., a callback)](#Rconc-unknown)
* [CP.23: Think of a joining `thread` as a scoped container](#Rconc-join)
* [CP.24: Think of a `thread` as a global container](#Rconc-detach)
* [CP.25: Prefer `gsl::joining_thread` over `std::thread`](#Rconc-joining_thread)
* [CP.26: Don't `detach()` a thread](#Rconc-detached_thread)
* [CP.31: Pass small amounts of data between threads by value, rather than by reference or pointer](#Rconc-data-by-value)
* [CP.32: To share ownership between unrelated `thread`s use `shared_ptr`](#Rconc-shared)
* [CP.40: Minimize context switching](#Rconc-switch)
* [CP.41: Minimize thread creation and destruction](#Rconc-create)
* [CP.42: Don't `wait` without a condition](#Rconc-wait)
* [CP.43: Minimize time spent in a critical section](#Rconc-time)
* [CP.44: Remember to name your `lock_guard`s and `unique_lock`s](#Rconc-name)
* [CP.50: Define a `mutex` together with the data it guards. Use `synchronized_value<T>` where possible](#Rconc-mutex)
* ??? when to use a spinlock
* ??? when to use `try_lock()`
* ??? when to prefer `lock_guard` over `unique_lock`
* ??? Time multiplexing
* ??? when/how to use `new thread`

### <a name="Rconc-raii"></a>CP.20: Use RAII, never plain `lock()`/`unlock()`

##### Reason

Avoids nasty errors from unreleased locks.

##### Example, bad

    mutex mtx;

    void do_stuff()
    {
        mtx.lock();
        // ... do stuff ...
        mtx.unlock();
    }

Sooner or later, someone will forget the `mtx.unlock()`, place a `return` in the `... do stuff ...`, throw an exception, or something.

    mutex mtx;

    void do_stuff()
    {
        unique_lock<mutex> lck {mtx};
        // ... do stuff ...
    }

##### Enforcement

Flag calls of member `lock()` and `unlock()`.  ???


### <a name="Rconc-lock"></a>CP.21: Use `std::lock()` or `std::scoped_lock` to acquire multiple `mutex`es

##### Reason

To avoid deadlocks on multiple `mutex`es.

##### Example

This is asking for deadlock:

    // thread 1
    lock_guard<mutex> lck1(m1);
    lock_guard<mutex> lck2(m2);

    // thread 2
    lock_guard<mutex> lck2(m2);
    lock_guard<mutex> lck1(m1);

Instead, use `lock()`:

    // thread 1
    lock(m1, m2);
    lock_guard<mutex> lck1(m1, adopt_lock);
    lock_guard<mutex> lck2(m2, adopt_lock);

    // thread 2
    lock(m2, m1);
    lock_guard<mutex> lck2(m2, adopt_lock);
    lock_guard<mutex> lck1(m1, adopt_lock);

or (better, but C++17 only):

    // thread 1
    scoped_lock<mutex, mutex> lck1(m1, m2);

    // thread 2
    scoped_lock<mutex, mutex> lck2(m2, m1);

Here, the writers of `thread1` and `thread2` are still not agreeing on the order of the `mutex`es, but order no longer matters.

##### Note

In real code, `mutex`es are rarely named to conveniently remind the programmer of an intended relation and intended order of acquisition.
In real code, `mutex`es are not always conveniently acquired on consecutive lines.

In C++17 it's possible to write plain

    lock_guard lck1(m1, adopt_lock);

and have the `mutex` type deduced.

##### Enforcement

Detect the acquisition of multiple `mutex`es.
This is undecidable in general, but catching common simple examples (like the one above) is easy.


### <a name="Rconc-unknown"></a>CP.22: Never call unknown code while holding a lock (e.g., a callback)

##### Reason

If you don't know what a piece of code does, you are risking deadlock.

##### Example

    void do_this(Foo* p)
    {
        lock_guard<mutex> lck {my_mutex};
        // ... do something ...
        p->act(my_data);
        // ...
    }

If you don't know what `Foo::act` does (maybe it is a virtual function invoking a derived class member of a class not yet written),
it may call `do_this` (recursively) and cause a deadlock on `my_mutex`.
Maybe it will lock on a different mutex and not return in a reasonable time, causing delays to any code calling `do_this`.

##### Example

A common example of the "calling unknown code" problem is a call to a function that tries to gain locked access to the same object.
Such problem can often be solved by using a `recursive_mutex`. For example:

    recursive_mutex my_mutex;

    template<typename Action>
    void do_something(Action f)
    {
        unique_lock<recursive_mutex> lck {my_mutex};
        // ... do something ...
        f(this);    // f will do something to *this
        // ...
    }

If, as it is likely, `f()` invokes operations on `*this`, we must make sure that the object's invariant holds before the call.

##### Enforcement

* Flag calling a virtual function with a non-recursive `mutex` held
* Flag calling a callback with a non-recursive `mutex` held


### <a name="Rconc-join"></a>CP.23: Think of a joining `thread` as a scoped container

##### Reason

To maintain pointer safety and avoid leaks, we need to consider what pointers are used by a `thread`.
If a `thread` joins, we can safely pass pointers to objects in the scope of the `thread` and its enclosing scopes.

##### Example

    void f(int* p)
    {
        // ...
        *p = 99;
        // ...
    }
    int glob = 33;

    void some_fct(int* p)
    {
        int x = 77;
        joining_thread t0(f, &x);           // OK
        joining_thread t1(f, p);            // OK
        joining_thread t2(f, &glob);        // OK
        auto q = make_unique<int>(99);
        joining_thread t3(f, q.get());      // OK
        // ...
    }

A `gsl::joining_thread` is a `std::thread` with a destructor that joins and that cannot be `detached()`.
By "OK" we mean that the object will be in scope ("live") for as long as a `thread` can use the pointer to it.
The fact that `thread`s run concurrently doesn't affect the lifetime or ownership issues here;
these `thread`s can be seen as just a function object called from `some_fct`.

##### Enforcement

Ensure that `joining_thread`s don't `detach()`.
After that, the usual lifetime and ownership (for local objects) enforcement applies.

### <a name="Rconc-detach"></a>CP.24: Think of a `thread` as a global container

##### Reason

To maintain pointer safety and avoid leaks, we need to consider what pointers are used by a `thread`.
If a `thread` is detached, we can safely pass pointers to static and free store objects (only).

##### Example

    void f(int* p)
    {
        // ...
        *p = 99;
        // ...
    }

    int glob = 33;

    void some_fct(int* p)
    {
        int x = 77;
        std::thread t0(f, &x);           // bad
        std::thread t1(f, p);            // bad
        std::thread t2(f, &glob);        // OK
        auto q = make_unique<int>(99);
        std::thread t3(f, q.get());      // bad
        // ...
        t0.detach();
        t1.detach();
        t2.detach();
        t3.detach();
        // ...
    }

By "OK" we mean that the object will be in scope ("live") for as long as a `thread` can use the pointers to it.
By "bad" we mean that a `thread` may use a pointer after the pointed-to object is destroyed.
The fact that `thread`s run concurrently doesn't affect the lifetime or ownership issues here;
these `thread`s can be seen as just a function object called from `some_fct`.

##### Note

Even objects with static storage duration can be problematic if used from detached threads: if the
thread continues until the end of the program, it might be running concurrently with the destruction
of objects with static storage duration, and thus accesses to such objects might race.

##### Note

This rule is redundant if you [don't `detach()`](#Rconc-detached_thread) and [use `gsl::joining_thread`](#Rconc-joining_thread).
However, converting code to follow those guidelines could be difficult and even impossible for third-party libraries.
In such cases, the rule becomes essential for lifetime safety and type safety.


In general, it is undecidable whether a `detach()` is executed for a `thread`, but simple common cases are easily detected.
If we cannot prove that a `thread` does not `detach()`, we must assume that it does and that it outlives the scope in which it was constructed;
After that, the usual lifetime and ownership (for global objects) enforcement applies.

##### Enforcement

Flag attempts to pass local variables to a thread that might `detach()`.

### <a name="Rconc-joining_thread"></a>CP.25: Prefer `gsl::joining_thread` over `std::thread`

##### Reason

A `joining_thread` is a thread that joins at the end of its scope.
Detached threads are hard to monitor.
It is harder to ensure absence of errors in detached threads (and potentially detached threads)

##### Example, bad

    void f() { std::cout << "Hello "; }

    struct F {
        void operator()() { std::cout << "parallel world "; }
    };

    int main()
    {
        std::thread t1{f};      // f() executes in separate thread
        std::thread t2{F()};    // F()() executes in separate thread
    }  // spot the bugs

##### Example

    void f() { std::cout << "Hello "; }

    struct F {
        void operator()() { std::cout << "parallel world "; }
    };

    int main()
    {
        std::thread t1{f};      // f() executes in separate thread
        std::thread t2{F()};    // F()() executes in separate thread

        t1.join();
        t2.join();
    }  // one bad bug left


##### Example, bad

The code determining whether to `join()` or `detach()` may be complicated and even decided in the thread of functions called from it or functions called by the function that creates a thread:

    void tricky(thread* t, int n)
    {
        // ...
        if (is_odd(n))
            t->detach();
        // ...
    }

    void use(int n)
    {
        thread t { tricky, this, n };
        // ...
        // ... should I join here? ...
    }

This seriously complicates lifetime analysis, and in not too unlikely cases makes lifetime analysis impossible.
This implies that we cannot safely refer to local objects in `use()` from the thread or refer to local objects in the thread from `use()`.

##### Note

Make "immortal threads" globals, put them in an enclosing scope, or put them on the free store rather than `detach()`.
[don't `detach`](#Rconc-detached_thread).

##### Note

Because of old code and third party libraries using `std::thread` this rule can be hard to introduce.

##### Enforcement

Flag uses of `std::thread`:

* Suggest use of `gsl::joining_thread`.
* Suggest ["exporting ownership"](#Rconc-detached_thread) to an enclosing scope if it detaches.
* Seriously warn if it is not obvious whether if joins of detaches.

### <a name="Rconc-detached_thread"></a>CP.26: Don't `detach()` a thread

##### Reason

Often, the need to outlive the scope of its creation is inherent in the `thread`s task,
but implementing that idea by `detach` makes it harder to monitor and communicate with the detached thread.
In particular, it is harder (though not impossible) to ensure that the thread completed as expected or lives for as long as expected.

##### Example

    void heartbeat();

    void use()
    {
        std::thread t(heartbeat);             // don't join; heartbeat is meant to run forever
        t.detach();
        // ...
    }

This is a reasonable use of a thread, for which `detach()` is commonly used.
There are problems, though.
How do we monitor the detached thread to see if it is alive?
Something might go wrong with the heartbeat, and losing a heartbeat can be very serious in a system for which it is needed.
So, we need to communicate with the heartbeat thread
(e.g., through a stream of messages or notification events using a `condition_variable`).

An alternative, and usually superior solution is to control its lifetime by placing it in a scope outside its point of creation (or activation).
For example:

    void heartbeat();

    gsl::joining_thread t(heartbeat);             // heartbeat is meant to run "forever"

This heartbeat will (barring error, hardware problems, etc.) run for as long as the program does.

Sometimes, we need to separate the point of creation from the point of ownership:

    void heartbeat();

    unique_ptr<gsl::joining_thread> tick_tock {nullptr};

    void use()
    {
        // heartbeat is meant to run as long as tick_tock lives
        tick_tock = make_unique<gsl::joining_thread>(heartbeat);
        // ...
    }

#### Enforcement

Flag `detach()`.


### <a name="Rconc-data-by-value"></a>CP.31: Pass small amounts of data between threads by value, rather than by reference or pointer

##### Reason

Copying a small amount of data is cheaper to copy and access than to share it using some locking mechanism.
Copying naturally gives unique ownership (simplifies code) and eliminates the possibility of data races.

##### Note

Defining "small amount" precisely is impossible.

##### Example

    string modify1(string);
    void modify2(string&);

    void fct(string& s)
    {
        auto res = async(modify1, s);
        async(modify2, s);
    }

The call of `modify1` involves copying two `string` values; the call of `modify2` does not.
On the other hand, the implementation of `modify1` is exactly as we would have written it for single-threaded code,
whereas the implementation of `modify2` will need some form of locking to avoid data races.
If the string is short (say 10 characters), the call of `modify1` can be surprisingly fast;
essentially all the cost is in the `thread` switch. If the string is long (say 1,000,000 characters), copying it twice
is probably not a good idea.

Note that this argument has nothing to do with `async` as such. It applies equally to considerations about whether to use
message passing or shared memory.

##### Enforcement

???


### <a name="Rconc-shared"></a>CP.32: To share ownership between unrelated `thread`s use `shared_ptr`

##### Reason

If threads are unrelated (that is, not known to be in the same scope or one within the lifetime of the other)
and they need to share free store memory that needs to be deleted, a `shared_ptr` (or equivalent) is the only
safe way to ensure proper deletion.

##### Example

    ???

##### Note

* A static object (e.g. a global) can be shared because it is not owned in the sense that some thread is responsible for its deletion.
* An object on free store that is never to be deleted can be shared.
* An object owned by one thread can be safely shared with another as long as that second thread doesn't outlive the owner.

##### Enforcement

???


### <a name="Rconc-switch"></a>CP.40: Minimize context switching

##### Reason

Context switches are expensive.

##### Example

    ???

##### Enforcement

???


### <a name="Rconc-create"></a>CP.41: Minimize thread creation and destruction

##### Reason

Thread creation is expensive.

##### Example

    void worker(Message m)
    {
        // process
    }

    void master(istream& is)
    {
        for (Message m; is >> m; )
            run_list.push_back(new thread(worker, m));
    }

This spawns a `thread` per message, and the `run_list` is presumably managed to destroy those tasks once they are finished.

Instead, we could have a set of pre-created worker threads processing the messages

    Sync_queue<Message> work;

    void master(istream& is)
    {
        for (Message m; is >> m; )
            work.put(m);
    }

    void worker()
    {
        for (Message m; m = work.get(); ) {
            // process
        }
    }

    void workers()  // set up worker threads (specifically 4 worker threads)
    {
        joining_thread w1 {worker};
        joining_thread w2 {worker};
        joining_thread w3 {worker};
        joining_thread w4 {worker};
    }

##### Note

If your system has a good thread pool, use it.
If your system has a good message queue, use it.

##### Enforcement

???


### <a name="Rconc-wait"></a>CP.42: Don't `wait` without a condition

##### Reason

A `wait` without a condition can miss a wakeup or wake up simply to find that there is no work to do.

##### Example, bad

    std::condition_variable cv;
    std::mutex mx;

    void thread1()
    {
        while (true) {
            // do some work ...
            std::unique_lock<std::mutex> lock(mx);
            cv.notify_one();    // wake other thread
        }
    }

    void thread2()
    {
        while (true) {
            std::unique_lock<std::mutex> lock(mx);
            cv.wait(lock);    // might block forever
            // do work ...
        }
    }

Here, if some other `thread` consumes `thread1`'s notification, `thread2` can wait forever.

##### Example

    template<typename T>
    class Sync_queue {
    public:
        void put(const T& val);
        void put(T&& val);
        void get(T& val);
    private:
        mutex mtx;
        condition_variable cond;    // this controls access
        list<T> q;
    };

    template<typename T>
    void Sync_queue<T>::put(const T& val)
    {
        lock_guard<mutex> lck(mtx);
        q.push_back(val);
        cond.notify_one();
    }

    template<typename T>
    void Sync_queue<T>::get(T& val)
    {
        unique_lock<mutex> lck(mtx);
        cond.wait(lck, [this]{ return !q.empty(); });    // prevent spurious wakeup
        val = q.front();
        q.pop_front();
    }

Now if the queue is empty when a thread executing `get()` wakes up (e.g., because another thread has gotten to `get()` before it),
it will immediately go back to sleep, waiting.

##### Enforcement

Flag all `wait`s without conditions.


### <a name="Rconc-time"></a>CP.43: Minimize time spent in a critical section

##### Reason

The less time is spent with a `mutex` taken, the less chance that another `thread` has to wait,
and `thread` suspension and resumption are expensive.

##### Example

    void do_something() // bad
    {
        unique_lock<mutex> lck(my_lock);
        do0();  // preparation: does not need lock
        do1();  // transaction: needs locking
        do2();  // cleanup: does not need locking
    }

Here, we are holding the lock for longer than necessary:
We should not have taken the lock before we needed it and should have released it again before starting the cleanup.
We could rewrite this to

    void do_something() // bad
    {
        do0();  // preparation: does not need lock
        my_lock.lock();
        do1();  // transaction: needs locking
        my_lock.unlock();
        do2();  // cleanup: does not need locking
    }

But that compromises safety and violates the [use RAII](#Rconc-raii) rule.
Instead, add a block for the critical section:

    void do_something() // OK
    {
        do0();  // preparation: does not need lock
        {
            unique_lock<mutex> lck(my_lock);
            do1();  // transaction: needs locking
        }
        do2();  // cleanup: does not need locking
    }

##### Enforcement

Impossible in general.
Flag "naked" `lock()` and `unlock()`.


### <a name="Rconc-name"></a>CP.44: Remember to name your `lock_guard`s and `unique_lock`s

##### Reason

An unnamed local objects is a temporary that immediately goes out of scope.

##### Example

    unique_lock<mutex>(m1);
    lock_guard<mutex> {m2};
    lock(m1, m2);

This looks innocent enough, but it isn't.

##### Enforcement

Flag all unnamed `lock_guard`s and `unique_lock`s.



### <a name="Rconc-mutex"></a>CP.50: Define a `mutex` together with the data it guards. Use `synchronized_value<T>` where possible

##### Reason

It should be obvious to a reader that the data is to be guarded and how. This decreases the chance of the wrong mutex being locked, or the mutex not being locked.

Using a `synchronized_value<T>` ensures that the data has a mutex, and the right mutex is locked when the data is accessed.
See the [WG21 proposal](http://wg21.link/p0290) to add `synchronized_value` to a future TS or revision of the C++ standard.

##### Example

    struct Record {
        std::mutex m;   // take this mutex before accessing other members
        // ...
    };

    class MyClass {
        struct DataRecord {
           // ...
        };
        synchronized_value<DataRecord> data; // Protect the data with a mutex
    };

##### Enforcement

??? Possible?


## <a name="SScp-par"></a>CP.par: Parallelism

By "parallelism" we refer to performing a task (more or less) simultaneously ("in parallel with") on many data items.

Parallelism rule summary:

* ???
* ???
* Where appropriate, prefer the standard-library parallel algorithms
* Use algorithms that are designed for parallelism, not algorithms with unnecessary dependency on linear evaluation



## <a name="SScp-mess"></a>CP.mess: Message passing

The standard-library facilities are quite low-level, focused on the needs of close-to the hardware critical programming using `thread`s, `mutex`es, `atomic` types, etc.
Most people shouldn't work at this level: it's error-prone and development is slow.
If possible, use a higher level facility: messaging libraries, parallel algorithms, and vectorization.
This section looks at passing messages so that a programmer doesn't have to do explicit synchronization.

Message passing rules summary:

* [CP.60: Use a `future` to return a value from a concurrent task](#Rconc-future)
* [CP.61: Use an `async()` to spawn a concurrent task](#Rconc-async)
* message queues
* messaging libraries

???? should there be a "use X rather than `std::async`" where X is something that would use a better specified thread pool?

??? Is `std::async` worth using in light of future (and even existing, as libraries) parallelism facilities? What should the guidelines recommend if someone wants to parallelize, e.g., `std::accumulate` (with the additional precondition of commutativity), or merge sort?


### <a name="Rconc-future"></a>CP.60: Use a `future` to return a value from a concurrent task

##### Reason

A `future` preserves the usual function call return semantics for asynchronous tasks.
There is no explicit locking and both correct (value) return and error (exception) return are handled simply.

##### Example

    ???

##### Note

???

##### Enforcement

???

### <a name="Rconc-async"></a>CP.61: Use an `async()` to spawn a concurrent task

##### Reason

A `future` preserves the usual function call return semantics for asynchronous tasks.
There is no explicit locking and both correct (value) return and error (exception) return are handled simply.

##### Example

    int read_value(const std::string& filename)
    {
        std::ifstream in(filename);
        in.exceptions(std::ifstream::failbit);
        int value;
        in >> value;
        return value;
    }


    void async_example()
    {
        try
        {
            auto v1 = std::async(std::launch::async, read_value, "v1.txt"); 
            auto v2 = std::async(std::launch::async, read_value, "v2.txt");
            std::cout << v1.get() + v2.get() << '\n';
        }
        catch (std::ios_base::failure & fail) 
        {
            // handle exception here
        }
    }
    
##### Note

Unfortunately, `async()` is not perfect.
For example, there is no guarantee that a thread pool is used to minimize thread construction.
In fact, most current `async()` implementations don't.
However, `async()` is simple and logically correct so until something better comes along
and unless you really need to optimize for many asynchronous tasks, stick with `async()`.

##### Enforcement

???


## <a name="SScp-vec"></a>CP.vec: Vectorization

Vectorization is a technique for executing a number of tasks concurrently without introducing explicit synchronization.
An operation is simply applied to elements of a data structure (a vector, an array, etc.) in parallel.
Vectorization has the interesting property of often requiring no non-local changes to a program.
However, vectorization works best with simple data structures and with algorithms specifically crafted to enable it.

Vectorization rule summary:

* ???
* ???

## <a name="SScp-free"></a>CP.free: Lock-free programming

Synchronization using `mutex`es and `condition_variable`s can be relatively expensive.
Furthermore, it can lead to deadlock.
For performance and to eliminate the possibility of deadlock, we sometimes have to use the tricky low-level "lock-free" facilities
that rely on briefly gaining exclusive ("atomic") access to memory.
Lock-free programming is also used to implement higher-level concurrency mechanisms, such as `thread`s and `mutex`es.

Lock-free programming rule summary:

* [CP.100: Don't use lock-free programming unless you absolutely have to](#Rconc-lockfree)
* [CP.101: Distrust your hardware/compiler combination](#Rconc-distrust)
* [CP.102: Carefully study the literature](#Rconc-literature)
* how/when to use atomics
* avoid starvation
* use a lock-free data structure rather than hand-crafting specific lock-free access
* [CP.110: Do not write your own double-checked locking for initialization](#Rconc-double)
* [CP.111: Use a conventional pattern if you really need double-checked locking](#Rconc-double-pattern)
* how/when to compare and swap


### <a name="Rconc-lockfree"></a>CP.100: Don't use lock-free programming unless you absolutely have to

##### Reason

It's error-prone and requires expert level knowledge of language features, machine architecture, and data structures.

##### Example, bad

    extern atomic<Link*> head;        // the shared head of a linked list

    Link* nh = new Link(data, nullptr);    // make a link ready for insertion
    Link* h = head.load();                 // read the shared head of the list

    do {
        if (h->data <= data) break;        // if so, insert elsewhere
        nh->next = h;                      // next element is the previous head
    } while (!head.compare_exchange_weak(h, nh));    // write nh to head or to h

Spot the bug.
It would be really hard to find through testing.
Read up on the ABA problem.

##### Exception

[Atomic variables](#???) can be used simply and safely, as long as you are using the sequentially consistent memory model (memory_order_seq_cst), which is the default.

##### Note

Higher-level concurrency mechanisms, such as `thread`s and `mutex`es are implemented using lock-free programming.

**Alternative**: Use lock-free data structures implemented by others as part of some library.


### <a name="Rconc-distrust"></a>CP.101: Distrust your hardware/compiler combination

##### Reason

The low-level hardware interfaces used by lock-free programming are among the hardest to implement well and among
the areas where the most subtle portability problems occur.
If you are doing lock-free programming for performance, you need to check for regressions.

##### Note

Instruction reordering (static and dynamic) makes it hard for us to think effectively at this level (especially if you use relaxed memory models).
Experience, (semi)formal models and model checking can be useful.
Testing - often to an extreme extent - is essential.
"Don't fly too close to the sun."

##### Enforcement

Have strong rules for re-testing in place that covers any change in hardware, operating system, compiler, and libraries.


### <a name="Rconc-literature"></a>CP.102: Carefully study the literature

##### Reason

With the exception of atomics and a few use standard patterns, lock-free programming is really an expert-only topic.
Become an expert before shipping lock-free code for others to use.

##### References

* Anthony Williams: C++ concurrency in action. Manning Publications.
* Boehm, Adve, You Don't Know Jack About Shared Variables or Memory Models , Communications of the ACM, Feb 2012.
* Boehm, "Threads Basics", HPL TR 2009-259.
* Adve, Boehm, "Memory Models: A Case for Rethinking Parallel Languages and Hardware", Communications of the ACM, August 2010.
* Boehm, Adve, "Foundations of the C++ Concurrency Memory Model", PLDI 08.
* Mark Batty, Scott Owens, Susmit Sarkar, Peter Sewell, and Tjark Weber, "Mathematizing C++ Concurrency", POPL 2011.
* Damian Dechev, Peter Pirkelbauer, and Bjarne Stroustrup: Understanding and Effectively Preventing the ABA Problem in Descriptor-based Lock-free Designs. 13th IEEE Computer Society ISORC 2010 Symposium. May 2010.
* Damian Dechev and Bjarne Stroustrup: Scalable Non-blocking Concurrent Objects for Mission Critical Code. ACM OOPSLA'09. October 2009
* Damian Dechev, Peter Pirkelbauer, Nicolas Rouquette, and Bjarne Stroustrup: Semantically Enhanced Containers for Concurrent Real-Time Systems. Proc. 16th Annual IEEE International Conference and Workshop on the Engineering of Computer Based Systems (IEEE ECBS). April 2009.


### <a name="Rconc-double"></a>CP.110: Do not write your own double-checked locking for initialization

##### Reason

Since C++11, static local variables are now initialized in a thread-safe way. When combined with the RAII pattern, static local variables can replace the need for writing your own double-checked locking for initialization. std::call_once can also achieve the same purpose. Use either static local variables of C++11 or std::call_once instead of writing your own double-checked locking for initialization.

##### Example

Example with std::call_once.

    void f()
    {
        static std::once_flag my_once_flag;
        std::call_once(my_once_flag, []()
        {
            // do this only once
        });
        // ...
    }

Example with thread-safe static local variables of C++11.

    void f()
    {
        // Assuming the compiler is compliant with C++11
        static My_class my_object; // Constructor called only once
        // ...
    }

    class My_class
    {
    public:
        My_class()
        {
            // do this only once
        }
    };

##### Enforcement

??? Is it possible to detect the idiom?


### <a name="Rconc-double-pattern"></a>CP.111: Use a conventional pattern if you really need double-checked locking

##### Reason

Double-checked locking is easy to mess up. If you really need to write your own double-checked locking, in spite of the rules [CP.110: Do not write your own double-checked locking for initialization](#Rconc-double) and [CP.100: Don't use lock-free programming unless you absolutely have to](#Rconc-lockfree), then do it in a conventional pattern.

The uses of the double-checked locking pattern that are not in violation of [CP.110: Do not write your own double-checked locking for initialization](#Rconc-double) arise when a non-thread-safe action is both hard and rare, and there exists a fast thread-safe test that can be used to guarantee that the action is not needed, but cannot be used to guarantee the converse.

##### Example, bad

The use of volatile does not make the first check thread-safe, see also [CP.200: Use `volatile` only to talk to non-C++ memory](#Rconc-volatile2)

    mutex action_mutex;
    volatile bool action_needed;

    if (action_needed) {
        std::lock_guard<std::mutex> lock(action_mutex);
        if (action_needed) {
            take_action();
            action_needed = false;
        }
    }

##### Example, good

    mutex action_mutex;
    atomic<bool> action_needed;

    if (action_needed) {
        std::lock_guard<std::mutex> lock(action_mutex);
        if (action_needed) {
            take_action();
            action_needed = false;
        }
    }

Fine-tuned memory order may be beneficial where acquire load is more efficient than sequentially-consistent load

    mutex action_mutex;
    atomic<bool> action_needed;

    if (action_needed.load(memory_order_acquire)) {
        lock_guard<std::mutex> lock(action_mutex);
        if (action_needed.load(memory_order_relaxed)) {
            take_action();
            action_needed.store(false, memory_order_release);
        }
    }

##### Enforcement

??? Is it possible to detect the idiom?


## <a name="SScp-etc"></a>CP.etc: Etc. concurrency rules

These rules defy simple categorization:

* [CP.200: Use `volatile` only to talk to non-C++ memory](#Rconc-volatile2)
* [CP.201: ??? Signals](#Rconc-signal)

### <a name="Rconc-volatile2"></a>CP.200: Use `volatile` only to talk to non-C++ memory

##### Reason

`volatile` is used to refer to objects that are shared with "non-C++" code or hardware that does not follow the C++ memory model.

##### Example

    const volatile long clock;

This describes a register constantly updated by a clock circuit.
`clock` is `volatile` because its value will change without any action from the C++ program that uses it.
For example, reading `clock` twice will often yield two different values, so the optimizer had better not optimize away the second read in this code:

    long t1 = clock;
    // ... no use of clock here ...
    long t2 = clock;

`clock` is `const` because the program should not try to write to `clock`.

##### Note

Unless you are writing the lowest level code manipulating hardware directly, consider `volatile` an esoteric feature that is best avoided.

##### Example

Usually C++ code receives `volatile` memory that is owned elsewhere (hardware or another language):

    int volatile* vi = get_hardware_memory_location();
        // note: we get a pointer to someone else's memory here
        // volatile says "treat this with extra respect"

Sometimes C++ code allocates the `volatile` memory and shares it with "elsewhere" (hardware or another language) by deliberately escaping a pointer:

    static volatile long vl;
    please_use_this(&vl);   // escape a reference to this to "elsewhere" (not C++)

##### Example, bad

`volatile` local variables are nearly always wrong -- how can they be shared with other languages or hardware if they're ephemeral?
The same applies almost as strongly to member variables, for the same reason.

    void f() {
        volatile int i = 0; // bad, volatile local variable
        // etc.
    }

    class My_type {
        volatile int i = 0; // suspicious, volatile member variable
        // etc.
    };

##### Note

In C++, unlike in some other languages, `volatile` has [nothing to do with synchronization](#Rconc-volatile).

##### Enforcement

* Flag `volatile T` local and member variables; almost certainly you intended to use `atomic<T>` instead.
* ???

### <a name="Rconc-signal"></a>CP.201: ??? Signals

???UNIX signal handling???. May be worth reminding how little is async-signal-safe, and how to communicate with a signal handler (best is probably "not at all")


# <a name="S-errors"></a>E: Error handling

Error handling involves:

* Detecting an error
* Transmitting information about an error to some handler code
* Preserving a valid state of the program
* Avoiding resource leaks

It is not possible to recover from all errors. If recovery from an error is not possible, it is important to quickly "get out" in a well-defined way. A strategy for error handling must be simple, or it becomes a source of even worse errors.  Untested and rarely executed error-handling code is itself the source of many bugs.

The rules are designed to help avoid several kinds of errors:

* Type violations (e.g., misuse of `union`s and casts)
* Resource leaks (including memory leaks)
* Bounds errors
* Lifetime errors (e.g., accessing an object after is has been `delete`d)
* Complexity errors (logical errors made likely by overly complex expression of ideas)
* Interface errors (e.g., an unexpected value is passed through an interface)

Error-handling rule summary:

* [E.1: Develop an error-handling strategy early in a design](#Re-design)
* [E.2: Throw an exception to signal that a function can't perform its assigned task](#Re-throw)
* [E.3: Use exceptions for error handling only](#Re-errors)
* [E.4: Design your error-handling strategy around invariants](#Re-design-invariants)
* [E.5: Let a constructor establish an invariant, and throw if it cannot](#Re-invariant)
* [E.6: Use RAII to prevent leaks](#Re-raii)
* [E.7: State your preconditions](#Re-precondition)
* [E.8: State your postconditions](#Re-postcondition)

* [E.12: Use `noexcept` when exiting a function because of a `throw` is impossible or unacceptable](#Re-noexcept)
* [E.13: Never throw while being the direct owner of an object](#Re-never-throw)
* [E.14: Use purpose-designed user-defined types as exceptions (not built-in types)](#Re-exception-types)
* [E.15: Catch exceptions from a hierarchy by reference](#Re-exception-ref)
* [E.16: Destructors, deallocation, and `swap` must never fail](#Re-never-fail)
* [E.17: Don't try to catch every exception in every function](#Re-not-always)
* [E.18: Minimize the use of explicit `try`/`catch`](#Re-catch)
* [E.19: Use a `final_action` object to express cleanup if no suitable resource handle is available](#Re-finally)

* [E.25: If you can't throw exceptions, simulate RAII for resource management](#Re-no-throw-raii)
* [E.26: If you can't throw exceptions, consider failing fast](#Re-no-throw-crash)
* [E.27: If you can't throw exceptions, use error codes systematically](#Re-no-throw-codes)
* [E.28: Avoid error handling based on global state (e.g. `errno`)](#Re-no-throw)

* [E.30: Don't use exception specifications](#Re-specifications)
* [E.31: Properly order your `catch`-clauses](#Re_catch)

### <a name="Re-design"></a>E.1: Develop an error-handling strategy early in a design

##### Reason

A consistent and complete strategy for handling errors and resource leaks is hard to retrofit into a system.

### <a name="Re-throw"></a>E.2: Throw an exception to signal that a function can't perform its assigned task

##### Reason

To make error handling systematic, robust, and non-repetitive.

##### Example

    struct Foo {
        vector<Thing> v;
        File_handle f;
        string s;
    };

    void use()
    {
        Foo bar {{Thing{1}, Thing{2}, Thing{monkey}}, {"my_file", "r"}, "Here we go!"};
        // ...
    }

Here, `vector` and `string`s constructors may not be able to allocate sufficient memory for their elements, `vector`s constructor may not be able copy the `Thing`s in its initializer list, and `File_handle` may not be able to open the required file.
In each case, they throw an exception for `use()`'s caller to handle.
If `use()` could handle the failure to construct `bar` it can take control using `try`/`catch`.
In either case, `Foo`'s constructor correctly destroys constructed members before passing control to whatever tried to create a `Foo`.
Note that there is no return value that could contain an error code.

The `File_handle` constructor might be defined like this:

    File_handle::File_handle(const string& name, const string& mode)
        :f{fopen(name.c_str(), mode.c_str())}
    {
        if (!f)
            throw runtime_error{"File_handle: could not open " + name + " as " + mode};
    }

##### Note

It is often said that exceptions are meant to signal exceptional events and failures.
However, that's a bit circular because "what is exceptional?"
Examples:

* A precondition that cannot be met
* A constructor that cannot construct an object (failure to establish its class's [invariant](#Rc-struct))
* An out-of-range error (e.g., `v[v.size()] = 7`)
* Inability to acquire a resource (e.g., the network is down)

In contrast, termination of an ordinary loop is not exceptional.
Unless the loop was meant to be infinite, termination is normal and expected.

##### Note

Don't use a `throw` as simply an alternative way of returning a value from a function.

##### Exception

Some systems, such as hard-real-time systems require a guarantee that an action is taken in a (typically short) constant maximum time known before execution starts. Such systems can use exceptions only if there is tool support for accurately predicting the maximum time to recover from a `throw`.

**See also**: [RAII](#Re-raii)

**See also**: [discussion](#Sd-noexcept)

##### Note

Before deciding that you cannot afford or don't like exception-based error handling, have a look at the [alternatives](#Re-no-throw-raii);
they have their own complexities and problems.
Also, as far as possible, measure before making claims about efficiency.

### <a name="Re-errors"></a>E.3: Use exceptions for error handling only

##### Reason

To keep error handling separated from "ordinary code."
C++ implementations tend to be optimized based on the assumption that exceptions are rare.

##### Example, don't

    // don't: exception not used for error handling
    int find_index(vector<string>& vec, const string& x)
    {
        try {
            for (gsl::index i = 0; i < vec.size(); ++i)
                if (vec[i] == x) throw i;  // found x
        } catch (int i) {
            return i;
        }
        return -1;   // not found
    }

This is more complicated and most likely runs much slower than the obvious alternative.
There is nothing exceptional about finding a value in a `vector`.

##### Enforcement

Would need to be heuristic.
Look for exception values "leaked" out of `catch` clauses.

### <a name="Re-design-invariants"></a>E.4: Design your error-handling strategy around invariants

##### Reason

To use an object it must be in a valid state (defined formally or informally by an invariant) and to recover from an error every object not destroyed must be in a valid state.

##### Note

An [invariant](#Rc-struct) is a logical condition for the members of an object that a constructor must establish for the public member functions to assume.

##### Enforcement

???

### <a name="Re-invariant"></a>E.5: Let a constructor establish an invariant, and throw if it cannot

##### Reason

Leaving an object without its invariant established is asking for trouble.
Not all member functions can be called.

##### Example

    class Vector {  // very simplified vector of doubles
        // if elem != nullptr then elem points to sz doubles
    public:
        Vector() : elem{nullptr}, sz{0}{}
        Vector(int s) : elem{new double[s]}, sz{s} { /* initialize elements */ }
        ~Vector() { delete [] elem; }
        double& operator[](int s) { return elem[s]; }
        // ...
    private:
        owner<double*> elem;
        int sz;
    };

The class invariant - here stated as a comment - is established by the constructors.
`new` throws if it cannot allocate the required memory.
The operators, notably the subscript operator, relies on the invariant.

**See also**: [If a constructor cannot construct a valid object, throw an exception](#Rc-throw)

##### Enforcement

Flag classes with `private` state without a constructor (public, protected, or private).

### <a name="Re-raii"></a>E.6: Use RAII to prevent leaks

##### Reason

Leaks are typically unacceptable.
Manual resource release is error-prone.
RAII ("Resource Acquisition Is Initialization") is the simplest, most systematic way of preventing leaks.

##### Example

    void f1(int i)   // Bad: possible leak
    {
        int* p = new int[12];
        // ...
        if (i < 17) throw Bad{"in f()", i};
        // ...
    }

We could carefully release the resource before the throw:

    void f2(int i)   // Clumsy and error-prone: explicit release
    {
        int* p = new int[12];
        // ...
        if (i < 17) {
            delete[] p;
            throw Bad{"in f()", i};
        }
        // ...
    }

This is verbose. In larger code with multiple possible `throw`s explicit releases become repetitive and error-prone.

    void f3(int i)   // OK: resource management done by a handle (but see below)
    {
        auto p = make_unique<int[]>(12);
        // ...
        if (i < 17) throw Bad{"in f()", i};
        // ...
    }

Note that this works even when the `throw` is implicit because it happened in a called function:

    void f4(int i)   // OK: resource management done by a handle (but see below)
    {
        auto p = make_unique<int[]>(12);
        // ...
        helper(i);   // may throw
        // ...
    }

Unless you really need pointer semantics, use a local resource object:

    void f5(int i)   // OK: resource management done by local object
    {
        vector<int> v(12);
        // ...
        helper(i);   // may throw
        // ...
    }

That's even simpler and safer, and often more efficient.

##### Note

If there is no obvious resource handle and for some reason defining a proper RAII object/handle is infeasible,
as a last resort, cleanup actions can be represented by a [`final_action`](#Re-finally) object.

##### Note

But what do we do if we are writing a program where exceptions cannot be used?
First challenge that assumption; there are many anti-exceptions myths around.
We know of only a few good reasons:

* We are on a system so small that the exception support would eat up most of our 2K memory.
* We are in a hard-real-time system and we don't have tools that guarantee us that an exception is handled within the required time.
* We are in a system with tons of legacy code using lots of pointers in difficult-to-understand ways
  (in particular without a recognizable ownership strategy) so that exceptions could cause leaks.
* Our implementation of the C++ exception mechanisms is unreasonably poor
(slow, memory consuming, failing to work correctly for dynamically linked libraries, etc.).
Complain to your implementation purveyor; if no user complains, no improvement will happen.
* We get fired if we challenge our manager's ancient wisdom.

Only the first of these reasons is fundamental, so whenever possible, use exceptions to implement RAII, or design your RAII objects to never fail.
When exceptions cannot be used, simulate RAII.
That is, systematically check that objects are valid after construction and still release all resources in the destructor.
One strategy is to add a `valid()` operation to every resource handle:

    void f()
    {
        vector<string> vs(100);   // not std::vector: valid() added
        if (!vs.valid()) {
            // handle error or exit
        }

        ifstream fs("foo");   // not std::ifstream: valid() added
        if (!fs.valid()) {
            // handle error or exit
        }

        // ...
    } // destructors clean up as usual

Obviously, this increases the size of the code, doesn't allow for implicit propagation of "exceptions" (`valid()` checks), and `valid()` checks can be forgotten.
Prefer to use exceptions.

**See also**: [Use of `noexcept`](#Re-noexcept)

##### Enforcement

???

### <a name="Re-precondition"></a>E.7: State your preconditions

##### Reason

To avoid interface errors.

**See also**: [precondition rule](#Ri-pre)

### <a name="Re-postcondition"></a>E.8: State your postconditions

##### Reason

To avoid interface errors.

**See also**: [postcondition rule](#Ri-post)

### <a name="Re-noexcept"></a>E.12: Use `noexcept` when exiting a function because of a `throw` is impossible or unacceptable

##### Reason

To make error handling systematic, robust, and efficient.

##### Example

    double compute(double d) noexcept
    {
        return log(sqrt(d <= 0 ? 1 : d));
    }

Here, we know that `compute` will not throw because it is composed out of operations that don't throw.
By declaring `compute` to be `noexcept`, we give the compiler and human readers information that can make it easier for them to understand and manipulate `compute`.

##### Note

Many standard-library functions are `noexcept` including all the standard-library functions "inherited" from the C Standard Library.

##### Example

    vector<double> munge(const vector<double>& v) noexcept
    {
        vector<double> v2(v.size());
        // ... do something ...
    }

The `noexcept` here states that I am not willing or able to handle the situation where I cannot construct the local `vector`.
That is, I consider memory exhaustion a serious design error (on par with hardware failures) so that I'm willing to crash the program if it happens.

##### Note

Do not use traditional [exception-specifications](#Re-specifications).

##### See also

[discussion](#Sd-noexcept).

### <a name="Re-never-throw"></a>E.13: Never throw while being the direct owner of an object

##### Reason

That would be a leak.

##### Example

    void leak(int x)   // don't: may leak
    {
        auto p = new int{7};
        if (x < 0) throw Get_me_out_of_here{};  // may leak *p
        // ...
        delete p;   // we may never get here
    }

One way of avoiding such problems is to use resource handles consistently:

    void no_leak(int x)
    {
        auto p = make_unique<int>(7);
        if (x < 0) throw Get_me_out_of_here{};  // will delete *p if necessary
        // ...
        // no need for delete p
    }

Another solution (often better) would be to use a local variable to eliminate explicit use of pointers:

    void no_leak_simplified(int x)
    {
        vector<int> v(7);
        // ...
    }

##### Note

If you have local "things" that requires cleanup, but is not represented by an object with a destructor, such cleanup must
also be done before a `throw`.
Sometimes, [`finally()`](#Re-finally) can make such unsystematic cleanup a bit more manageable.

### <a name="Re-exception-types"></a>E.14: Use purpose-designed user-defined types as exceptions (not built-in types)

##### Reason

A user-defined type is unlikely to clash with other people's exceptions.

##### Example

    void my_code()
    {
        // ...
        throw Moonphase_error{};
        // ...
    }

    void your_code()
    {
        try {
            // ...
            my_code();
            // ...
        }
        catch(const Bufferpool_exhausted&) {
            // ...
        }
    }

##### Example, don't

    void my_code()     // Don't
    {
        // ...
        throw 7;       // 7 means "moon in the 4th quarter"
        // ...
    }

    void your_code()   // Don't
    {
        try {
            // ...
            my_code();
            // ...
        }
        catch(int i) {  // i == 7 means "input buffer too small"
            // ...
        }
    }

##### Note

The standard-library classes derived from `exception` should be used only as base classes or for exceptions that require only "generic" handling. Like built-in types, their use could clash with other people's use of them.

##### Example, don't

    void my_code()   // Don't
    {
        // ...
        throw runtime_error{"moon in the 4th quarter"};
        // ...
    }

    void your_code()   // Don't
    {
        try {
            // ...
            my_code();
            // ...
        }
        catch(const runtime_error&) {   // runtime_error means "input buffer too small"
            // ...
        }
    }

**See also**: [Discussion](#Sd-???)

##### Enforcement

Catch `throw` and `catch` of a built-in type. Maybe warn about `throw` and `catch` using a standard-library `exception` type. Obviously, exceptions derived from the `std::exception` hierarchy are fine.

### <a name="Re-exception-ref"></a>E.15: Catch exceptions from a hierarchy by reference

##### Reason

To prevent slicing.

##### Example

    void f()
    {
        try {
            // ...
        }
        catch (exception e) {   // don't: may slice
            // ...
        }
    }

Instead, use a reference:

    catch (exception& e) { /* ... */ }

or - typically better still - a `const` reference:

    catch (const exception& e) { /* ... */ }

Most handlers do not modify their exception and in general we [recommend use of `const`](#Res-const).

##### Note

To rethrow a caught exception use `throw;` not `throw e;`. Using `throw e;` would throw a new copy of `e` (sliced to the static type `std::exception`) instead of rethrowing the original exception of type `std::runtime_error`. (But keep [Don't try to catch every exception in every function](#Re-not-always) and [Minimize the use of explicit `try`/`catch`](#Re-catch) in mind.)

##### Enforcement

Flag by-value exceptions if their types are part of a hierarchy (could require whole-program analysis to be perfect).

### <a name="Re-never-fail"></a>E.16: Destructors, deallocation, and `swap` must never fail

##### Reason

We don't know how to write reliable programs if a destructor, a swap, or a memory deallocation fails; that is, if it exits by an exception or simply doesn't perform its required action.

##### Example, don't

    class Connection {
        // ...
    public:
        ~Connection()   // Don't: very bad destructor
        {
            if (cannot_disconnect()) throw I_give_up{information};
            // ...
        }
    };

##### Note

Many have tried to write reliable code violating this rule for examples, such as a network connection that "refuses to close".
To the best of our knowledge nobody has found a general way of doing this.
Occasionally, for very specific examples, you can get away with setting some state for future cleanup.
For example, we might put a socket that does not want to close on a "bad socket" list,
to be examined by a regular sweep of the system state.
Every example we have seen of this is error-prone, specialized, and often buggy.

##### Note

The standard library assumes that destructors, deallocation functions (e.g., `operator delete`), and `swap` do not throw. If they do, basic standard-library invariants are broken.

##### Note

Deallocation functions, including `operator delete`, must be `noexcept`. `swap` functions must be `noexcept`.
Most destructors are implicitly `noexcept` by default.
Also, [make move operations `noexcept`](#Rc-move-noexcept).

##### Enforcement

Catch destructors, deallocation operations, and `swap`s that `throw`.
Catch such operations that are not `noexcept`.

**See also**: [discussion](#Sd-never-fail)

### <a name="Re-not-always"></a>E.17: Don't try to catch every exception in every function

##### Reason

Catching an exception in a function that cannot take a meaningful recovery action leads to complexity and waste.
Let an exception propagate until it reaches a function that can handle it.
Let cleanup actions on the unwinding path be handled by [RAII](#Re-raii).

##### Example, don't

    void f()   // bad
    {
        try {
            // ...
        }
        catch (...) {
            // no action
            throw;   // propagate exception
        }
    }

##### Enforcement

* Flag nested try-blocks.
* Flag source code files with a too high ratio of try-blocks to functions. (??? Problem: define "too high")

### <a name="Re-catch"></a>E.18: Minimize the use of explicit `try`/`catch`

##### Reason

 `try`/`catch` is verbose and non-trivial uses are error-prone.
 `try`/`catch` can be a sign of unsystematic and/or low-level resource management or error handling.

##### Example, Bad

    void f(zstring s)
    {
        Gadget* p;
        try {
            p = new Gadget(s);
            // ...
            delete p;
        }
        catch (Gadget_construction_failure) {
            delete p;
            throw;
        }
    }

This code is messy.
There could be a leak from the naked pointer in the `try` block.
Not all exceptions are handled.
`deleting` an object that failed to construct is almost certainly a mistake.
Better:

    void f2(zstring s)
    {
        Gadget g {s};
    }

##### Alternatives

* proper resource handles and [RAII](#Re-raii)
* [`finally`](#Re-finally)

##### Enforcement

??? hard, needs a heuristic

### <a name="Re-finally"></a>E.19: Use a `final_action` object to express cleanup if no suitable resource handle is available

##### Reason

`finally` is less verbose and harder to get wrong than `try`/`catch`.

##### Example

    void f(int n)
    {
        void* p = malloc(n);
        auto _ = finally([p] { free(p); });
        // ...
    }

##### Note

`finally` is not as messy as `try`/`catch`, but it is still ad-hoc.
Prefer [proper resource management objects](#Re-raii).
Consider `finally` a last resort.

##### Note

Use of `finally` is a systematic and reasonably clean alternative to the old [`goto exit;` technique](#Re-no-throw-codes)
for dealing with cleanup where resource management is not systematic.

##### Enforcement

Heuristic: Detect `goto exit;`

### <a name="Re-no-throw-raii"></a>E.25: If you can't throw exceptions, simulate RAII for resource management

##### Reason

Even without exceptions, [RAII](#Re-raii) is usually the best and most systematic way of dealing with resources.

##### Note

Error handling using exceptions is the only complete and systematic way of handling non-local errors in C++.
In particular, non-intrusively signaling failure to construct an object requires an exception.
Signaling errors in a way that cannot be ignored requires exceptions.
If you can't use exceptions, simulate their use as best you can.

A lot of fear of exceptions is misguided.
When used for exceptional circumstances in code that is not littered with pointers and complicated control structures,
exception handling is almost always affordable (in time and space) and almost always leads to better code.
This, of course, assumes a good implementation of the exception handling mechanisms, which is not available on all systems.
There are also cases where the problems above do not apply, but exceptions cannot be used for other reasons.
Some hard-real-time systems are an example: An operation has to be completed within a fixed time with an error or a correct answer.
In the absence of appropriate time estimation tools, this is hard to guarantee for exceptions.
Such systems (e.g. flight control software) typically also ban the use of dynamic (heap) memory.

So, the primary guideline for error handling is "use exceptions and [RAII](#Re-raii)."
This section deals with the cases where you either do not have an efficient implementation of exceptions,
or have such a rat's nest of old-style code
(e.g., lots of pointers, ill-defined ownership, and lots of unsystematic error handling based on tests of error codes)
that it is infeasible to introduce simple and systematic exception handling.

Before condemning exceptions or complaining too much about their cost, consider examples of the use of [error codes](#Re-no-throw-codes).
Consider the cost and complexity of the use of error codes.
If performance is your worry, measure.

##### Example

Assume you wanted to write

    void func(zstring arg)
    {
        Gadget g {arg};
        // ...
    }

If the `gadget` isn't correctly constructed, `func` exits with an exception.
If we cannot throw an exception, we can simulate this RAII style of resource handling by adding a `valid()` member function to `Gadget`:

    error_indicator func(zstring arg)
    {
        Gadget g {arg};
        if (!g.valid()) return gadget_construction_error;
        // ...
        return 0;   // zero indicates "good"
    }

The problem is of course that the caller now has to remember to test the return value.

**See also**: [Discussion](#Sd-???)

##### Enforcement

Possible (only) for specific versions of this idea: e.g., test for systematic test of `valid()` after resource handle construction

### <a name="Re-no-throw-crash"></a>E.26: If you can't throw exceptions, consider failing fast

##### Reason

If you can't do a good job at recovering, at least you can get out before too much consequential damage is done.

**See also**: [Simulating RAII](#Re-no-throw-raii)

##### Note

If you cannot be systematic about error handling, consider "crashing" as a response to any error that cannot be handled locally.
That is, if you cannot recover from an error in the context of the function that detected it, call `abort()`, `quick_exit()`,
or a similar function that will trigger some sort of system restart.

In systems where you have lots of processes and/or lots of computers, you need to expect and handle fatal crashes anyway,
say from hardware failures.
In such cases, "crashing" is simply leaving error handling to the next level of the system.

##### Example

    void f(int n)
    {
        // ...
        p = static_cast<X*>(malloc(n * sizeof(X)));
        if (!p) abort();     // abort if memory is exhausted
        // ...
    }

Most programs cannot handle memory exhaustion gracefully anyway. This is roughly equivalent to

    void f(int n)
    {
        // ...
        p = new X[n];    // throw if memory is exhausted (by default, terminate)
        // ...
    }

Typically, it is a good idea to log the reason for the "crash" before exiting.

##### Enforcement

Awkward

### <a name="Re-no-throw-codes"></a>E.27: If you can't throw exceptions, use error codes systematically

##### Reason

Systematic use of any error-handling strategy minimizes the chance of forgetting to handle an error.

**See also**: [Simulating RAII](#Re-no-throw-raii)

##### Note

There are several issues to be addressed:

* How do you transmit an error indicator from out of a function?
* How do you release all resources from a function before doing an error exit?
* What do you use as an error indicator?

In general, returning an error indicator implies returning two values: The result and an error indicator.
The error indicator can be part of the object, e.g. an object can have a `valid()` indicator
or a pair of values can be returned.

##### Example

    Gadget make_gadget(int n)
    {
        // ...
    }

    void user()
    {
        Gadget g = make_gadget(17);
        if (!g.valid()) {
                // error handling
        }
        // ...
    }

This approach fits with [simulated RAII resource management](#Re-no-throw-raii).
The `valid()` function could return an `error_indicator` (e.g. a member of an `error_indicator` enumeration).

##### Example

What if we cannot or do not want to modify the `Gadget` type?
In that case, we must return a pair of values.
For example:

    std::pair<Gadget, error_indicator> make_gadget(int n)
    {
        // ...
    }

    void user()
    {
        auto r = make_gadget(17);
        if (!r.second) {
                // error handling
        }
        Gadget& g = r.first;
        // ...
    }

As shown, `std::pair` is a possible return type.
Some people prefer a specific type.
For example:

    Gval make_gadget(int n)
    {
        // ...
    }

    void user()
    {
        auto r = make_gadget(17);
        if (!r.err) {
                // error handling
        }
        Gadget& g = r.val;
        // ...
    }

One reason to prefer a specific return type is to have names for its members, rather than the somewhat cryptic `first` and `second`
and to avoid confusion with other uses of `std::pair`.

##### Example

In general, you must clean up before an error exit.
This can be messy:

    std::pair<int, error_indicator> user()
    {
        Gadget g1 = make_gadget(17);
        if (!g1.valid()) {
                return {0, g1_error};
        }

        Gadget g2 = make_gadget(17);
        if (!g2.valid()) {
                cleanup(g1);
                return {0, g2_error};
        }

        // ...

        if (all_foobar(g1, g2)) {
            cleanup(g1);
            cleanup(g2);
            return {0, foobar_error};
        // ...

        cleanup(g1);
        cleanup(g2);
        return {res, 0};
    }

Simulating RAII can be non-trivial, especially in functions with multiple resources and multiple possible errors.
A not uncommon technique is to gather cleanup at the end of the function to avoid repetition (note the extra scope around `g2` is undesirable but necessary to make the `goto` version compile):

    std::pair<int, error_indicator> user()
    {
        error_indicator err = 0;

        Gadget g1 = make_gadget(17);
        if (!g1.valid()) {
                err = g1_error;
                goto exit;
        }

        {
        Gadget g2 = make_gadget(17);
        if (!g2.valid()) {
                err = g2_error;
                goto exit;
        }

        if (all_foobar(g1, g2)) {
            err = foobar_error;
            goto exit;
        }
        // ...
        }

    exit:
      if (g1.valid()) cleanup(g1);
      if (g2.valid()) cleanup(g2);
      return {res, err};
    }

The larger the function, the more tempting this technique becomes.
`finally` can [ease the pain a bit](#Re-finally).
Also, the larger the program becomes the harder it is to apply an error-indicator-based error-handling strategy systematically.

We [prefer exception-based error handling](#Re-throw) and recommend [keeping functions short](#Rf-single).

**See also**: [Discussion](#Sd-???)

**See also**: [Returning multiple values](#Rf-out-multi)

##### Enforcement

Awkward.

### <a name="Re-no-throw"></a>E.28: Avoid error handling based on global state (e.g. `errno`)

##### Reason

Global state is hard to manage and it is easy to forget to check it.
When did you last test the return value of `printf()`?

**See also**: [Simulating RAII](#Re-no-throw-raii)

##### Example, bad

    int last_err;

    void f(int n)
    {
        // ...
        p = static_cast<X*>(malloc(n * sizeof(X)));
        if (!p) last_err = -1;     // error if memory is exhausted
        // ...
    }

##### Note

C-style error handling is based on the global variable `errno`, so it is essentially impossible to avoid this style completely.

##### Enforcement

Awkward.


### <a name="Re-specifications"></a>E.30: Don't use exception specifications

##### Reason

Exception specifications make error handling brittle, impose a run-time cost, and have been removed from the C++ standard.

##### Example

    int use(int arg)
        throw(X, Y)
    {
        // ...
        auto x = f(arg);
        // ...
    }

If `f()` throws an exception different from `X` and `Y` the unexpected handler is invoked, which by default terminates.
That's OK, but say that we have checked that this cannot happen and `f` is changed to throw a new exception `Z`,
we now have a crash on our hands unless we change `use()` (and re-test everything).
The snag is that `f()` may be in a library we do not control and the new exception is not anything that `use()` can do
anything about or is in any way interested in.
We can change `use()` to pass `Z` through, but now `use()`'s callers probably needs to be modified.
This quickly becomes unmanageable.
Alternatively, we can add a `try`-`catch` to `use()` to map `Z` into an acceptable exception.
This too, quickly becomes unmanageable.
Note that changes to the set of exceptions often happens at the lowest level of a system
(e.g., because of changes to a network library or some middleware), so changes "bubble up" through long call chains.
In a large code base, this could mean that nobody could update to a new version of a library until the last user was modified.
If `use()` is part of a library, it may not be possible to update it because a change could affect unknown clients.

The policy of letting exceptions propagate until they reach a function that potentially can handle it has proven itself over the years.

##### Note

No. This would not be any better had exception specifications been statically enforced.
For example, see [Stroustrup94](#Stroustrup94).

##### Note

If no exception may be thrown, use [`noexcept`](#Re-noexcept) or its equivalent `throw()`.

##### Enforcement

Flag every exception specification.

### <a name="Re_catch"></a>E.31: Properly order your `catch`-clauses

##### Reason

`catch`-clauses are evaluated in the order they appear and one clause can hide another.

##### Example

    void f()
    {
        // ...
        try {
                // ...
        }
        catch (Base& b) { /* ... */ }
        catch (Derived& d) { /* ... */ }
        catch (...) { /* ... */ }
        catch (std::exception& e){ /* ... */ }
    }

If `Derived`is derived from `Base` the `Derived`-handler will never be invoked.
The "catch everything" handler ensured that the `std::exception`-handler will never be invoked.

##### Enforcement

Flag all "hiding handlers".

# <a name="S-const"></a>Con: Constants and immutability

You can't have a race condition on a constant.
It is easier to reason about a program when many of the objects cannot change their values.
Interfaces that promises "no change" of objects passed as arguments greatly increase readability.

Constant rule summary:

* [Con.1: By default, make objects immutable](#Rconst-immutable)
* [Con.2: By default, make member functions `const`](#Rconst-fct)
* [Con.3: By default, pass pointers and references to `const`s](#Rconst-ref)
* [Con.4: Use `const` to define objects with values that do not change after construction](#Rconst-const)
* [Con.5: Use `constexpr` for values that can be computed at compile time](#Rconst-constexpr)

### <a name="Rconst-immutable"></a>Con.1: By default, make objects immutable

##### Reason

Immutable objects are easier to reason about, so make objects non-`const` only when there is a need to change their value.
Prevents accidental or hard-to-notice change of value.

##### Example

    for (const int i : c) cout << i << '\n';    // just reading: const

    for (int i : c) cout << i << '\n';          // BAD: just reading

##### Exception

Function arguments are rarely mutated, but also rarely declared const.
To avoid confusion and lots of false positives, don't enforce this rule for function arguments.

    void f(const char* const p); // pedantic
    void g(const int i);        // pedantic

Note that function parameter is a local variable so changes to it are local.

##### Enforcement

* Flag non-`const` variables that are not modified (except for parameters to avoid many false positives)

### <a name="Rconst-fct"></a>Con.2: By default, make member functions `const`

##### Reason

A member function should be marked `const` unless it changes the object's observable state.
This gives a more precise statement of design intent, better readability, more errors caught by the compiler, and sometimes more optimization opportunities.

##### Example, bad

    class Point {
        int x, y;
    public:
        int getx() { return x; }    // BAD, should be const as it doesn't modify the object's state
        // ...
    };

    void f(const Point& pt) {
        int x = pt.getx();          // ERROR, doesn't compile because getx was not marked const
    }

##### Note

It is not inherently bad to pass a pointer or reference to non-`const`,
but that should be done only when the called function is supposed to modify the object.
A reader of code must assume that a function that takes a "plain" `T*` or `T&` will modify the object referred to.
If it doesn't now, it might do so later without forcing recompilation.

##### Note

There are code/libraries that offer functions that declare a`T*` even though
those function do not modify that `T`.
This is a problem for people modernizing code.
You can

* update the library to be `const`-correct; preferred long-term solution
* "cast away `const`"; [best avoided](#Res-casts-const)
* provide a wrapper function

Example:

    void f(int* p);   // old code: f() does not modify `*p`
    void f(const int* p) { f(const_cast<int*>(p)); } // wrapper

Note that this wrapper solution is a patch that should be used only when the declaration of `f()` cannot be modified,
e.g. because it is in a library that you cannot modify.

##### Note

A `const` member function can modify the value of an object that is `mutable` or accessed through a pointer member.
A common use is to maintain a cache rather than repeatedly do a complicated computation.
For example, here is a `Date` that caches (memoizes) its string representation to simplify repeated uses:

    class Date {
    public:
        // ...
        const string& string_ref() const
        {
            if (string_val == "") compute_string_rep();
            return string_val;
        }
        // ...
    private:
        void compute_string_rep() const;    // compute string representation and place it in string_val
        mutable string string_val;
        // ...
    };

Another way of saying this is that `const`ness is not transitive.
It is possible for a `const` member function to change the value of `mutable` members and the value of objects accessed
through non-`const` pointers.
It is the job of the class to ensure such mutation is done only when it makes sense according to the semantics (invariants)
it offers to its users.

**See also**: [Pimpl](#Ri-pimpl)

##### Enforcement

* Flag a member function that is not marked `const`, but that does not perform a non-`const` operation on any member variable.

### <a name="Rconst-ref"></a>Con.3: By default, pass pointers and references to `const`s

##### Reason

 To avoid a called function unexpectedly changing the value.
 It's far easier to reason about programs when called functions don't modify state.

##### Example

    void f(char* p);        // does f modify *p? (assume it does)
    void g(const char* p);  // g does not modify *p

##### Note

It is not inherently bad to pass a pointer or reference to non-`const`,
but that should be done only when the called function is supposed to modify the object.

##### Note

[Do not cast away `const`](#Res-casts-const).

##### Enforcement

* Flag function that does not modify an object passed by  pointer or reference to non-`const`
* Flag a function that (using a cast) modifies an object passed by pointer or reference to `const`

### <a name="Rconst-const"></a>Con.4: Use `const` to define objects with values that do not change after construction

##### Reason

 Prevent surprises from unexpectedly changed object values.

##### Example

    void f()
    {
        int x = 7;
        const int y = 9;

        for (;;) {
            // ...
        }
        // ...
    }

As `x` is not `const`, we must assume that it is modified somewhere in the loop.

##### Enforcement

* Flag unmodified non-`const` variables.

### <a name="Rconst-constexpr"></a>Con.5: Use `constexpr` for values that can be computed at compile time

##### Reason

Better performance, better compile-time checking, guaranteed compile-time evaluation, no possibility of race conditions.

##### Example

    double x = f(2);            // possible run-time evaluation
    const double y = f(2);      // possible run-time evaluation
    constexpr double z = f(2);  // error unless f(2) can be evaluated at compile time

##### Note

See F.4.

##### Enforcement

* Flag `const` definitions with constant expression initializers.

# <a name="S-templates"></a>T: Templates and generic programming

Generic programming is programming using types and algorithms parameterized by types, values, and algorithms.
In C++, generic programming is supported by the `template` language mechanisms.

Arguments to generic functions are characterized by sets of requirements on the argument types and values involved.
In C++, these requirements are expressed by compile-time predicates called concepts.

Templates can also be used for meta-programming; that is, programs that compose code at compile time.

A central notion in generic programming is "concepts"; that is, requirements on template arguments presented as compile-time predicates.
"Concepts" are defined in an ISO Technical Specification: [concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf).
A draft of a set of standard-library concepts can be found in another ISO TS: [ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf)
Concepts are supported in GCC 6.1 and later.
Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only.
If you use GCC 6.1 or later, you can uncomment them.

Template use rule summary:

* [T.1: Use templates to raise the level of abstraction of code](#Rt-raise)
* [T.2: Use templates to express algorithms that apply to many argument types](#Rt-algo)
* [T.3: Use templates to express containers and ranges](#Rt-cont)
* [T.4: Use templates to express syntax tree manipulation](#Rt-expr)
* [T.5: Combine generic and OO techniques to amplify their strengths, not their costs](#Rt-generic-oo)

Concept use rule summary:

* [T.10: Specify concepts for all template arguments](#Rt-concepts)
* [T.11: Whenever possible use standard concepts](#Rt-std-concepts)
* [T.12: Prefer concept names over `auto` for local variables](#Rt-auto)
* [T.13: Prefer the shorthand notation for simple, single-type argument concepts](#Rt-shorthand)
* ???

Concept definition rule summary:

* [T.20: Avoid "concepts" without meaningful semantics](#Rt-low)
* [T.21: Require a complete set of operations for a concept](#Rt-complete)
* [T.22: Specify axioms for concepts](#Rt-axiom)
* [T.23: Differentiate a refined concept from its more general case by adding new use patterns](#Rt-refine)
* [T.24: Use tag classes or traits to differentiate concepts that differ only in semantics](#Rt-tag)
* [T.25: Avoid complementary constraints](#Rt-not)
* [T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax](#Rt-use)
* [T.30: Use concept negation (`!C<T>`) sparingly to express a minor difference](#Rt-not)
* [T.31: Use concept disjunction (`C1<T> || C2<T>`) sparingly to express alternatives](#Rt-or)
* ???

Template interface rule summary:

* [T.40: Use function objects to pass operations to algorithms](#Rt-fo)
* [T.41: Require only essential properties in a template's concepts](#Rt-essential)
* [T.42: Use template aliases to simplify notation and hide implementation details](#Rt-alias)
* [T.43: Prefer `using` over `typedef` for defining aliases](#Rt-using)
* [T.44: Use function templates to deduce class template argument types (where feasible)](#Rt-deduce)
* [T.46: Require template arguments to be at least `Regular` or `SemiRegular`](#Rt-regular)
* [T.47: Avoid highly visible unconstrained templates with common names](#Rt-visible)
* [T.48: If your compiler does not support concepts, fake them with `enable_if`](#Rt-concept-def)
* [T.49: Where possible, avoid type-erasure](#Rt-erasure)

Template definition rule summary:

* [T.60: Minimize a template's context dependencies](#Rt-depend)
* [T.61: Do not over-parameterize members (SCARY)](#Rt-scary)
* [T.62: Place non-dependent class template members in a non-templated base class](#Rt-nondependent)
* [T.64: Use specialization to provide alternative implementations of class templates](#Rt-specialization)
* [T.65: Use tag dispatch to provide alternative implementations of functions](#Rt-tag-dispatch)
* [T.67: Use specialization to provide alternative implementations for irregular types](#Rt-specialization2)
* [T.68: Use `{}` rather than `()` within templates to avoid ambiguities](#Rt-cast)
* [T.69: Inside a template, don't make an unqualified nonmember function call unless you intend it to be a customization point](#Rt-customization)

Template and hierarchy rule summary:

* [T.80: Do not naively templatize a class hierarchy](#Rt-hier)
* [T.81: Do not mix hierarchies and arrays](#Rt-array) // ??? somewhere in "hierarchies"
* [T.82: Linearize a hierarchy when virtual functions are undesirable](#Rt-linear)
* [T.83: Do not declare a member function template virtual](#Rt-virtual)
* [T.84: Use a non-template core implementation to provide an ABI-stable interface](#Rt-abi)
* [T.??: ????](#Rt-???)

Variadic template rule summary:

* [T.100: Use variadic templates when you need a function that takes a variable number of arguments of a variety of types](#Rt-variadic)
* [T.101: ??? How to pass arguments to a variadic template ???](#Rt-variadic-pass)
* [T.102: ??? How to process arguments to a variadic template ???](#Rt-variadic-process)
* [T.103: Don't use variadic templates for homogeneous argument lists](#Rt-variadic-not)
* [T.??: ????](#Rt-???)

Metaprogramming rule summary:

* [T.120: Use template metaprogramming only when you really need to](#Rt-metameta)
* [T.121: Use template metaprogramming primarily to emulate concepts](#Rt-emulate)
* [T.122: Use templates (usually template aliases) to compute types at compile time](#Rt-tmp)
* [T.123: Use `constexpr` functions to compute values at compile time](#Rt-fct)
* [T.124: Prefer to use standard-library TMP facilities](#Rt-std-tmp)
* [T.125: If you need to go beyond the standard-library TMP facilities, use an existing library](#Rt-lib)
* [T.??: ????](#Rt-???)

Other template rules summary:

* [T.140: Name all operations with potential for reuse](#Rt-name)
* [T.141: Use an unnamed lambda if you need a simple function object in one place only](#Rt-lambda)
* [T.142: Use template variables to simplify notation](#Rt-var)
* [T.143: Don't write unintentionally nongeneric code](#Rt-nongeneric)
* [T.144: Don't specialize function templates](#Rt-specialize-function)
* [T.150: Check that a class matches a concept using `static_assert`](#Rt-check-class)
* [T.??: ????](#Rt-???)

## <a name="SS-GP"></a>T.gp: Generic programming

Generic programming is programming using types and algorithms parameterized by types, values, and algorithms.

### <a name="Rt-raise"></a>T.1: Use templates to raise the level of abstraction of code

##### Reason

Generality. Reuse. Efficiency. Encourages consistent definition of user types.

##### Example, bad

Conceptually, the following requirements are wrong because what we want of `T` is more than just the very low-level concepts of "can be incremented" or "can be added":

    template<typename T>
        // requires Incrementable<T>
    T sum1(vector<T>& v, T s)
    {
        for (auto x : v) s += x;
        return s;
    }

    template<typename T>
        // requires Simple_number<T>
    T sum2(vector<T>& v, T s)
    {
        for (auto x : v) s = s + x;
        return s;
    }

Assuming that `Incrementable` does not support `+` and `Simple_number` does not support `+=`, we have overconstrained implementers of `sum1` and `sum2`.
And, in this case, missed an opportunity for a generalization.

##### Example

    template<typename T>
        // requires Arithmetic<T>
    T sum(vector<T>& v, T s)
    {
        for (auto x : v) s += x;
        return s;
    }

Assuming that `Arithmetic` requires both `+` and `+=`, we have constrained the user of `sum` to provide a complete arithmetic type.
That is not a minimal requirement, but it gives the implementer of algorithms much needed freedom and ensures that any `Arithmetic` type
can be used for a wide variety of algorithms.

For additional generality and reusability, we could also use a more general `Container` or `Range` concept instead of committing to only one container, `vector`.

##### Note

If we define a template to require exactly the operations required for a single implementation of a single algorithm
(e.g., requiring just `+=` rather than also `=` and `+`) and only those, we have overconstrained maintainers.
We aim to minimize requirements on template arguments, but the absolutely minimal requirements of an implementation is rarely a meaningful concept.

##### Note

Templates can be used to express essentially everything (they are Turing complete), but the aim of generic programming (as expressed using templates)
is to efficiently generalize operations/algorithms over a set of types with similar semantic properties.

##### Note

The `requires` in the comments are uses of `concepts`.
"Concepts" are defined in an ISO Technical Specification: [concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf).
Concepts are supported in GCC 6.1 and later.
Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only.
If you use GCC 6.1 or later, you can uncomment them.

##### Enforcement

* Flag algorithms with "overly simple" requirements, such as direct use of specific operators without a concept.
* Do not flag the definition of the "overly simple" concepts themselves; they may simply be building blocks for more useful concepts.

### <a name="Rt-algo"></a>T.2: Use templates to express algorithms that apply to many argument types

##### Reason

Generality. Minimizing the amount of source code. Interoperability. Reuse.

##### Example

That's the foundation of the STL. A single `find` algorithm easily works with any kind of input range:

    template<typename Iter, typename Val>
        // requires Input_iterator<Iter>
        //       && Equality_comparable<Value_type<Iter>, Val>
    Iter find(Iter b, Iter e, Val v)
    {
        // ...
    }

##### Note

Don't use a template unless you have a realistic need for more than one template argument type.
Don't overabstract.

##### Enforcement

??? tough, probably needs a human

### <a name="Rt-cont"></a>T.3: Use templates to express containers and ranges

##### Reason

Containers need an element type, and expressing that as a template argument is general, reusable, and type safe.
It also avoids brittle or inefficient workarounds. Convention: That's the way the STL does it.

##### Example

    template<typename T>
        // requires Regular<T>
    class Vector {
        // ...
        T* elem;   // points to sz Ts
        int sz;
    };

    Vector<double> v(10);
    v[7] = 9.9;

##### Example, bad

    class Container {
        // ...
        void* elem;   // points to size elements of some type
        int sz;
    };

    Container c(10, sizeof(double));
    ((double*) c.elem)[7] = 9.9;

This doesn't directly express the intent of the programmer and hides the structure of the program from the type system and optimizer.

Hiding the `void*` behind macros simply obscures the problems and introduces new opportunities for confusion.

**Exceptions**: If you need an ABI-stable interface, you might have to provide a base implementation and express the (type-safe) template in terms of that.
See [Stable base](#Rt-abi).

##### Enforcement

* Flag uses of `void*`s and casts outside low-level implementation code

### <a name="Rt-expr"></a>T.4: Use templates to express syntax tree manipulation

##### Reason

 ???

##### Example

    ???

**Exceptions**: ???

### <a name="Rt-generic-oo"></a>T.5: Combine generic and OO techniques to amplify their strengths, not their costs

##### Reason

Generic and OO techniques are complementary.

##### Example

Static helps dynamic: Use static polymorphism to implement dynamically polymorphic interfaces.

    class Command {
        // pure virtual functions
    };

    // implementations
    template</*...*/>
    class ConcreteCommand : public Command {
        // implement virtuals
    };

##### Example

Dynamic helps static: Offer a generic, comfortable, statically bound interface, but internally dispatch dynamically, so you offer a uniform object layout.
Examples include type erasure as with `std::shared_ptr`'s deleter (but [don't overuse type erasure](#Rt-erasure)).

##### Note

In a class template, nonvirtual functions are only instantiated if they're used -- but virtual functions are instantiated every time.
This can bloat code size, and may overconstrain a generic type by instantiating functionality that is never needed.
Avoid this, even though the standard-library facets made this mistake.

##### See also

* ref ???
* ref ???
* ref ???

##### Enforcement

See the reference to more specific rules.

## <a name="SS-concepts"></a>T.concepts: Concept rules

Concepts is a facility for specifying requirements for template arguments.
It is an [ISO Technical Specification](#Ref-conceptsTS), but currently supported only by GCC.
Concepts are, however, crucial in the thinking about generic programming and the basis of much work on future C++ libraries
(standard and other).

This section assumes concept support

Concept use rule summary:

* [T.10: Specify concepts for all template arguments](#Rt-concepts)
* [T.11: Whenever possible use standard concepts](#Rt-std-concepts)
* [T.12: Prefer concept names over `auto`](#Rt-auto)
* [T.13: Prefer the shorthand notation for simple, single-type argument concepts](#Rt-shorthand)
* ???

Concept definition rule summary:

* [T.20: Avoid "concepts" without meaningful semantics](#Rt-low)
* [T.21: Require a complete set of operations for a concept](#Rt-complete)
* [T.22: Specify axioms for concepts](#Rt-axiom)
* [T.23: Differentiate a refined concept from its more general case by adding new use patterns](#Rt-refine)
* [T.24: Use tag classes or traits to differentiate concepts that differ only in semantics](#Rt-tag)
* [T.25: Avoid complimentary constraints](#Rt-not)
* [T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax](#Rt-use)
* ???

## <a name="SS-concept-use"></a>T.con-use: Concept use

### <a name="Rt-concepts"></a>T.10: Specify concepts for all template arguments

##### Reason

Correctness and readability.
The assumed meaning (syntax and semantics) of a template argument is fundamental to the interface of a template.
A concept dramatically improves documentation and error handling for the template.
Specifying concepts for template arguments is a powerful design tool.

##### Example

    template<typename Iter, typename Val>
    //    requires Input_iterator<Iter>
    //             && Equality_comparable<Value_type<Iter>, Val>
    Iter find(Iter b, Iter e, Val v)
    {
        // ...
    }

or equivalently and more succinctly:

    template<Input_iterator Iter, typename Val>
    //    requires Equality_comparable<Value_type<Iter>, Val>
    Iter find(Iter b, Iter e, Val v)
    {
        // ...
    }

##### Note

"Concepts" are defined in an ISO Technical Specification: [concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf).
A draft of a set of standard-library concepts can be found in another ISO TS: [ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf)
Concepts are supported in GCC 6.1 and later.
Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only.
If you use GCC 6.1 or later, you can uncomment them:

    template<typename Iter, typename Val>
        requires Input_iterator<Iter>
               && Equality_comparable<Value_type<Iter>, Val>
    Iter find(Iter b, Iter e, Val v)
    {
        // ...
    }

##### Note

Plain `typename` (or `auto`) is the least constraining concept.
It should be used only rarely when nothing more than "it's a type" can be assumed.
This is typically only needed when (as part of template metaprogramming code) we manipulate pure expression trees, postponing type checking.

**References**: TC++PL4, Palo Alto TR, Sutton

##### Enforcement

Flag template type arguments without concepts

### <a name="Rt-std-concepts"></a>T.11: Whenever possible use standard concepts

##### Reason

 "Standard" concepts (as provided by the [GSL](#S-GSL) and the [Ranges TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf), and hopefully soon the ISO standard itself)
save us the work of thinking up our own concepts, are better thought out than we can manage to do in a hurry, and improve interoperability.

##### Note

Unless you are creating a new generic library, most of the concepts you need will already be defined by the standard library.

##### Example (using TS concepts)

    template<typename T>
        // don't define this: Sortable is in the GSL
    concept Ordered_container = Sequence<T> && Random_access<Iterator<T>> && Ordered<Value_type<T>>;

    void sort(Ordered_container& s);

This `Ordered_container` is quite plausible, but it is very similar to the `Sortable` concept in the GSL (and the Range TS).
Is it better? Is it right? Does it accurately reflect the standard's requirements for `sort`?
It is better and simpler just to use `Sortable`:

    void sort(Sortable& s);   // better

##### Note

The set of "standard" concepts is evolving as we approach an ISO standard including concepts.

##### Note

Designing a useful concept is challenging.

##### Enforcement

Hard.

* Look for unconstrained arguments, templates that use "unusual"/non-standard concepts, templates that use "homebrew" concepts without axioms.
* Develop a concept-discovery tool (e.g., see [an early experiment](http://www.stroustrup.com/sle2010_webversion.pdf)).

### <a name="Rt-auto"></a>T.12: Prefer concept names over `auto` for local variables

##### Reason

 `auto` is the weakest concept. Concept names convey more meaning than just `auto`.

##### Example (using TS concepts)

    vector<string> v{ "abc", "xyz" };
    auto& x = v.front();     // bad
    String& s = v.front();   // good (String is a GSL concept)

##### Enforcement

* ???

### <a name="Rt-shorthand"></a>T.13: Prefer the shorthand notation for simple, single-type argument concepts

##### Reason

Readability. Direct expression of an idea.

##### Example (using TS concepts)

To say "`T` is `Sortable`":

    template<typename T>       // Correct but verbose: "The parameter is
    //    requires Sortable<T>   // of type T which is the name of a type
    void sort(T&);             // that is Sortable"

    template<Sortable T>       // Better (assuming support for concepts): "The parameter is of type T
    void sort(T&);             // which is Sortable"

    void sort(Sortable&);      // Best (assuming support for concepts): "The parameter is Sortable"

The shorter versions better match the way we speak. Note that many templates don't need to use the `template` keyword.

##### Note

"Concepts" are defined in an ISO Technical Specification: [concepts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf).
A draft of a set of standard-library concepts can be found in another ISO TS: [ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf)
Concepts are supported in GCC 6.1 and later.
Consequently, we comment out uses of concepts in examples; that is, we use them as formalized comments only.
If you use a compiler that supports concepts (e.g., GCC 6.1 or later), you can remove the `//`.

##### Enforcement

* Not feasible in the short term when people convert from the `<typename T>` and `<class T`> notation.
* Later, flag declarations that first introduce a typename and then constrain it with a simple, single-type-argument concept.

## <a name="SS-concepts-def"></a>T.concepts.def: Concept definition rules

Defining good concepts is non-trivial.
Concepts are meant to represent fundamental concepts in an application domain (hence the name "concepts").
Similarly throwing together a set of syntactic constraints to be used for the arguments for a single class or algorithm is not what concepts were designed for
and will not give the full benefits of the mechanism.

Obviously, defining concepts will be most useful for code that can use an implementation (e.g., GCC 6.1 or later),
but defining concepts is in itself a useful design technique and help catch conceptual errors and clean up the concepts (sic!) of an implementation.

### <a name="Rt-low"></a>T.20: Avoid "concepts" without meaningful semantics

##### Reason

Concepts are meant to express semantic notions, such as "a number", "a range" of elements, and "totally ordered."
Simple constraints, such as "has a `+` operator" and "has a `>` operator" cannot be meaningfully specified in isolation
and should be used only as building blocks for meaningful concepts, rather than in user code.

##### Example, bad (using TS concepts)

    template<typename T>
    concept Addable = has_plus<T>;    // bad; insufficient

    template<Addable N> auto algo(const N& a, const N& b) // use two numbers
    {
        // ...
        return a + b;
    }

    int x = 7;
    int y = 9;
    auto z = algo(x, y);   // z = 16

    string xx = "7";
    string yy = "9";
    auto zz = algo(xx, yy);   // zz = "79"

Maybe the concatenation was expected. More likely, it was an accident. Defining minus equivalently would give dramatically different sets of accepted types.
This `Addable` violates the mathematical rule that addition is supposed to be commutative: `a+b == b+a`.

##### Note

The ability to specify a meaningful semantics is a defining characteristic of a true concept, as opposed to a syntactic constraint.

##### Example (using TS concepts)

    template<typename T>
    // The operators +, -, *, and / for a number are assumed to follow the usual mathematical rules
    concept Number = has_plus<T>
                     && has_minus<T>
                     && has_multiply<T>
                     && has_divide<T>;

    template<Number N> auto algo(const N& a, const N& b)
    {
        // ...
        return a + b;
    }

    int x = 7;
    int y = 9;
    auto z = algo(x, y);   // z = 16

    string xx = "7";
    string yy = "9";
    auto zz = algo(xx, yy);   // error: string is not a Number

##### Note

Concepts with multiple operations have far lower chance of accidentally matching a type than a single-operation concept.

##### Enforcement

* Flag single-operation `concepts` when used outside the definition of other `concepts`.
* Flag uses of `enable_if` that appears to simulate single-operation `concepts`.


### <a name="Rt-complete"></a>T.21: Require a complete set of operations for a concept

##### Reason

Ease of comprehension.
Improved interoperability.
Helps implementers and maintainers.

##### Note

This is a specific variant of the general rule that [a concept must make semantic sense](#Rt-low).

##### Example, bad (using TS concepts)

    template<typename T> concept Subtractable = requires(T a, T, b) { a-b; };

This makes no semantic sense.
You need at least `+` to make `-` meaningful and useful.

Examples of complete sets are

* `Arithmetic`: `+`, `-`, `*`, `/`, `+=`, `-=`, `*=`, `/=`
* `Comparable`: `<`, `>`, `<=`, `>=`, `==`, `!=`

##### Note

This rule applies whether we use direct language support for concepts or not.
It is a general design rule that even applies to non-templates:

    class Minimal {
        // ...
    };

    bool operator==(const Minimal&, const Minimal&);
    bool operator<(const Minimal&, const Minimal&);

    Minimal operator+(const Minimal&, const Minimal&);
    // no other operators

    void f(const Minimal& x, const Minimal& y)
    {
        if (!(x == y)) { /* ... */ }    // OK
        if (x != y) { /* ... */ }       // surprise! error

        while (!(x < y)) { /* ... */ }  // OK
        while (x >= y) { /* ... */ }    // surprise! error

        x = x + y;          // OK
        x += y;             // surprise! error
    }

This is minimal, but surprising and constraining for users.
It could even be less efficient.

The rule supports the view that a concept should reflect a (mathematically) coherent set of operations.

##### Example

    class Convenient {
        // ...
    };

    bool operator==(const Convenient&, const Convenient&);
    bool operator<(const Convenient&, const Convenient&);
    // ... and the other comparison operators ...

    Minimal operator+(const Convenient&, const Convenient&);
    // .. and the other arithmetic operators ...

    void f(const Convenient& x, const Convenient& y)
    {
        if (!(x == y)) { /* ... */ }    // OK
        if (x != y) { /* ... */ }       // OK

        while (!(x < y)) { /* ... */ }  // OK
        while (x >= y) { /* ... */ }    // OK

        x = x + y;     // OK
        x += y;        // OK
    }

It can be a nuisance to define all operators, but not hard.
Ideally, that rule should be language supported by giving you comparison operators by default.

##### Enforcement

* Flag classes that support "odd" subsets of a set of operators, e.g., `==` but not `!=` or `+` but not `-`.
  Yes, `std::string` is "odd", but it's too late to change that.


### <a name="Rt-axiom"></a>T.22: Specify axioms for concepts

##### Reason

A meaningful/useful concept has a semantic meaning.
Expressing these semantics in an informal, semi-formal, or formal way makes the concept comprehensible to readers and the effort to express it can catch conceptual errors.
Specifying semantics is a powerful design tool.

##### Example (using TS concepts)

    template<typename T>
        // The operators +, -, *, and / for a number are assumed to follow the usual mathematical rules
        // axiom(T a, T b) { a + b == b + a; a - a == 0; a * (b + c) == a * b + a * c; /*...*/ }
        concept Number = requires(T a, T b) {
            {a + b} -> T;   // the result of a + b is convertible to T
            {a - b} -> T;
            {a * b} -> T;
            {a / b} -> T;
        }

##### Note

This is an axiom in the mathematical sense: something that may be assumed without proof.
In general, axioms are not provable, and when they are the proof is often beyond the capability of a compiler.
An axiom may not be general, but the template writer may assume that it holds for all inputs actually used (similar to a precondition).

##### Note

In this context axioms are Boolean expressions.
See the [Palo Alto TR](#S-references) for examples.
Currently, C++ does not support axioms (even the ISO Concepts TS), so we have to make do with comments for a longish while.
Once language support is available, the `//` in front of the axiom can be removed

##### Note

The GSL concepts have well-defined semantics; see the Palo Alto TR and the Ranges TS.

##### Exception (using TS concepts)

Early versions of a new "concept" still under development will often just define simple sets of constraints without a well-specified semantics.
Finding good semantics can take effort and time.
An incomplete set of constraints can still be very useful:

    // balancer for a generic binary tree
    template<typename Node> concept bool Balancer = requires(Node* p) {
        add_fixup(p);
        touch(p);
        detach(p);
    }

So a `Balancer` must supply at least thee operations on a tree `Node`,
but we are not yet ready to specify detailed semantics because a new kind of balanced tree might require more operations
and the precise general semantics for all nodes is hard to pin down in the early stages of design.

A "concept" that is incomplete or without a well-specified semantics can still be useful.
For example, it allows for some checking during initial experimentation.
However, it should not be assumed to be stable.
Each new use case may require such an incomplete concept to be improved.

##### Enforcement

* Look for the word "axiom" in concept definition comments

### <a name="Rt-refine"></a>T.23: Differentiate a refined concept from its more general case by adding new use patterns.

##### Reason

Otherwise they cannot be distinguished automatically by the compiler.

##### Example (using TS concepts)

    template<typename I>
    concept bool Input_iter = requires(I iter) { ++iter; };

    template<typename I>
    concept bool Fwd_iter = Input_iter<I> && requires(I iter) { iter++; }

The compiler can determine refinement based on the sets of required operations (here, suffix `++`).
This decreases the burden on implementers of these types since
they do not need any special declarations to "hook into the concept".
If two concepts have exactly the same requirements, they are logically equivalent (there is no refinement).

##### Enforcement

* Flag a concept that has exactly the same requirements as another already-seen concept (neither is more refined).
To disambiguate them, see [T.24](#Rt-tag).

### <a name="Rt-tag"></a>T.24: Use tag classes or traits to differentiate concepts that differ only in semantics.

##### Reason

Two concepts requiring the same syntax but having different semantics leads to ambiguity unless the programmer differentiates them.

##### Example (using TS concepts)

    template<typename I>    // iterator providing random access
    concept bool RA_iter = ...;

    template<typename I>    // iterator providing random access to contiguous data
    concept bool Contiguous_iter =
        RA_iter<I> && is_contiguous<I>::value;  // using is_contiguous trait

The programmer (in a library) must define `is_contiguous` (a trait) appropriately.

Wrapping a tag class into a concept leads to a simpler expression of this idea:

    template<typename I> concept Contiguous = is_contiguous<I>::value;

    template<typename I>
    concept bool Contiguous_iter = RA_iter<I> && Contiguous<I>;

The programmer (in a library) must define `is_contiguous` (a trait) appropriately.

##### Note

Traits can be trait classes or type traits.
These can be user-defined or standard-library ones.
Prefer the standard-library ones.

##### Enforcement

* The compiler flags ambiguous use of identical concepts.
* Flag the definition of identical concepts.

### <a name="Rt-not"></a>T.25: Avoid complementary constraints

##### Reason

Clarity. Maintainability.
Functions with complementary requirements expressed using negation are brittle.

##### Example (using TS concepts)

Initially, people will try to define functions with complementary requirements:

    template<typename T>
        requires !C<T>    // bad
    void f();

    template<typename T>
        requires C<T>
    void f();

This is better:

    template<typename T>   // general template
        void f();

    template<typename T>   // specialization by concept
        requires C<T>
    void f();

The compiler will choose the unconstrained template only when `C<T>` is
unsatisfied. If you do not want to (or cannot) define an unconstrained
version of `f()`, then delete it.

    template<typename T>
    void f() = delete;

The compiler will select the overload and emit an appropriate error.

##### Note

Complementary constraints are unfortunately common in `enable_if` code:

    template<typename T>
    enable_if<!C<T>, void>   // bad
    f();

    template<typename T>
    enable_if<C<T>, void>
    f();


##### Note

Complementary requirements on one requirements is sometimes (wrongly) considered manageable.
However, for two or more requirements the number of definitions needs can go up exponentially (2,4,8,16,...):

    C1<T> && C2<T>
    !C1<T> && C2<T>
    C1<T> && !C2<T>
    !C1<T> && !C2<T>

Now the opportunities for errors multiply.

##### Enforcement

* Flag pairs of functions with `C<T>` and `!C<T>` constraints

### <a name="Rt-use"></a>T.26: Prefer to define concepts in terms of use-patterns rather than simple syntax

##### Reason

The definition is more readable and corresponds directly to what a user has to write.
Conversions are taken into account. You don't have to remember the names of all the type traits.

##### Example (using TS concepts)

You might be tempted to define a concept `Equality` like this:

    template<typename T> concept Equality = has_equal<T> && has_not_equal<T>;

Obviously, it would be better and easier just to use the standard `EqualityComparable`,
but - just as an example - if you had to define such a concept, prefer:

    template<typename T> concept Equality = requires(T a, T b) {
        bool == { a == b }
        bool == { a != b }
        // axiom { !(a == b) == (a != b) }
        // axiom { a = b; => a == b }  // => means "implies"
    }

as opposed to defining two meaningless concepts `has_equal` and `has_not_equal` just as helpers in the definition of `Equality`.
By "meaningless" we mean that we cannot specify the semantics of `has_equal` in isolation.

##### Enforcement

???

## <a name="SS-temp-interface"></a>Template interfaces

Over the years, programming with templates have suffered from a weak distinction between the interface of a template
and its implementation.
Before concepts, that distinction had no direct language support.
However, the interface to a template is a critical concept - a contract between a user and an implementer - and should be carefully designed.

### <a name="Rt-fo"></a>T.40: Use function objects to pass operations to algorithms

##### Reason

Function objects can carry more information through an interface than a "plain" pointer to function.
In general, passing function objects gives better performance than passing pointers to functions.

##### Example (using TS concepts)

    bool greater(double x, double y) { return x > y; }
    sort(v, greater);                                    // pointer to function: potentially slow
    sort(v, [](double x, double y) { return x > y; });   // function object
    sort(v, std::greater<>);                             // function object

    bool greater_than_7(double x) { return x > 7; }
    auto x = find_if(v, greater_than_7);                 // pointer to function: inflexible
    auto y = find_if(v, [](double x) { return x > 7; }); // function object: carries the needed data
    auto z = find_if(v, Greater_than<double>(7));        // function object: carries the needed data

You can, of course, generalize those functions using `auto` or (when and where available) concepts. For example:

    auto y1 = find_if(v, [](Ordered x) { return x > 7; }); // require an ordered type
    auto z1 = find_if(v, [](auto x) { return x > 7; });    // hope that the type has a >

##### Note

Lambdas generate function objects.

##### Note

The performance argument depends on compiler and optimizer technology.

##### Enforcement

* Flag pointer to function template arguments.
* Flag pointers to functions passed as arguments to a template (risk of false positives).


### <a name="Rt-essential"></a>T.41: Require only essential properties in a template's concepts

##### Reason

Keep interfaces simple and stable.

##### Example (using TS concepts)

Consider, a `sort` instrumented with (oversimplified) simple debug support:

    void sort(Sortable& s)  // sort sequence s
    {
        if (debug) cerr << "enter sort( " << s <<  ")\n";
        // ...
        if (debug) cerr << "exit sort( " << s <<  ")\n";
    }

Should this be rewritten to:

    template<Sortable S>
        requires Streamable<S>
    void sort(S& s)  // sort sequence s
    {
        if (debug) cerr << "enter sort( " << s <<  ")\n";
        // ...
        if (debug) cerr << "exit sort( " << s <<  ")\n";
    }

After all, there is nothing in `Sortable` that requires `iostream` support.
On the other hand, there is nothing in the fundamental idea of sorting that says anything about debugging.

##### Note

If we require every operation used to be listed among the requirements, the interface becomes unstable:
Every time we change the debug facilities, the usage data gathering, testing support, error reporting, etc.,
the definition of the template would need change and every use of the template would have to be recompiled.
This is cumbersome, and in some environments infeasible.

Conversely, if we use an operation in the implementation that is not guaranteed by concept checking,
we may get a late compile-time error.

By not using concept checking for properties of a template argument that is not considered essential,
we delay checking until instantiation time.
We consider this a worthwhile tradeoff.

Note that using non-local, non-dependent names (such as `debug` and `cerr`) also introduces context dependencies that may lead to "mysterious" errors.

##### Note

It can be hard to decide which properties of a type are essential and which are not.

##### Enforcement

???

### <a name="Rt-alias"></a>T.42: Use template aliases to simplify notation and hide implementation details

##### Reason

Improved readability.
Implementation hiding.
Note that template aliases replace many uses of traits to compute a type.
They can also be used to wrap a trait.

##### Example

    template<typename T, size_t N>
    class Matrix {
        // ...
        using Iterator = typename std::vector<T>::iterator;
        // ...
    };

This saves the user of `Matrix` from having to know that its elements are stored in a `vector` and also saves the user from repeatedly typing `typename std::vector<T>::`.

##### Example

    template<typename T>
    void user(T& c)
    {
        // ...
        typename container_traits<T>::value_type x; // bad, verbose
        // ...
    }

    template<typename T>
    using Value_type = typename container_traits<T>::value_type;


This saves the user of `Value_type` from having to know the technique used to implement `value_type`s.

    template<typename T>
    void user2(T& c)
    {
        // ...
        Value_type<T> x;
        // ...
    }

##### Note

A simple, common use could be expressed: "Wrap traits!"

##### Enforcement

* Flag use of `typename` as a disambiguator outside `using` declarations.
* ???

### <a name="Rt-using"></a>T.43: Prefer `using` over `typedef` for defining aliases

##### Reason

Improved readability: With `using`, the new name comes first rather than being embedded somewhere in a declaration.
Generality: `using` can be used for template aliases, whereas `typedef`s can't easily be templates.
Uniformity: `using` is syntactically similar to `auto`.

##### Example

    typedef int (*PFI)(int);   // OK, but convoluted

    using PFI2 = int (*)(int);   // OK, preferred

    template<typename T>
    typedef int (*PFT)(T);      // error

    template<typename T>
    using PFT2 = int (*)(T);   // OK

##### Enforcement

* Flag uses of `typedef`. This will give a lot of "hits" :-(

### <a name="Rt-deduce"></a>T.44: Use function templates to deduce class template argument types (where feasible)

##### Reason

Writing the template argument types explicitly can be tedious and unnecessarily verbose.

##### Example

    tuple<int, string, double> t1 = {1, "Hamlet", 3.14};   // explicit type
    auto t2 = make_tuple(1, "Ophelia"s, 3.14);         // better; deduced type

Note the use of the `s` suffix to ensure that the string is a `std::string`, rather than a C-style string.

##### Note

Since you can trivially write a `make_T` function, so could the compiler. Thus, `make_T` functions may become redundant in the future.

##### Exception

Sometimes there isn't a good way of getting the template arguments deduced and sometimes, you want to specify the arguments explicitly:

    vector<double> v = { 1, 2, 3, 7.9, 15.99 };
    list<Record*> lst;

##### Note

Note that C++17 will make this rule redundant by allowing the template arguments to be deduced directly from constructor arguments:
[Template parameter deduction for constructors (Rev. 3)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r1.html).
For example:

    tuple t1 = {1, "Hamlet"s, 3.14}; // deduced: tuple<int, string, double>

##### Enforcement

Flag uses where an explicitly specialized type exactly matches the types of the arguments used.

### <a name="Rt-regular"></a>T.46: Require template arguments to be at least `Regular` or `SemiRegular`

##### Reason

 Readability.
 Preventing surprises and errors.
 Most uses support that anyway.

##### Example

    class X {
    public:
        explicit X(int);
        X(const X&);            // copy
        X operator=(const X&);
        X(X&&) noexcept;                 // move
        X& operator=(X&&) noexcept;
        ~X();
        // ... no more constructors ...
    };

    X x {1};    // fine
    X y = x;      // fine
    std::vector<X> v(10); // error: no default constructor

##### Note

Semiregular requires default constructible.

##### Enforcement

* Flag types that are not at least `SemiRegular`.

### <a name="Rt-visible"></a>T.47: Avoid highly visible unconstrained templates with common names

##### Reason

 An unconstrained template argument is a perfect match for anything so such a template can be preferred over more specific types that require minor conversions.
 This is particularly annoying/dangerous when ADL is used.
 Common names make this problem more likely.

##### Example

    namespace Bad {
        struct S { int m; };
        template<typename T1, typename T2>
        bool operator==(T1, T2) { cout << "Bad\n"; return true; }
    }

    namespace T0 {
        bool operator==(int, Bad::S) { cout << "T0\n"; return true; }  // compare to int

        void test()
        {
            Bad::S bad{ 1 };
            vector<int> v(10);
            bool b = 1 == bad;
            bool b2 = v.size() == bad;
        }
    }

This prints `T0` and `Bad`.

Now the `==` in `Bad` was designed to cause trouble, but would you have spotted the problem in real code?
The problem is that `v.size()` returns an `unsigned` integer so that a conversion is needed to call the local `==`;
the `==` in `Bad` requires no conversions.
Realistic types, such as the standard-library iterators can be made to exhibit similar anti-social tendencies.

##### Note

If an unconstrained template is defined in the same namespace as a type,
that unconstrained template can be found by ADL (as happened in the example).
That is, it is highly visible.

##### Note

This rule should not be necessary, but the committee cannot agree to exclude unconstrained templated from ADL.

Unfortunately this will get many false positives; the standard library violates this widely, by putting many unconstrained templates and types into the single namespace `std`.


##### Enforcement

Flag templates defined in a namespace where concrete types are also defined (maybe not feasible until we have concepts).


### <a name="Rt-concept-def"></a>T.48: If your compiler does not support concepts, fake them with `enable_if`

##### Reason

Because that's the best we can do without direct concept support.
`enable_if` can be used to conditionally define functions and to select among a set of functions.

##### Example

    template <typename T>
    enable_if_t<is_integral_v<T>>
    f(T v)
    {
        // ...
    }

    // Equivalent to:
    template <Integral T>
    void f(T v)
    {
        // ...
    }

##### Note

Beware of [complementary constraints](# T.25).
Faking concept overloading using `enable_if` sometimes forces us to use that error-prone design technique.

##### Enforcement

???

### <a name="Rt-erasure"></a>T.49: Where possible, avoid type-erasure

##### Reason

Type erasure incurs an extra level of indirection by hiding type information behind a separate compilation boundary.

##### Example

    ???

**Exceptions**: Type erasure is sometimes appropriate, such as for `std::function`.

##### Enforcement

???


##### Note


## <a name="SS-temp-def"></a>T.def: Template definitions

A template definition (class or function) can contain arbitrary code, so only a comprehensive review of C++ programming techniques would cover this topic.
However, this section focuses on what is specific to template implementation.
In particular, it focuses on a template definition's dependence on its context.

### <a name="Rt-depend"></a>T.60: Minimize a template's context dependencies

##### Reason

Eases understanding.
Minimizes errors from unexpected dependencies.
Eases tool creation.

##### Example

    template<typename C>
    void sort(C& c)
    {
        std::sort(begin(c), end(c)); // necessary and useful dependency
    }

    template<typename Iter>
    Iter algo(Iter first, Iter last) {
        for (; first != last; ++first) {
            auto x = sqrt(*first); // potentially surprising dependency: which sqrt()?
            helper(first, x);      // potentially surprising dependency:
                                   // helper is chosen based on first and x
            TT var = 7;            // potentially surprising dependency: which TT?
        }
    }

##### Note

Templates typically appear in header files so their context dependencies are more vulnerable to `#include` order dependencies than functions in `.cpp` files.

##### Note

Having a template operate only on its arguments would be one way of reducing the number of dependencies to a minimum, but that would generally be unmanageable.
For example, an algorithm usually uses other algorithms and invoke operations that does not exclusively operate on arguments.
And don't get us started on macros!

**See also**: [T.69](#Rt-customization)

##### Enforcement

??? Tricky

### <a name="Rt-scary"></a>T.61: Do not over-parameterize members (SCARY)

##### Reason

A member that does not depend on a template parameter cannot be used except for a specific template argument.
This limits use and typically increases code size.

##### Example, bad

    template<typename T, typename A = std::allocator{}>
        // requires Regular<T> && Allocator<A>
    class List {
    public:
        struct Link {   // does not depend on A
            T elem;
            T* pre;
            T* suc;
        };

        using iterator = Link*;

        iterator first() const { return head; }

        // ...
    private:
        Link* head;
    };

    List<int> lst1;
    List<int, My_allocator> lst2;

This looks innocent enough, but now `Link` formally depends on the allocator (even though it doesn't use the allocator). This forces redundant instantiations that can be surprisingly costly in some real-world scenarios.
Typically, the solution is to make what would have been a nested class non-local, with its own minimal set of template parameters.

    template<typename T>
    struct Link {
        T elem;
        T* pre;
        T* suc;
    };

    template<typename T, typename A = std::allocator{}>
        // requires Regular<T> && Allocator<A>
    class List2 {
    public:
        using iterator = Link<T>*;

        iterator first() const { return head; }

        // ...
    private:
        Link* head;
    };

    List<int> lst1;
    List<int, My_allocator> lst2;

Some people found the idea that the `Link` no longer was hidden inside the list scary, so we named the technique
[SCARY](http://www.open-std.org/jtc1/sc22/WG21/docs/papers/2009/n2911.pdf). From that academic paper:
"The acronym SCARY describes assignments and initializations that are Seemingly erroneous (appearing Constrained by conflicting generic parameters), but Actually work with the Right implementation (unconstrained bY the conflict due to minimized dependencies)."

##### Enforcement

* Flag member types that do not depend on every template argument
* Flag member functions that do not depend on every template argument

### <a name="Rt-nondependent"></a>T.62: Place non-dependent class template members in a non-templated base class

##### Reason

 Allow the base class members to be used without specifying template arguments and without template instantiation.

##### Example

    template<typename T>
    class Foo {
    public:
        enum { v1, v2 };
        // ...
    };

???

    struct Foo_base {
        enum { v1, v2 };
        // ...
    };

    template<typename T>
    class Foo : public Foo_base {
    public:
        // ...
    };

##### Note

A more general version of this rule would be
"If a template class member depends on only N template parameters out of M, place it in a base class with only N parameters."
For N == 1, we have a choice of a base class of a class in the surrounding scope as in [T.61](#Rt-scary).

??? What about constants? class statics?

##### Enforcement

* Flag ???

### <a name="Rt-specialization"></a>T.64: Use specialization to provide alternative implementations of class templates

##### Reason

A template defines a general interface.
Specialization offers a powerful mechanism for providing alternative implementations of that interface.

##### Example

    ??? string specialization (==)

    ??? representation specialization ?

##### Note

???

##### Enforcement

???

### <a name="Rt-tag-dispatch"></a>T.65: Use tag dispatch to provide alternative implementations of a function

##### Reason

* A template defines a general interface.
* Tag dispatch allows us to select implementations based on specific properties of an argument type.
* Performance.

##### Example

This is a simplified version of `std::copy` (ignoring the possibility of non-contiguous sequences)

    struct pod_tag {};
    struct non_pod_tag {};

    template<class T> struct copy_trait { using tag = non_pod_tag; };   // T is not "plain old data"

    template<> struct copy_trait<int> { using tag = pod_tag; };         // int is "plain old data"

    template<class Iter>
    Out copy_helper(Iter first, Iter last, Iter out, pod_tag)
    {
        // use memmove
    }

    template<class Iter>
    Out copy_helper(Iter first, Iter last, Iter out, non_pod_tag)
    {
        // use loop calling copy constructors
    }

    template<class Itert>
    Out copy(Iter first, Iter last, Iter out)
    {
        return copy_helper(first, last, out, typename copy_trait<Iter>::tag{})
    }

    void use(vector<int>& vi, vector<int>& vi2, vector<string>& vs, vector<string>& vs2)
    {
        copy(vi.begin(), vi.end(), vi2.begin()); // uses memmove
        copy(vs.begin(), vs.end(), vs2.begin()); // uses a loop calling copy constructors
    }

This is a general and powerful technique for compile-time algorithm selection.

##### Note

When `concept`s become widely available such alternatives can be distinguished directly:

    template<class Iter>
        requires Pod<Value_type<iter>>
    Out copy_helper(In, first, In last, Out out)
    {
        // use memmove
    }

    template<class Iter>
    Out copy_helper(In, first, In last, Out out)
    {
        // use loop calling copy constructors
    }

##### Enforcement

???


### <a name="Rt-specialization2"></a>T.67: Use specialization to provide alternative implementations for irregular types

##### Reason

 ???

##### Example

    ???

##### Enforcement

???

### <a name="Rt-cast"></a>T.68: Use `{}` rather than `()` within templates to avoid ambiguities

##### Reason

 `()` is vulnerable to grammar ambiguities.

##### Example

    template<typename T, typename U>
    void f(T t, U u)
    {
        T v1(x);    // is v1 a function or a variable?
        T v2 {x};   // variable
        auto x = T(u);  // construction or cast?
    }

    f(1, "asdf"); // bad: cast from const char* to int

##### Enforcement

* flag `()` initializers
* flag function-style casts


### <a name="Rt-customization"></a>T.69: Inside a template, don't make an unqualified nonmember function call unless you intend it to be a customization point

##### Reason

* Provide only intended flexibility.
* Avoid vulnerability to accidental environmental changes.

##### Example

There are three major ways to let calling code customize a template.

    template<class T>
        // Call a member function
    void test1(T t)
    {
        t.f();    // require T to provide f()
    }

    template<class T>
    void test2(T t)
        // Call a nonmember function without qualification
    {
        f(t);  // require f(/*T*/) be available in caller's scope or in T's namespace
    }

    template<class T>
    void test3(T t)
        // Invoke a "trait"
    {
        test_traits<T>::f(t); // require customizing test_traits<>
                              // to get non-default functions/types
    }

A trait is usually a type alias to compute a type,
a `constexpr` function to compute a value,
or a traditional traits template to be specialized on the user's type.

##### Note

If you intend to call your own helper function `helper(t)` with a value `t` that depends on a template type parameter,
put it in a `::detail` namespace and qualify the call as `detail::helper(t);`.
An unqualified call becomes a customization point where any function `helper` in the namespace of `t`'s type can be invoked;
this can cause problems like [unintentionally invoking unconstrained function templates](#Rt-unconstrained-adl).


##### Enforcement

* In a template, flag an unqualified call to a nonmember function that passes a variable of dependent type when there is a nonmember function of the same name in the template's namespace.


## <a name="SS-temp-hier"></a>T.temp-hier: Template and hierarchy rules:

Templates are the backbone of C++'s support for generic programming and class hierarchies the backbone of its support
for object-oriented programming.
The two language mechanisms can be used effectively in combination, but a few design pitfalls must be avoided.

### <a name="Rt-hier"></a>T.80: Do not naively templatize a class hierarchy

##### Reason

Templating a class hierarchy that has many functions, especially many virtual functions, can lead to code bloat.

##### Example, bad

    template<typename T>
    struct Container {         // an interface
        virtual T* get(int i);
        virtual T* first();
        virtual T* next();
        virtual void sort();
    };

    template<typename T>
    class Vector : public Container<T> {
    public:
        // ...
    };

    Vector<int> vi;
    Vector<string> vs;

It is probably a dumb idea to define a `sort` as a member function of a container, but it is not unheard of and it makes a good example of what not to do.

Given this, the compiler cannot know if `vector<int>::sort()` is called, so it must generate code for it.
Similar for `vector<string>::sort()`.
Unless those two functions are called that's code bloat.
Imagine what this would do to a class hierarchy with dozens of member functions and dozens of derived classes with many instantiations.

##### Note

In many cases you can provide a stable interface by not parameterizing a base;
see ["stable base"](#Rt-abi) and [OO and GP](#Rt-generic-oo)

##### Enforcement

* Flag virtual functions that depend on a template argument. ??? False positives

### <a name="Rt-array"></a>T.81: Do not mix hierarchies and arrays

##### Reason

An array of derived classes can implicitly "decay" to a pointer to a base class with potential disastrous results.

##### Example

Assume that `Apple` and `Pear` are two kinds of `Fruit`s.

    void maul(Fruit* p)
    {
        *p = Pear{};     // put a Pear into *p
        p[1] = Pear{};   // put a Pear into p[1]
    }

    Apple aa [] = { an_apple, another_apple };   // aa contains Apples (obviously!)

    maul(aa);
    Apple& a0 = &aa[0];   // a Pear?
    Apple& a1 = &aa[1];   // a Pear?

Probably, `aa[0]` will be a `Pear` (without the use of a cast!).
If `sizeof(Apple) != sizeof(Pear)` the access to `aa[1]` will not be aligned to the proper start of an object in the array.
We have a type violation and possibly (probably) a memory corruption.
Never write such code.

Note that `maul()` violates the a [`T*` points to an individual object rule](#Rf-ptr).

**Alternative**: Use a proper (templatized) container:

    void maul2(Fruit* p)
    {
        *p = Pear{};   // put a Pear into *p
    }

    vector<Apple> va = { an_apple, another_apple };   // va contains Apples (obviously!)

    maul2(va);       // error: cannot convert a vector<Apple> to a Fruit*
    maul2(&va[0]);   // you asked for it

    Apple& a0 = &va[0];   // a Pear?

Note that the assignment in `maul2()` violated the [no-slicing rule](#Res-slice).

##### Enforcement

* Detect this horror!

### <a name="Rt-linear"></a>T.82: Linearize a hierarchy when virtual functions are undesirable

##### Reason

 ???

##### Example

    ???

##### Enforcement

???

### <a name="Rt-virtual"></a>T.83: Do not declare a member function template virtual

##### Reason

C++ does not support that.
If it did, vtbls could not be generated until link time.
And in general, implementations must deal with dynamic linking.

##### Example, don't

    class Shape {
        // ...
        template<class T>
        virtual bool intersect(T* p);   // error: template cannot be virtual
    };

##### Note

We need a rule because people keep asking about this

##### Alternative

Double dispatch, visitors, calculate which function to call

##### Enforcement

The compiler handles that.

### <a name="Rt-abi"></a>T.84: Use a non-template core implementation to provide an ABI-stable interface

##### Reason

Improve stability of code.
Avoid code bloat.

##### Example

It could be a base class:

    struct Link_base {   // stable
        Link_base* suc;
        Link_base* pre;
    };

    template<typename T>   // templated wrapper to add type safety
    struct Link : Link_base {
        T val;
    };

    struct List_base {
        Link_base* first;   // first element (if any)
        int sz;             // number of elements
        void add_front(Link_base* p);
        // ...
    };

    template<typename T>
    class List : List_base {
    public:
        void put_front(const T& e) { add_front(new Link<T>{e}); }   // implicit cast to Link_base
        T& front() { static_cast<Link<T>*>(first).val; }   // explicit cast back to Link<T>
        // ...
    };

    List<int> li;
    List<string> ls;

Now there is only one copy of the operations linking and unlinking elements of a `List`.
The `Link` and `List` classes do nothing but type manipulation.

Instead of using a separate "base" type, another common technique is to specialize for `void` or `void*` and have the general template for `T` be just the safely-encapsulated casts to and from the core `void` implementation.

**Alternative**: Use a [Pimpl](#Ri-pimpl) implementation.

##### Enforcement

???

## <a name="SS-variadic"></a>T.var: Variadic template rules

???

### <a name="Rt-variadic"></a>T.100: Use variadic templates when you need a function that takes a variable number of arguments of a variety of types

##### Reason

Variadic templates is the most general mechanism for that, and is both efficient and type-safe. Don't use C varargs.

##### Example

    ??? printf

##### Enforcement

* Flag uses of `va_arg` in user code.

### <a name="Rt-variadic-pass"></a>T.101: ??? How to pass arguments to a variadic template ???

##### Reason

 ???

##### Example

    ??? beware of move-only and reference arguments

##### Enforcement

???

### <a name="Rt-variadic-process"></a>T.102: How to process arguments to a variadic template

##### Reason

 ???

##### Example

    ??? forwarding, type checking, references

##### Enforcement

???

### <a name="Rt-variadic-not"></a>T.103: Don't use variadic templates for homogeneous argument lists

##### Reason

There are more precise ways of specifying a homogeneous sequence, such as an `initializer_list`.

##### Example

    ???

##### Enforcement

???

## <a name="SS-meta"></a>T.meta: Template metaprogramming (TMP)

Templates provide a general mechanism for compile-time programming.

Metaprogramming is programming where at least one input or one result is a type.
Templates offer Turing-complete (modulo memory capacity) duck typing at compile time.
The syntax and techniques needed are pretty horrendous.

### <a name="Rt-metameta"></a>T.120: Use template metaprogramming only when you really need to

##### Reason

Template metaprogramming is hard to get right, slows down compilation, and is often very hard to maintain.
However, there are real-world examples where template metaprogramming provides better performance than any alternative short of expert-level assembly code.
Also, there are real-world examples where template metaprogramming expresses the fundamental ideas better than run-time code.
For example, if you really need AST manipulation at compile time (e.g., for optional matrix operation folding) there may be no other way in C++.

##### Example, bad

    ???

##### Example, bad

    enable_if

Instead, use concepts. But see [How to emulate concepts if you don't have language support](#Rt-emulate).

##### Example

    ??? good

**Alternative**: If the result is a value, rather than a type, use a [`constexpr` function](#Rt-fct).

##### Note

If you feel the need to hide your template metaprogramming in macros, you have probably gone too far.

### <a name="Rt-emulate"></a>T.121: Use template metaprogramming primarily to emulate concepts

##### Reason

Until concepts become generally available, we need to emulate them using TMP.
Use cases that require concepts (e.g. overloading based on concepts) are among the most common (and simple) uses of TMP.

##### Example

    template<typename Iter>
        /*requires*/ enable_if<random_access_iterator<Iter>, void>
    advance(Iter p, int n) { p += n; }

    template<typename Iter>
        /*requires*/ enable_if<forward_iterator<Iter>, void>
    advance(Iter p, int n) { assert(n >= 0); while (n--) ++p;}

##### Note

Such code is much simpler using concepts:

    void advance(RandomAccessIterator p, int n) { p += n; }

    void advance(ForwardIterator p, int n) { assert(n >= 0); while (n--) ++p;}

##### Enforcement

???

### <a name="Rt-tmp"></a>T.122: Use templates (usually template aliases) to compute types at compile time

##### Reason

Template metaprogramming is the only directly supported and half-way principled way of generating types at compile time.

##### Note

"Traits" techniques are mostly replaced by template aliases to compute types and `constexpr` functions to compute values.

##### Example

    ??? big object / small object optimization

##### Enforcement

???

### <a name="Rt-fct"></a>T.123: Use `constexpr` functions to compute values at compile time

##### Reason

A function is the most obvious and conventional way of expressing the computation of a value.
Often a `constexpr` function implies less compile-time overhead than alternatives.

##### Note

"Traits" techniques are mostly replaced by template aliases to compute types and `constexpr` functions to compute values.

##### Example

    template<typename T>
        // requires Number<T>
    constexpr T pow(T v, int n)   // power/exponential
    {
        T res = 1;
        while (n--) res *= v;
        return res;
    }

    constexpr auto f7 = pow(pi, 7);

##### Enforcement

* Flag template metaprograms yielding a value. These should be replaced with `constexpr` functions.

### <a name="Rt-std-tmp"></a>T.124: Prefer to use standard-library TMP facilities

##### Reason

Facilities defined in the standard, such as `conditional`, `enable_if`, and `tuple`, are portable and can be assumed to be known.

##### Example

    ???

##### Enforcement

???

### <a name="Rt-lib"></a>T.125: If you need to go beyond the standard-library TMP facilities, use an existing library

##### Reason

Getting advanced TMP facilities is not easy and using a library makes you part of a (hopefully supportive) community.
Write your own "advanced TMP support" only if you really have to.

##### Example

    ???

##### Enforcement

???

## <a name="SS-temp-other"></a>Other template rules

### <a name="Rt-name"></a>T.140: Name all operations with potential for reuse

##### Reason

Documentation, readability, opportunity for reuse.

##### Example

    struct Rec {
        string name;
        string addr;
        int id;         // unique identifier
    };

    bool same(const Rec& a, const Rec& b)
    {
        return a.id == b.id;
    }

    vector<Rec*> find_id(const string& name);    // find all records for "name"

    auto x = find_if(vr.begin(), vr.end(),
        [&](Rec& r) {
            if (r.name.size() != n.size()) return false; // name to compare to is in n
            for (int i = 0; i < r.name.size(); ++i)
                if (tolower(r.name[i]) != tolower(n[i])) return false;
            return true;
        }
    );

There is a useful function lurking here (case insensitive string comparison), as there often is when lambda arguments get large.

    bool compare_insensitive(const string& a, const string& b)
    {
        if (a.size() != b.size()) return false;
        for (int i = 0; i < a.size(); ++i) if (tolower(a[i]) != tolower(b[i])) return false;
        return true;
    }

    auto x = find_if(vr.begin(), vr.end(),
        [&](Rec& r) { compare_insensitive(r.name, n); }
    );

Or maybe (if you prefer to avoid the implicit name binding to n):

    auto cmp_to_n = [&n](const string& a) { return compare_insensitive(a, n); };

    auto x = find_if(vr.begin(), vr.end(),
        [](const Rec& r) { return cmp_to_n(r.name); }
    );

##### Note

whether functions, lambdas, or operators.

##### Exception

* Lambdas logically used only locally, such as an argument to `for_each` and similar control flow algorithms.
* Lambdas as [initializers](#???)

##### Enforcement

* (hard) flag similar lambdas
* ???

### <a name="Rt-lambda"></a>T.141: Use an unnamed lambda if you need a simple function object in one place only

##### Reason

That makes the code concise and gives better locality than alternatives.

##### Example

    auto earlyUsersEnd = std::remove_if(users.begin(), users.end(),
                                        [](const User &a) { return a.id > 100; });


##### Exception

Naming a lambda can be useful for clarity even if it is used only once.

##### Enforcement

* Look for identical and near identical lambdas (to be replaced with named functions or named lambdas).

### <a name="Rt-var"></a>T.142?: Use template variables to simplify notation

##### Reason

Improved readability.

##### Example

    ???

##### Enforcement

???

### <a name="Rt-nongeneric"></a>T.143: Don't write unintentionally nongeneric code

##### Reason

Generality. Reusability. Don't gratuitously commit to details; use the most general facilities available.

##### Example

Use `!=` instead of `<` to compare iterators; `!=` works for more objects because it doesn't rely on ordering.

    for (auto i = first; i < last; ++i) {   // less generic
        // ...
    }

    for (auto i = first; i != last; ++i) {   // good; more generic
        // ...
    }

Of course, range-`for` is better still where it does what you want.

##### Example

Use the least-derived class that has the functionality you need.

    class Base {
    public:
        Bar f();
        Bar g();
    };

    class Derived1 : public Base {
    public:
        Bar h();
    };

    class Derived2 : public Base {
    public:
        Bar j();
    };

    // bad, unless there is a specific reason for limiting to Derived1 objects only
    void my_func(Derived1& param)
    {
        use(param.f());
        use(param.g());
    }

    // good, uses only Base interface so only commit to that
    void my_func(Base& param)
    {
        use(param.f());
        use(param.g());
    }

##### Enforcement

* Flag comparison of iterators using `<` instead of `!=`.
* Flag `x.size() == 0` when `x.empty()` or `x.is_empty()` is available. Emptiness works for more containers than size(), because some containers don't know their size or are conceptually of unbounded size.
* Flag functions that take a pointer or reference to a more-derived type but only use functions declared in a base type.

### <a name="Rt-specialize-function"></a>T.144: Don't specialize function templates

##### Reason

You can't partially specialize a function template per language rules. You can fully specialize a function template but you almost certainly want to overload instead -- because function template specializations don't participate in overloading, they don't act as you probably wanted. Rarely, you should actually specialize by delegating to a class template that you can specialize properly.

##### Example

    ???

**Exceptions**: If you do have a valid reason to specialize a function template, just write a single function template that delegates to a class template, then specialize the class template (including the ability to write partial specializations).

##### Enforcement

* Flag all specializations of a function template. Overload instead.


### <a name="Rt-check-class"></a>T.150: Check that a class matches a concept using `static_assert`

##### Reason

If you intend for a class to match a concept, verifying that early saves users pain.

##### Example

    class X {
    public:
        X() = delete;
        X(const X&) = default;
        X(X&&) = default;
        X& operator=(const X&) = default;
        // ...
    };

Somewhere, possibly in an implementation file, let the compiler check the desired properties of `X`:

    static_assert(Default_constructible<X>);    // error: X has no default constructor
    static_assert(Copyable<X>);                 // error: we forgot to define X's move constructor


##### Enforcement

Not feasible.

# <a name="S-cpl"></a>CPL: C-style programming

C and C++ are closely related languages.
They both originate in "Classic C" from 1978 and have evolved in ISO committees since then.
Many attempts have been made to keep them compatible, but neither is a subset of the other.

C rule summary:

* [CPL.1: Prefer C++ to C](#Rcpl-C)
* [CPL.2: If you must use C, use the common subset of C and C++, and compile the C code as C++](#Rcpl-subset)
* [CPL.3: If you must use C for interfaces, use C++ in the calling code using such interfaces](#Rcpl-interface)

### <a name="Rcpl-C"></a>CPL.1: Prefer C++ to C

##### Reason

C++ provides better type checking and more notational support.
It provides better support for high-level programming and often generates faster code.

##### Example

    char ch = 7;
    void* pv = &ch;
    int* pi = pv;   // not C++
    *pi = 999;      // overwrite sizeof(int) bytes near &ch

The rules for implicit casting to and from `void*` in C are subtle and unenforced.
In particular, this example violates a rule against converting to a type with stricter alignment.

##### Enforcement

Use a C++ compiler.

### <a name="Rcpl-subset"></a>CPL.2: If you must use C, use the common subset of C and C++, and compile the C code as C++

##### Reason

That subset can be compiled with both C and C++ compilers, and when compiled as C++ is better type checked than "pure C."

##### Example

    int* p1 = malloc(10 * sizeof(int));                      // not C++
    int* p2 = static_cast<int*>(malloc(10 * sizeof(int)));   // not C, C-style C++
    int* p3 = new int[10];                                   // not C
    int* p4 = (int*) malloc(10 * sizeof(int));               // both C and C++

##### Enforcement

* Flag if using a build mode that compiles code as C.

  * The C++ compiler will enforce that the code is valid C++ unless you use C extension options.

### <a name="Rcpl-interface"></a>CPL.3: If you must use C for interfaces, use C++ in the calling code using such interfaces

##### Reason

C++ is more expressive than C and offers better support for many types of programming.

##### Example

For example, to use a 3rd party C library or C systems interface, define the low-level interface in the common subset of C and C++ for better type checking.
Whenever possible encapsulate the low-level interface in an interface that follows the C++ guidelines (for better abstraction, memory safety, and resource safety) and use that C++ interface in C++ code.

##### Example

You can call C from C++:

    // in C:
    double sqrt(double);

    // in C++:
    extern "C" double sqrt(double);

    sqrt(2);

##### Example

You can call C++ from C:

    // in C:
    X call_f(struct Y*, int);

    // in C++:
    extern "C" X call_f(Y* p, int i)
    {
        return p->f(i);   // possibly a virtual function call
    }

##### Enforcement

None needed

# <a name="S-source"></a>SF: Source files

Distinguish between declarations (used as interfaces) and definitions (used as implementations).
Use header files to represent interfaces and to emphasize logical structure.

Source file rule summary:

* [SF.1: Use a `.cpp` suffix for code files and `.h` for interface files if your project doesn't already follow another convention](#Rs-file-suffix)
* [SF.2: A `.h` file may not contain object definitions or non-inline function definitions](#Rs-inline)
* [SF.3: Use `.h` files for all declarations used in multiple source files](#Rs-declaration-header)
* [SF.4: Include `.h` files before other declarations in a file](#Rs-include-order)
* [SF.5: A `.cpp` file must include the `.h` file(s) that defines its interface](#Rs-consistency)
* [SF.6: Use `using namespace` directives for transition, for foundation libraries (such as `std`), or within a local scope (only)](#Rs-using)
* [SF.7: Don't write `using namespace` at global scope in a header file](#Rs-using-directive)
* [SF.8: Use `#include` guards for all `.h` files](#Rs-guards)
* [SF.9: Avoid cyclic dependencies among source files](#Rs-cycles)
* [SF.10: Avoid dependencies on implicitly `#include`d names](#Rs-implicit)
* [SF.11: Header files should be self-contained](#Rs-contained)

* [SF.20: Use `namespace`s to express logical structure](#Rs-namespace)
* [SF.21: Don't use an unnamed (anonymous) namespace in a header](#Rs-unnamed)
* [SF.22: Use an unnamed (anonymous) namespace for all internal/nonexported entities](#Rs-unnamed2)

### <a name="Rs-file-suffix"></a>SF.1: Use a `.cpp` suffix for code files and `.h` for interface files if your project doesn't already follow another convention

##### Reason

It's a longstanding convention.
But consistency is more important, so if your project uses something else, follow that.

##### Note

This convention reflects a common use pattern:
Headers are more often shared with C to compile as both C++ and C, which typically uses `.h`,
and it's easier to name all headers `.h` instead of having different extensions for just those headers that are intended to be shared with C.
On the other hand, implementation files are rarely shared with C and so should typically be distinguished from `.c` files,
so it's normally best to name all C++ implementation files something else (such as `.cpp`).

The specific names `.h` and `.cpp` are not required (just recommended as a default) and other names are in widespread use.
Examples are `.hh`, `.C`, and `.cxx`. Use such names equivalently.
In this document, we refer to `.h` and `.cpp` as a shorthand for header and implementation files,
even though the actual extension may be different.

Your IDE (if you use one) may have strong opinions about suffixes.

##### Example

    // foo.h:
    extern int a;   // a declaration
    extern void foo();

    // foo.cpp:
    int a;   // a definition
    void foo() { ++a; }

`foo.h` provides the interface to `foo.cpp`. Global variables are best avoided.

##### Example, bad

    // foo.h:
    int a;   // a definition
    void foo() { ++a; }

`#include <foo.h>` twice in a program and you get a linker error for two one-definition-rule violations.

##### Enforcement

* Flag non-conventional file names.
* Check that `.h` and `.cpp` (and equivalents) follow the rules below.

### <a name="Rs-inline"></a>SF.2: A `.h` file may not contain object definitions or non-inline function definitions

##### Reason

Including entities subject to the one-definition rule leads to linkage errors.

##### Example

    // file.h:
    namespace Foo {
        int x = 7;
        int xx() { return x+x; }
    }

    // file1.cpp:
    #include <file.h>
    // ... more ...

     // file2.cpp:
    #include <file.h>
    // ... more ...

Linking `file1.cpp` and `file2.cpp` will give two linker errors.

**Alternative formulation**: A `.h` file must contain only:

* `#include`s of other `.h` files (possibly with include guards)
* templates
* class definitions
* function declarations
* `extern` declarations
* `inline` function definitions
* `constexpr` definitions
* `const` definitions
* `using` alias definitions
* ???

##### Enforcement

Check the positive list above.

### <a name="Rs-declaration-header"></a>SF.3: Use `.h` files for all declarations used in multiple source files

##### Reason

Maintainability. Readability.

##### Example, bad

    // bar.cpp:
    void bar() { cout << "bar\n"; }

    // foo.cpp:
    extern void bar();
    void foo() { bar(); }

A maintainer of `bar` cannot find all declarations of `bar` if its type needs changing.
The user of `bar` cannot know if the interface used is complete and correct. At best, error messages come (late) from the linker.

##### Enforcement

* Flag declarations of entities in other source files not placed in a `.h`.

### <a name="Rs-include-order"></a>SF.4: Include `.h` files before other declarations in a file

##### Reason

Minimize context dependencies and increase readability.

##### Example

    #include <vector>
    #include <algorithm>
    #include <string>

    // ... my code here ...

##### Example, bad

    #include <vector>

    // ... my code here ...

    #include <algorithm>
    #include <string>

##### Note

This applies to both `.h` and `.cpp` files.

##### Note

There is an argument for insulating code from declarations and macros in header files by `#including` headers *after* the code we want to protect
(as in the example labeled "bad").
However

* that only works for one file (at one level): Use that technique in a header included with other headers and the vulnerability reappears.
* a namespace (an "implementation namespace") can protect against many context dependencies.
* full protection and flexibility require modules.

**See also**:

* [Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4592.pdf)
* [Modules, Componentization, and Transition](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0141r0.pdf)

##### Enforcement

Easy.

### <a name="Rs-consistency"></a>SF.5: A `.cpp` file must include the `.h` file(s) that defines its interface

##### Reason

This enables the compiler to do an early consistency check.

##### Example, bad

    // foo.h:
    void foo(int);
    int bar(long);
    int foobar(int);

    // foo.cpp:
    void foo(int) { /* ... */ }
    int bar(double) { /* ... */ }
    double foobar(int);

The errors will not be caught until link time for a program calling `bar` or `foobar`.

##### Example

    // foo.h:
    void foo(int);
    int bar(long);
    int foobar(int);

    // foo.cpp:
    #include <foo.h>

    void foo(int) { /* ... */ }
    int bar(double) { /* ... */ }
    double foobar(int);   // error: wrong return type

The return-type error for `foobar` is now caught immediately when `foo.cpp` is compiled.
The argument-type error for `bar` cannot be caught until link time because of the possibility of overloading, but systematic use of `.h` files increases the likelihood that it is caught earlier by the programmer.

##### Enforcement

???

### <a name="Rs-using"></a>SF.6: Use `using namespace` directives for transition, for foundation libraries (such as `std`), or within a local scope (only)

##### Reason

 `using namespace` can lead to name clashes, so it should be used sparingly.
 However, it is not always possible to qualify every name from a namespace in user code (e.g., during transition)
 and sometimes a namespace is so fundamental and prevalent in a code base, that consistent qualification would be verbose and distracting.

##### Example

    #include <string>
    #include <vector>
    #include <iostream>
    #include <memory>
    #include <algorithm>

    using namespace std;

    // ...

Here (obviously), the standard library is used pervasively and apparently no other library is used, so requiring `std::` everywhere
could be distracting.

##### Example

The use of `using namespace std;` leaves the programmer open to a name clash with a name from the standard library

    #include <cmath>
    using namespace std;

    int g(int x)
    {
        int sqrt = 7;
        // ...
        return sqrt(x); // error
    }

However, this is not particularly likely to lead to a resolution that is not an error and
people who use `using namespace std` are supposed to know about `std` and about this risk.

##### Note

A `.cpp` file is a form of local scope.
There is little difference in the opportunities for name clashes in an N-line `.cpp` containing a `using namespace X`,
an N-line function containing a `using namespace X`,
and M functions each containing a `using namespace X`with N lines of code in total.

##### Note

[Don't write `using namespace` in a header file](#Rs-using-directive).

##### Enforcement

Flag multiple `using namespace` directives for different namespaces in a single source file.

### <a name="Rs-using-directive"></a>SF.7: Don't write `using namespace` at global scope in a header file

##### Reason

Doing so takes away an `#include`r's ability to effectively disambiguate and to use alternatives. It also makes `#include`d headers order-dependent as they may have different meaning when included in different orders.

##### Example

    // bad.h
    #include <iostream>
    using namespace std; // bad

    // user.cpp
    #include "bad.h"

    bool copy(/*... some parameters ...*/);    // some function that happens to be named copy

    int main() {
        copy(/*...*/);    // now overloads local ::copy and std::copy, could be ambiguous
    }

##### Note

An exception is `using namespace std::literals;`. This is necessary to use string literals
in header files and given [the rules](http://eel.is/c++draft/over.literal) - users are required
to name their own UDLs `operator""_x` - they will not collide with the standard library.

##### Enforcement

Flag `using namespace` at global scope in a header file.

### <a name="Rs-guards"></a>SF.8: Use `#include` guards for all `.h` files

##### Reason

To avoid files being `#include`d several times.

In order to avoid include guard collisions, do not just name the guard after the filename.
Be sure to also include a key and good differentiator, such as the name of library or component
the header file is part of.

##### Example

    // file foobar.h:
    #ifndef LIBRARY_FOOBAR_H
    #define LIBRARY_FOOBAR_H
    // ... declarations ...
    #endif // LIBRARY_FOOBAR_H

##### Enforcement

Flag `.h` files without `#include` guards.

##### Note

Some implementations offer vendor extensions like `#pragma once` as alternative to include guards.
It is not standard and it is not portable.  It injects the hosting machine's filesystem semantics
into your program, in addition to locking you down to a vendor.
Our recommendation is to write in ISO C++: See [rule P.2](#Rp-Cplusplus).

### <a name="Rs-cycles"></a>SF.9: Avoid cyclic dependencies among source files

##### Reason

Cycles complicate comprehension and slow down compilation. They also
complicate conversion to use language-supported modules (when they become
available).

##### Note

Eliminate cycles; don't just break them with `#include` guards.

##### Example, bad

    // file1.h:
    #include "file2.h"

    // file2.h:
    #include "file3.h"

    // file3.h:
    #include "file1.h"

##### Enforcement

Flag all cycles.


### <a name="Rs-implicit"></a>SF.10: Avoid dependencies on implicitly `#include`d names

##### Reason

Avoid surprises.
Avoid having to change `#include`s if an `#include`d header changes.
Avoid accidentally becoming dependent on implementation details and logically separate entities included in a header.

##### Example

    #include <iostream>
    using namespace std;

    void use()                  // bad
    {
        string s;
        cin >> s;               // fine
        getline(cin, s);        // error: getline() not defined
        if (s == "surprise") {  // error == not defined
            // ...
        }
    }

`<iostream>` exposes the definition of `std::string` ("why?" makes for a fun trivia question),
but it is not required to do so by transitively including the entire `<string>` header,
resulting in the popular beginner question "why doesn't `getline(cin,s);` work?"
or even an occasional "`string`s cannot be compared with `==`).

The solution is to explicitly `#include <string>`:

    #include <iostream>
    #include <string>
    using namespace std;

    void use()
    {
        string s;
        cin >> s;               // fine
        getline(cin, s);        // fine
        if (s == "surprise") {  // fine
            // ...
        }
    }

##### Note

Some headers exist exactly to collect a set of consistent declarations from a variety of headers.
For example:

    // basic_std_lib.h:

    #include <string>
    #include <map>
    #include <iostream>
    #include <random>
    #include <vector>

a user can now get that set of declarations with a single `#include`"

    #include "basic_std_lib.h"

This rule against implicit inclusion is not meant to prevent such deliberate aggregation.

##### Enforcement

Enforcement would require some knowledge about what in a header is meant to be "exported" to users and what is there to enable implementation.
No really good solution is possible until we have modules.

### <a name="Rs-contained"></a>SF.11: Header files should be self-contained

##### Reason

Usability, headers should be simple to use and work when included on their own.
Headers should encapsulate the functionality they provide.
Avoid clients of a header having to manage that header's dependencies.

##### Example

    #include "helpers.h"
    // helpers.h depends on std::string and includes <string>

##### Note

Failing to follow this results in difficult to diagnose errors for clients of a header.

##### Note

A header should include all its dependencies. Be careful about using relative paths because C++ implementations diverge on their meaning.

##### Enforcement

A test should verify that the header file itself compiles or that a cpp file which only includes the header file compiles.

### <a name="Rs-namespace"></a>SF.20: Use `namespace`s to express logical structure

##### Reason

 ???

##### Example

    ???

##### Enforcement

???

### <a name="Rs-unnamed"></a>SF.21: Don't use an unnamed (anonymous) namespace in a header

##### Reason

It is almost always a bug to mention an unnamed namespace in a header file.

##### Example

    ???

##### Enforcement

* Flag any use of an anonymous namespace in a header file.

### <a name="Rs-unnamed2"></a>SF.22: Use an unnamed (anonymous) namespace for all internal/nonexported entities

##### Reason

Nothing external can depend on an entity in a nested unnamed namespace.
Consider putting every definition in an implementation source file in an unnamed namespace unless that is defining an "external/exported" entity.

##### Example

An API class and its members can't live in an unnamed namespace; but any "helper" class or function that is defined in an implementation source file should be at an unnamed namespace scope.

    ???

##### Enforcement

* ???

# <a name="S-stdlib"></a>SL: The Standard Library

Using only the bare language, every task is tedious (in any language).
Using a suitable library any task can be reasonably simple.

The standard library has steadily grown over the years.
Its description in the standard is now larger than that of the language features.
So, it is likely that this library section of the guidelines will eventually grow in size to equal or exceed all the rest.

<< ??? We need another level of rule numbering ??? >>

C++ Standard Library component summary:

* [SL.con: Containers](#SS-con)
* [SL.str: String](#SS-string)
* [SL.io: Iostream](#SS-io)
* [SL.regex: Regex](#SS-regex)
* [SL.chrono: Time](#SS-chrono)
* [SL.C: The C Standard Library](#SS-clib)

Standard-library rule summary:

* [SL.1: Use libraries wherever possible](#Rsl-lib)
* [SL.2: Prefer the standard library to other libraries](#Rsl-sl)
* [SL.3: Do not add non-standard entities to namespace `std`](#sl-std)
* [SL.4: Use the standard library in a type-safe manner](#sl-safe)
* ???

### <a name="Rsl-lib"></a>SL.1:  Use libraries wherever possible

##### Reason

Save time. Don't re-invent the wheel.
Don't replicate the work of others.
Benefit from other people's work when they make improvements.
Help other people when you make improvements.

### <a name="Rsl-sl"></a>SL.2: Prefer the standard library to other libraries

##### Reason

More people know the standard library.
It is more likely to be stable, well-maintained, and widely available than your own code or most other libraries.


### <a name="sl-std"></a>SL.3: Do not add non-standard entities to namespace `std`

##### Reason

Adding to `std` may change the meaning of otherwise standards conforming code.
Additions to `std` may clash with future versions of the standard.

##### Example

    ???

##### Enforcement

Possible, but messy and likely to cause problems with platforms.

### <a name="sl-safe"></a>SL.4: Use the standard library in a type-safe manner

##### Reason

Because, obviously, breaking this rule can lead to undefined behavior, memory corruption, and all kinds of other bad errors.

##### Note

This is a semi-philosophical meta-rule, which needs many supporting concrete rules.
We need it as an umbrella for the more specific rules.

Summary of more specific rules:

* [SL.4: Use the standard library in a type-safe manner](#sl-safe)


## <a name="SS-con"></a>SL.con: Containers

???

Container rule summary:

* [SL.con.1: Prefer using STL `array` or `vector` instead of a C array](#Rsl-arrays)
* [SL.con.2: Prefer using STL `vector` by default unless you have a reason to use a different container](#Rsl-vector)
* [SL.con.3: Avoid bounds errors](#Rsl-bounds)
* [SL.con.4: don't use `memset` or `memcpy` for arguments that are not trivially-copyable](#Rsl-copy)

### <a name="Rsl-arrays"></a>SL.con.1: Prefer using STL `array` or `vector` instead of a C array

##### Reason

C arrays are less safe, and have no advantages over `array` and `vector`.
For a fixed-length array, use `std::array`, which does not degenerate to a pointer when passed to a function and does know its size.
Also, like a built-in array, a stack-allocated `std::array` keeps its elements on the stack.
For a variable-length array, use `std::vector`, which additionally can change its size and handles memory allocation.

##### Example

    int v[SIZE];                        // BAD

    std::array<int, SIZE> w;             // ok

##### Example

    int* v = new int[initial_size];     // BAD, owning raw pointer
    delete[] v;                         // BAD, manual delete

    std::vector<int> w(initial_size);   // ok

##### Note

Use `gsl::span` for non-owning references into a container.

##### Note

Comparing the performance of a fixed-sized array allocated on the stack against a `vector` with its elements on the free store is bogus.
You could just as well compare a `std::array` on the stack against the result of a `malloc()` accessed through a pointer.
For most code, even the difference between stack allocation and free-store allocation doesn't matter, but the convenience and safety of `vector` does.
People working with code for which that difference matters are quite capable of choosing between `array` and `vector`.

##### Enforcement

* Flag declaration of a C array inside a function or class that also declares an STL container (to avoid excessive noisy warnings on legacy non-STL code). To fix: At least change the C array to a `std::array`.

### <a name="Rsl-vector"></a>SL.con.2: Prefer using STL `vector` by default unless you have a reason to use a different container

##### Reason

`vector` and `array` are the only standard containers that offer the following advantages:

* the fastest general-purpose access (random access, including being vectorization-friendly);
* the fastest default access pattern (begin-to-end or end-to-begin is prefetcher-friendly);
* the lowest space overhead (contiguous layout has zero per-element overhead, which is cache-friendly).

Usually you need to add and remove elements from the container, so use `vector` by default; if you don't need to modify the container's size, use `array`.

Even when other containers seem more suited, such as `map` for O(log N) lookup performance or a `list` for efficient insertion in the middle, a `vector` will usually still perform better for containers up to a few KB in size.

##### Note

`string` should not be used as a container of individual characters. A `string` is a textual string; if you want a container of characters, use `vector</*char_type*/>` or `array</*char_type*/>` instead.

##### Exceptions

If you have a good reason to use another container, use that instead. For example:

* If `vector` suits your needs but you don't need the container to be variable size, use `array` instead.

* If you want a dictionary-style lookup container that guarantees O(K) or O(log N) lookups, the container will be larger (more than a few KB) and you perform frequent inserts so that the overhead of maintaining a sorted `vector` is infeasible, go ahead and use an `unordered_map` or `map` instead.

##### Note

To initialize a vector with a number of elements, use `()`-initialization.
To initialize a vector with a list of elements, use `{}`-initialization.

    vector<int> v1(20);  // v1 has 20 elements with the value 0 (vector<int>{})
    vector<int> v2 {20}; // v2 has 1 element with the value 20

[Prefer the {}-initializer syntax](#Res-list).

##### Enforcement

* Flag a `vector` whose size never changes after construction (such as because it's `const` or because no non-`const` functions are called on it). To fix: Use an `array` instead.

### <a name="Rsl-bounds"></a>SL.con.3: Avoid bounds errors

##### Reason

Read or write beyond an allocated range of elements typically leads to bad errors, wrong results, crashes, and security violations.

##### Note

The standard-library functions that apply to ranges of elements all have (or could have) bounds-safe overloads that take `span`.
Standard types such as `vector` can be modified to perform bounds-checks under the bounds profile (in a compatible way, such as by adding contracts), or used with `at()`.

Ideally, the in-bounds guarantee should be statically enforced.
For example:

* a range-`for` cannot loop beyond the range of the container to which it is applied
* a `v.begin(),v.end()` is easily determined to be bounds safe

Such loops are as fast as any unchecked/unsafe equivalent.

Often a simple pre-check can eliminate the need for checking of individual indices.
For example

* for `v.begin(),v.begin()+i` the `i` can easily be checked against `v.size()`

Such loops can be much faster than individually checked element accesses.

##### Example, bad

    void f()
    {
        array<int, 10> a, b;
        memset(a.data(), 0, 10);         // BAD, and contains a length error (length = 10 * sizeof(int))
        memcmp(a.data(), b.data(), 10);  // BAD, and contains a length error (length = 10 * sizeof(int))
    }

Also, `std::array<>::fill()` or `std::fill()` or even an empty initializer are better candidate than `memset()`.

##### Example, good

    void f()
    {
        array<int, 10> a, b, c{};       // c is initialized to zero
        a.fill(0);
        fill(b.begin(), b.end(), 0);    // std::fill()
        fill(b, 0);                     // std::fill() + Ranges TS

        if ( a == b ) {
          // ...
        }
    }

##### Example

If code is using an unmodified standard library, then there are still workarounds that enable use of `std::array` and `std::vector` in a bounds-safe manner. Code can call the `.at()` member function on each class, which will result in an `std::out_of_range` exception being thrown. Alternatively, code can call the `at()` free function, which will result in fail-fast (or a customized action) on a bounds violation.

    void f(std::vector<int>& v, std::array<int, 12> a, int i)
    {
        v[0] = a[0];        // BAD
        v.at(0) = a[0];     // OK (alternative 1)
        at(v, 0) = a[0];    // OK (alternative 2)

        v.at(0) = a[i];     // BAD
        v.at(0) = a.at(i);  // OK (alternative 1)
        v.at(0) = at(a, i); // OK (alternative 2)
    }

##### Enforcement

* Issue a diagnostic for any call to a standard-library function that is not bounds-checked.
??? insert link to a list of banned functions

This rule is part of the [bounds profile](#SS-bounds).


### <a name="Rsl-copy"></a>SL.con.4: don't use `memset` or `memcpy` for arguments that are not trivially-copyable

##### Reason

Doing so messes the semantics of the objects (e.g., by overwriting a `vptr`).

##### Note

Similarly for (w)memset, (w)memcpy, (w)memmove, and (w)memcmp

##### Example

    struct base {
        virtual void update() = 0;
    };

    struct derived : public base {
        void update() override {}
    };


    void f(derived& a, derived& b) // goodbye v-tables
    {
        memset(&a, 0, sizeof(derived));
        memcpy(&a, &b, sizeof(derived));
        memcmp(&a, &b, sizeof(derived));
    }

Instead, define proper default initialization, copy, and comparison functions

    void g(derived& a, derived& b)
    {
        a = {};    // default initialize
        b = a;     // copy
        if (a == b) do_something(a, b);
    }

##### Enforcement

* Flag the use of those functions for types that are not trivially copyable

**TODO Notes**:

* Impact on the standard library will require close coordination with WG21, if only to ensure compatibility even if never standardized.
* We are considering specifying bounds-safe overloads for stdlib (especially C stdlib) functions like `memcmp` and shipping them in the GSL.
* For existing stdlib functions and types like `vector` that are not fully bounds-checked, the goal is for these features to be bounds-checked when called from code with the bounds profile on, and unchecked when called from legacy code, possibly using contracts (concurrently being proposed by several WG21 members).



## <a name="SS-string"></a>SL.str: String

Text manipulation is a huge topic.
`std::string` doesn't cover all of it.
This section primarily tries to clarify `std::string`'s relation to `char*`, `zstring`, `string_view`, and `gsl::string_span`.
The important issue of non-ASCII character sets and encodings (e.g., `wchar_t`, Unicode, and UTF-8) will be covered elsewhere.

**See also**: [regular expressions](#SS-regex)

Here, we use "sequence of characters" or "string" to refer to a sequence of characters meant to be read as text (somehow, eventually).
We don't consider ???

String summary:

* [SL.str.1: Use `std::string` to own character sequences](#Rstr-string)
* [SL.str.2: Use `std::string_view` or `gsl::string_span` to refer to character sequences](#Rstr-view)
* [SL.str.3: Use `zstring` or `czstring` to refer to a C-style, zero-terminated, sequence of characters](#Rstr-zstring)
* [SL.str.4: Use `char*` to refer to a single character](#Rstr-char*)
* [SL.str.5: Use `std::byte` to refer to byte values that do not necessarily represent characters](#Rstr-byte)

* [SL.str.10: Use `std::string` when you need to perform locale-sensitive string operations](#Rstr-locale)
* [SL.str.11: Use `gsl::string_span` rather than `std::string_view` when you need to mutate a string](#Rstr-span)
* [SL.str.12: Use the `s` suffix for string literals meant to be standard-library `string`s](#Rstr-s)

**See also**:

* [F.24 span](#Rf-range)
* [F.25 zstring](#Rf-zstring)


### <a name="Rstr-string"></a>SL.str.1: Use `std::string` to own character sequences

##### Reason

`string` correctly handles allocation, ownership, copying, gradual expansion, and offers a variety of useful operations.

##### Example

    vector<string> read_until(const string& terminator)
    {
        vector<string> res;
        for (string s; cin >> s && s != terminator; ) // read a word
            res.push_back(s);
        return res;
    }

Note how `>>` and `!=` are provided for `string` (as examples of useful operations) and there are no explicit
allocations, deallocations, or range checks (`string` takes care of those).

In C++17, we might use `string_view` as the argument, rather than `const string*` to allow more flexibility to callers:

    vector<string> read_until(string_view terminator)   // C++17
    {
        vector<string> res;
        for (string s; cin >> s && s != terminator; ) // read a word
            res.push_back(s);
        return res;
    }

The `gsl::string_span` is a current alternative offering most of the benefits of `std::string_view` for simple examples:

    vector<string> read_until(string_span terminator)
    {
        vector<string> res;
        for (string s; cin >> s && s != terminator; ) // read a word
            res.push_back(s);
        return res;
    }

##### Example, bad

Don't use C-style strings for operations that require non-trivial memory management

    char* cat(const char* s1, const char* s2)   // beware!
        // return s1 + '.' + s2
    {
        int l1 = strlen(s1);
        int l2 = strlen(s2);
        char* p = (char*) malloc(l1 + l2 + 2);
        strcpy(p, s1, l1);
        p[l1] = '.';
        strcpy(p + l1 + 1, s2, l2);
        p[l1 + l2 + 1] = 0;
        return p;
    }

Did we get that right?
Will the caller remember to `free()` the returned pointer?
Will this code pass a security review?

##### Note

Do not assume that `string` is slower than lower-level techniques without measurement and remember that not all code is performance critical.
[Don't optimize prematurely](#Rper-Knuth)

##### Enforcement

???

### <a name="Rstr-view"></a>SL.str.2: Use `std::string_view` or `gsl::string_span` to refer to character sequences

##### Reason

`std::string_view` or `gsl::string_span` provides simple and (potentially) safe access to character sequences independently of how
those sequences are allocated and stored.

##### Example

    vector<string> read_until(string_span terminator);

    void user(zstring p, const string& s, string_span ss)
    {
        auto v1 = read_until(p);
        auto v2 = read_until(s);
        auto v3 = read_until(ss);
        // ...
    }

##### Note

`std::string_view` (C++17) is read-only.

##### Enforcement

???

### <a name="Rstr-zstring"></a>SL.str.3: Use `zstring` or `czstring` to refer to a C-style, zero-terminated, sequence of characters

##### Reason

Readability.
Statement of intent.
A plain `char*` can be a pointer to a single character, a pointer to an array of characters, a pointer to a C-style (zero-terminated) string, or even to a small integer.
Distinguishing these alternatives prevents misunderstandings and bugs.

##### Example

    void f1(const char* s); // s is probably a string

All we know is that it is supposed to be the nullptr or point to at least one character

    void f1(zstring s);     // s is a C-style string or the nullptr
    void f1(czstring s);    // s is a C-style string constant or the nullptr
    void f1(std::byte* s);  // s is a pointer to a byte (C++17)

##### Note

Don't convert a C-style string to `string` unless there is a reason to.

##### Note

Like any other "plain pointer", a `zstring` should not represent ownership.

##### Note

There are billions of lines of C++ "out there", most use `char*` and `const char*` without documenting intent.
They are used in a wide variety of ways, including to represent ownership and as generic pointers to memory (instead of `void*`).
It is hard to separate these uses, so this guideline is hard to follow.
This is one of the major sources of bugs in C and C++ programs, so it is worthwhile to follow this guideline wherever feasible..

##### Enforcement

* Flag uses of `[]` on a `char*`
* Flag uses of `delete` on a `char*`
* Flag uses of `free()` on a `char*`

### <a name="Rstr-char*"></a>SL.str.4: Use `char*` to refer to a single character

##### Reason

The variety of uses of `char*` in current code is a major source of errors.

##### Example, bad

    char arr[] = {'a', 'b', 'c'};

    void print(const char* p)
    {
        cout << p << '\n';
    }

    void use()
    {
        print(arr);   // run-time error; potentially very bad
    }

The array `arr` is not a C-style string because it is not zero-terminated.

##### Alternative

See [`zstring`](#Rstr-zstring), [`string`](#Rstr-string), and [`string_span`](#Rstr-view).

##### Enforcement

* Flag uses of `[]` on a `char*`

### <a name="Rstr-byte"></a>SL.str.5: Use `std::byte` to refer to byte values that do not necessarily represent characters

##### Reason

Use of `char*` to represent a pointer to something that is not necessarily a character causes confusion
and disables valuable optimizations.

##### Example

    ???

##### Note

C++17

##### Enforcement

???


### <a name="Rstr-locale"></a>SL.str.10: Use `std::string` when you need to perform locale-sensitive string operations

##### Reason

`std::string` supports standard-library [`locale` facilities](#Rstr-locale)

##### Example

    ???

##### Note

???

##### Enforcement

???

### <a name="Rstr-span"></a>SL.str.11: Use `gsl::string_span` rather than `std::string_view` when you need to mutate a string

##### Reason

`std::string_view` is read-only.

##### Example

???

##### Note

???

##### Enforcement

The compiler will flag attempts to write to a `string_view`.

### <a name="Rstr-s"></a>SL.str.12: Use the `s` suffix for string literals meant to be standard-library `string`s

##### Reason

Direct expression of an idea minimizes mistakes.

##### Example

    auto pp1 = make_pair("Tokyo", 9.00);         // {C-style string,double} intended?
    pair<string, double> pp2 = {"Tokyo", 9.00};  // a bit verbose
    auto pp3 = make_pair("Tokyo"s, 9.00);        // {std::string,double}    // C++14
    pair pp4 = {"Tokyo"s, 9.00};                 // {std::string,double}    // C++17



##### Enforcement

???


## <a name="SS-io"></a>SL.io: Iostream

`iostream`s is a type safe, extensible, formatted and unformatted I/O library for streaming I/O.
It supports multiple (and user extensible) buffering strategies and multiple locales.
It can be used for conventional I/O, reading and writing to memory (string streams),
and user-defines extensions, such as streaming across networks (asio: not yet standardized).

Iostream rule summary:

* [SL.io.1: Use character-level input only when you have to](#Rio-low)
* [SL.io.2: When reading, always consider ill-formed input](#Rio-validate)
* [SL.io.3: Prefer iostreams for I/O](#Rio-streams)
* [SL.io.10: Unless you use `printf`-family functions call `ios_base::sync_with_stdio(false)`](#Rio-sync)
* [SL.io.50: Avoid `endl`](#Rio-endl)
* [???](#???)

### <a name="Rio-low"></a>SL.io.1: Use character-level input only when you have to

##### Reason

Unless you genuinely just deal with individual characters, using character-level input leads to the user code performing potentially error-prone
and potentially inefficient composition of tokens out of characters.

##### Example

    char c;
    char buf[128];
    int i = 0;
    while (cin.get(c) && !isspace(c) && i < 128)
        buf[i++] = c;
    if (i == 128) {
        // ... handle too long string ....
    }

Better (much simpler and probably faster):

    string s;
    s.reserve(128);
    cin >> s;

and the `reserve(128)` is probably not worthwhile.

##### Enforcement

???


### <a name="Rio-validate"></a>SL.io.2: When reading, always consider ill-formed input

##### Reason

Errors are typically best handled as soon as possible.
If input isn't validated, every function must be written to cope with bad data (and that is not practical).

##### Example

    ???

##### Enforcement

???

### <a name="Rio-streams"></a>SL.io.3: Prefer `iostream`s for I/O

##### Reason

`iostream`s are safe, flexible, and extensible.

##### Example

    // write a complex number:
    complex<double> z{ 3, 4 };
    cout << z << '\n';

`complex` is a user-defined type and its I/O is defined without modifying the `iostream` library.

##### Example

    // read a file of complex numbers:
    for (complex<double> z; cin >> z; )
        v.push_back(z);

##### Exception

??? performance ???

##### Discussion: `iostream`s vs. the `printf()` family

It is often (and often correctly) pointed out that the `printf()` family has two advantages compared to `iostream`s:
flexibility of formatting and performance.
This has to be weighed against `iostream`s advantages of extensibility to handle user-defined types, resilient against security violations,
implicit memory management, and `locale` handling.

If you need I/O performance, you can almost always do better than `printf()`.

`gets()`, `scanf()` using `%s`, and `printf()` using `%s` are security hazards (vulnerable to buffer overflow and generally error-prone).
C11 defines some "optional extensions" that do extra checking of their arguments.
If present in your C library, `gets_s()`, `scanf_s()`, and `printf_s()` may be safer alternatives, but they are still not type safe.

##### Enforcement

Optionally flag `<cstdio>` and `<stdio.h>`.

### <a name="Rio-sync"></a>SL.io.10: Unless you use `printf`-family functions call `ios_base::sync_with_stdio(false)`

##### Reason

Synchronizing `iostreams` with `printf-style` I/O can be costly.
`cin` and `cout` are by default synchronized with `printf`.

##### Example

    int main()
    {
        ios_base::sync_with_stdio(false);
        // ... use iostreams ...
    }

##### Enforcement

???

### <a name="Rio-endl"></a>SL.io.50: Avoid `endl`

##### Reason

The `endl` manipulator is mostly equivalent to `'\n'` and `"\n"`;
as most commonly used it simply slows down output by doing redundant `flush()`s.
This slowdown can be significant compared to `printf`-style output.

##### Example

    cout << "Hello, World!" << endl;    // two output operations and a flush
    cout << "Hello, World!\n";          // one output operation and no flush

##### Note

For `cin`/`cout` (and equivalent) interaction, there is no reason to flush; that's done automatically.
For writing to a file, there is rarely a need to `flush`.

##### Note

Apart from the (occasionally important) issue of performance,
the choice between `'\n'` and `endl` is almost completely aesthetic.

## <a name="SS-regex"></a>SL.regex: Regex

`<regex>` is the standard C++ regular expression library.
It supports a variety of regular expression pattern conventions.

## <a name="SS-chrono"></a>SL.chrono: Time

`<chrono>` (defined in namespace `std::chrono`) provides the notions of `time_point` and `duration` together with functions for
outputting time in various units.
It provides clocks for registering `time_points`.

## <a name="SS-clib"></a>SL.C: The C Standard Library

???

C Standard Library rule summary:

* [S.C.1: Don't use setjmp/longjmp](#Rclib-jmp)
* [???](#???)
* [???](#???)

### <a name="Rclib-jmp"></a>SL.C.1: Don't use setjmp/longjmp

##### Reason

a `longjmp` ignores destructors, thus invalidating all resource-management strategies relying on RAII

##### Enforcement

Flag all occurrences of `longjmp`and `setjmp`



# <a name="S-A"></a>A: Architectural ideas

This section contains ideas about higher-level architectural ideas and libraries.

Architectural rule summary:

* [A.1: Separate stable code from less stable code](#Ra-stable)
* [A.2: Express potentially reusable parts as a library](#Ra-lib)
* [A.4: There should be no cycles among libraries](#Ra-dag)
* [???](#???)
* [???](#???)
* [???](#???)
* [???](#???)
* [???](#???)
* [???](#???)

### <a name="Ra-stable"></a>A.1: Separate stable code from less stable code

Isolating less stable code facilitates its unit testing, interface improvement, refactoring, and eventual deprecation.

### <a name="Ra-lib"></a>A.2: Express potentially reusable parts as a library

##### Reason

##### Note

A library is a collection of declarations and definitions maintained, documented, and shipped together.
A library could be a set of headers (a "header-only library") or a set of headers plus a set of object files.
You can statically or dynamically link a library into a program, or you can `#include` a header-only library.


### <a name="Ra-dag"></a>A.4: There should be no cycles among libraries

##### Reason

* A cycle complicates the build process.
* Cycles are hard to understand and may introduce indeterminism (unspecified behavior).

##### Note

A library can contain cyclic references in the definition of its components.
For example:

    ???

However, a library should not depend on another that depends on it.


# <a name="S-not"></a>NR: Non-Rules and myths

This section contains rules and guidelines that are popular somewhere, but that we deliberately don't recommend.
We know full well that there have been times and places where these rules made sense, and we have used them ourselves at times.
However, in the context of the styles of programming we recommend and support with the guidelines, these "non-rules" would do harm.

Even today, there can be contexts where the rules make sense.
For example, lack of suitable tool support can make exceptions unsuitable in hard-real-time systems,
but please don't blindly trust "common wisdom" (e.g., unsupported statements about "efficiency");
such "wisdom" may be based on decades-old information or experienced from languages with very different properties than C++
(e.g., C or Java).

The positive arguments for alternatives to these non-rules are listed in the rules offered as "Alternatives".

Non-rule summary:

* [NR.1: Don't insist that all declarations should be at the top of a function](#Rnr-top)
* [NR.2: Don't insist to have only a single `return`-statement in a function](#Rnr-single-return)
* [NR.3: Don't avoid exceptions](#Rnr-no-exceptions)
* [NR.4: Don't insist on placing each class declaration in its own source file](#Rnr-lots-of-files)
* [NR.5: Don't use two-phase initialization](#Rnr-two-phase-init)
* [NR.6: Don't place all cleanup actions at the end of a function and `goto exit`](#Rnr-goto-exit)
* [NR.7: Don't make all data members `protected`](#Rnr-protected-data)
* ???

### <a name="Rnr-top"></a>NR.1: Don't insist that all declarations should be at the top of a function

##### Reason

The "all declarations on top" rule is a legacy of old programming languages that didn't allow initialization of variables and constants after a statement.
This leads to longer programs and more errors caused by uninitialized and wrongly initialized variables.

##### Example, bad

    int use(int x)
    {
        int i;
        char c;
        double d;

        // ... some stuff ...

        if (x < i) {
            // ...
            i = f(x, d);
        }
        if (i < x) {
            // ...
            i = g(x, c);
        }
        return i;
    }

The larger the distance between the uninitialized variable and its use, the larger the chance of a bug.
Fortunately, compilers catch many "used before set" errors.
Unfortunately, compilers cannot catch all such errors and unfortunately, the bugs aren't always as simple to spot as in this small example.


##### Alternative

* [Always initialize an object](#Res-always)
* [ES.21: Don't introduce a variable (or constant) before you need to use it](#Res-introduce)

### <a name="Rnr-single-return"></a>NR.2: Don't insist to have only a single `return`-statement in a function

##### Reason

The single-return rule can lead to unnecessarily convoluted code and the introduction of extra state variables.
In particular, the single-return rule makes it harder to concentrate error checking at the top of a function.

##### Example

    template<class T>
    //  requires Number<T>
    string sign(T x)
    {
        if (x < 0)
            return "negative";
        else if (x > 0)
            return "positive";
        return "zero";
    }

to use a single return only we would have to do something like

    template<class T>
    //  requires Number<T>
    string sign(T x)        // bad
    {
        string res;
        if (x < 0)
            res = "negative";
        else if (x > 0)
            res = "positive";
        else
            res = "zero";
        return res;
    }

This is both longer and likely to be less efficient.
The larger and more complicated the function is, the more painful the workarounds get.
Of course many simple functions will naturally have just one `return` because of their simpler inherent logic.

##### Example

    int index(const char* p)
    {
        if (!p) return -1;  // error indicator: alternatively "throw nullptr_error{}"
        // ... do a lookup to find the index for p
        return i;
    }

If we applied the rule, we'd get something like

    int index2(const char* p)
    {
        int i;
        if (!p)
            i = -1;  // error indicator
        else {
            // ... do a lookup to find the index for p
        }
        return i;
    }

Note that we (deliberately) violated the rule against uninitialized variables because this style commonly leads to that.
Also, this style is a temptation to use the [goto exit](#Rnr-goto-exit) non-rule.

##### Alternative

* Keep functions short and simple
* Feel free to use multiple `return` statements (and to throw exceptions).

### <a name="Rnr-no-exceptions"></a>NR.3: Don't avoid exceptions

##### Reason

There seem to be four main reasons given for not using exceptions:

* exceptions are inefficient
* exceptions lead to leaks and errors
* exception performance is not predictable
* the exception-handling run-time support takes up too much space

There is no way we can settle this issue to the satisfaction of everybody.
After all, the discussions about exceptions have been going on for 40+ years.
Some languages cannot be used without exceptions, but others do not support them.
This leads to strong traditions for the use and non-use of exceptions, and to heated debates.

However, we can briefly outline why we consider exceptions the best alternative for general-purpose programming
and in the context of these guidelines.
Simple arguments for and against are often inconclusive.
There are specialized applications where exceptions indeed can be inappropriate
(e.g., hard-real-time systems without support for reliable estimates of the cost of handling an exception).

Consider the major objections to exceptions in turn

* Exceptions are inefficient:
Compared to what?
When comparing make sure that the same set of errors are handled and that they are handled equivalently.
In particular, do not compare a program that immediately terminate on seeing an error with a program
that carefully cleans up resources before logging an error.
Yes, some systems have poor exception handling implementations; sometimes, such implementations force us to use
other error-handling approaches, but that's not a fundamental problem with exceptions.
When using an efficiency argument - in any context - be careful that you have good data that actually provides
insight into the problem under discussion.
* Exceptions lead to leaks and errors.
They do not.
If your program is a rat's nest of pointers without an overall strategy for resource management,
you have a problem whatever you do.
If your system consists of a million lines of such code,
you probably will not be able to use exceptions,
but that's a problem with excessive and undisciplined pointer use, rather than with exceptions.
In our opinion, you need RAII to make exception-based error handling simple and safe -- simpler and safer than alternatives.
* Exception performance is not predictable.
If you are in a hard-real-time system where you must guarantee completion of a task in a given time,
you need tools to back up such guarantees.
As far as we know such tools are not available (at least not to most programmers).
* the exception-handling run-time support takes up too much space
This can be the case in small (usually embedded systems).
However, before abandoning exceptions consider what space consistent error-handling using error-codes would require
and what failure to catch an error would cost.

Many, possibly most, problems with exceptions stem from historical needs to interact with messy old code.

The fundamental arguments for the use of exceptions are

* They clearly differentiate between erroneous return and ordinary return
* They cannot be forgotten or ignored
* They can be used systematically

Remember

* Exceptions are for reporting errors (in C++; other languages can have different uses for exceptions).
* Exceptions are not for errors that can be handled locally.
* Don't try to catch every exception in every function (that's tedious, clumsy, and leads to slow code).
* Exceptions are not for errors that require instant termination of a module/system after a non-recoverable error.

##### Example

    ???

##### Alternative

* [RAII](#Re-raii)
* Contracts/assertions: Use GSL's `Expects` and `Ensures` (until we get language support for contracts)

### <a name="Rnr-lots-of-files"></a>NR.4: Don't insist on placing each class declaration in its own source file

##### Reason

The resulting number of files from placing each class in its own file are hard to manage and can slow down compilation.
Individual classes are rarely a good logical unit of maintenance and distribution.

##### Example

    ???

##### Alternative

* Use namespaces containing logically cohesive sets of classes and functions.

### <a name="Rnr-two-phase-init"></a>NR.5: Don't use two-phase initialization

##### Reason

Splitting initialization into two leads to weaker invariants,
more complicated code (having to deal with semi-constructed objects),
and errors (when we didn't deal correctly with semi-constructed objects consistently).

##### Example, bad

    class Picture
    {
        int mx;
        int my;
        char * data;
    public:
        Picture(int x, int y)
        {
            mx = x,
            my = y;
            data = nullptr;
        }

        ~Picture()
        {
            Cleanup();
        }

        bool Init()
        {
            // invariant checks
            if (mx <= 0 || my <= 0) {
                return false;
            }
            if (data) {
                return false;
            }
            data = (char*) malloc(mx*my*sizeof(int));
            return data != nullptr;
        }

        void Cleanup()
        {
            if (data) free(data);
            data = nullptr;
        }
    };

    Picture picture(100, 0); // not ready-to-use picture here
    // this will fail..
    if (!picture.Init()) {
        puts("Error, invalid picture");
    }
    // now have a invalid picture object instance.

##### Example, good

    class Picture
    {
        size_t mx;
        size_t my;
        vector<char> data;

        static size_t check_size(size_t s)
        {
            // invariant check
            Expects(s > 0);
            return s;
        }

    public:
        // even more better would be a class for a 2D Size as one single parameter
        Picture(size_t x, size_t y)
            : mx(check_size(x))
            , my(check_size(y))
            // now we know x and y have a valid size
            , data(mx * my * sizeof(int)) // will throw std::bad_alloc on error
        {
            // picture is ready-to-use
        }
        // compiler generated dtor does the job. (also see C.21)
    };

    Picture picture1(100, 100);
    // picture is ready-to-use here...

    // not a valid size for y,
    // default contract violation behavior will call std::terminate then
    Picture picture2(100, 0);
    // not reach here...

##### Alternative

* Always establish a class invariant in a constructor.
* Don't define an object before it is needed.

### <a name="Rnr-goto-exit"></a>NR.6: Don't place all cleanup actions at the end of a function and `goto exit`

##### Reason

`goto` is error-prone.
This technique is a pre-exception technique for RAII-like resource and error handling.

##### Example, bad

    void do_something(int n)
    {
        if (n < 100) goto exit;
        // ...
        int* p = (int*) malloc(n);
        // ...
        if (some_error) goto_exit;
        // ...
    exit:
        free(p);
    }

and spot the bug.

##### Alternative

* Use exceptions and [RAII](#Re-raii)
* for non-RAII resources, use [`finally`](#Re-finally).

### <a name="Rnr-protected-data"></a>NR.7: Don't make all data members `protected`

##### Reason

`protected` data is a source of errors.
`protected` data can be manipulated from an unbounded amount of code in various places.
`protected` data is the class hierarchy equivalent to global data.

##### Example

    ???

##### Alternative

* [Make member data `public` or (preferably) `private`](#Rh-protected)


# <a name="S-references"></a>RF: References

Many coding standards, rules, and guidelines have been written for C++, and especially for specialized uses of C++.
Many

* focus on lower-level issues, such as the spelling of identifiers
* are written by C++ novices
* see "stopping programmers from doing unusual things" as their primary aim
* aim at portability across many compilers (some 10 years old)
* are written to preserve decades old code bases
* aim at a single application domain
* are downright counterproductive
* are ignored (must be ignored by programmers to get their work done well)

A bad coding standard is worse than no coding standard.
However an appropriate set of guidelines are much better than no standards: "Form is liberating."

Why can't we just have a language that allows all we want and disallows all we don't want ("a perfect language")?
Fundamentally, because affordable languages (and their tool chains) also serve people with needs that differ from yours and serve more needs than you have today.
Also, your needs change over time and a general-purpose language is needed to allow you to adapt.
A language that is ideal for today would be overly restrictive tomorrow.

Coding guidelines adapt the use of a language to specific needs.
Thus, there cannot be a single coding style for everybody.
We expect different organizations to provide additions, typically with more restrictions and firmer style rules.

Reference sections:

* [RF.rules: Coding rules](#SS-rules)
* [RF.books: Books with coding guidelines](#SS-books)
* [RF.C++: C++ Programming (C++11/C++14/C++17)](#SS-Cplusplus)
* [RF.web: Websites](#SS-web)
* [RS.video: Videos about "modern C++"](#SS-vid)
* [RF.man: Manuals](#SS-man)
* [RF.core: Core Guidelines materials](#SS-core)

## <a name="SS-rules"></a>RF.rules: Coding rules

* [AUTOSAR Guidelines for the use of the C++14 language in critical and safety-related systems v17.10](https://www.autosar.org/fileadmin/user_upload/standards/adaptive/17-10/AUTOSAR_RS_CPP14Guidelines.pdf)
* [Boost Library Requirements and Guidelines](http://www.boost.org/development/requirements.html).
  ???.
* [Bloomberg: BDE C++ Coding](https://github.com/bloomberg/bde/wiki/CodingStandards.pdf).
  Has a strong emphasis on code organization and layout.
* Facebook: ???
* [GCC Coding Conventions](https://gcc.gnu.org/codingconventions.html).
  C++03 and (reasonably) a bit backwards looking.
* [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html).
  Geared toward C++03 and (also) older code bases. Google experts are now actively collaborating here on helping to improve these Guidelines, and hopefully to merge efforts so these can be a modern common set they could also recommend.
* [JSF++: JOINT STRIKE FIGHTER AIR VEHICLE C++ CODING STANDARDS](http://www.stroustrup.com/JSF-AV-rules.pdf).
  Document Number 2RDU00001 Rev C. December 2005.
  For flight control software.
  For hard-real-time.
  This means that it is necessarily very restrictive ("if the program fails somebody dies").
  For example, no free store allocation or deallocation may occur after the plane takes off (no memory overflow and no fragmentation allowed).
  No exception may be used (because there was no available tool for guaranteeing that an exception would be handled within a fixed short time).
  Libraries used have to have been approved for mission critical applications.
  Any similarities to this set of guidelines are unsurprising because Bjarne Stroustrup was an author of JSF++.
  Recommended, but note its very specific focus.
* [_MISRA C++ 2008: Guidelines for the use of the C++ language in critical systems_] (https://www.misra.org.uk/Buyonline/tabid/58/Default.aspx).
* [Mozilla Portability Guide](https://developer.mozilla.org/en-US/docs/Mozilla/C%2B%2B_Portability_Guide).
  As the name indicates, this aims for portability across many (old) compilers.
  As such, it is restrictive.
* [Geosoft.no: C++ Programming Style Guidelines](http://geosoft.no/development/cppstyle.html).
  ???.
* [Possibility.com: C++ Coding Standard](http://www.possibility.com/Cpp/CppCodingStandard.html).
  ???.
* [SEI CERT: Secure C++ Coding Standard](https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=637).
  A very nicely done set of rules (with examples and rationales) done for security-sensitive code.
  Many of their rules apply generally.
* [High Integrity C++ Coding Standard](http://www.codingstandard.com/).
* [llvm](http://llvm.org/docs/CodingStandards.html).
  Somewhat brief, based on C++14, and (not unreasonably) adjusted to its domain.
* ???

## <a name="SS-books"></a>RF.books: Books with coding guidelines

* [Meyers96](#Meyers96) Scott Meyers: *More Effective C++*. Addison-Wesley 1996.
* [Meyers97](#Meyers97) Scott Meyers: *Effective C++, Second Edition*. Addison-Wesley 1997.
* [Meyers01](#Meyers01) Scott Meyers: *Effective STL*. Addison-Wesley 2001.
* [Meyers05](#Meyers05) Scott Meyers: *Effective C++, Third Edition*. Addison-Wesley 2005.
* [Meyers15](#Meyers15) Scott Meyers: *Effective Modern C++*. O'Reilly 2015.
* [SuttAlex05](#SuttAlex05) Sutter and Alexandrescu: *C++ Coding Standards*. Addison-Wesley 2005. More a set of meta-rules than a set of rules. Pre-C++11.
* [Stroustrup05](#Stroustrup05) Bjarne Stroustrup: [A rationale for semantically enhanced library languages](http://www.stroustrup.com/SELLrationale.pdf).
  LCSD05. October 2005.
* [Stroustrup14](#Stroustrup05) Stroustrup: [A Tour of C++](http://www.stroustrup.com/Tour.html).
  Addison Wesley 2014.
  Each chapter ends with an advice section consisting of a set of recommendations.
* [Stroustrup13](#Stroustrup13) Stroustrup: [The C++ Programming Language (4th Edition)](http://www.stroustrup.com/4th.html).
  Addison Wesley 2013.
  Each chapter ends with an advice section consisting of a set of recommendations.
* Stroustrup: [Style Guide](http://www.stroustrup.com/Programming/PPP-style.pdf)
  for [Programming: Principles and Practice using C++](http://www.stroustrup.com/programming.html).
  Mostly low-level naming and layout rules.
  Primarily a teaching tool.

## <a name="SS-Cplusplus"></a>RF.C++: C++ Programming (C++11/C++14)

* [TC++PL4](http://www.stroustrup.com/4th.html):
A thorough description of the C++ language and standard libraries for experienced programmers.
* [Tour++](http://www.stroustrup.com/Tour.html):
An overview of the C++ language and standard libraries for experienced programmers.
* [Programming: Principles and Practice using C++](http://www.stroustrup.com/programming.html):
A textbook for beginners and relative novices.

## <a name="SS-web"></a>RF.web: Websites

* [isocpp.org](https://isocpp.org)
* [Bjarne Stroustrup's home pages](http://www.stroustrup.com)
* [WG21](http://www.open-std.org/jtc1/sc22/wg21/)
* [Boost](http://www.boost.org)<a name="Boost"></a>
* [Adobe open source](http://www.adobe.com/open-source.html)
* [Poco libraries](http://pocoproject.org/)
* Sutter's Mill?
* ???

## <a name="SS-vid"></a>RS.video: Videos about "modern C++"

* Bjarne Stroustrup: [C++11 Style](http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style). 2012.
* Bjarne Stroustrup: [The Essence of C++: With Examples in C++84, C++98, C++11, and C++14](http://channel9.msdn.com/Events/GoingNative/2013/Opening-Keynote-Bjarne-Stroustrup). 2013
* All the talks from [CppCon '14](https://isocpp.org/blog/2014/11/cppcon-videos-c9)
* Bjarne Stroustrup: [The essence of C++](https://www.youtube.com/watch?v=86xWVb4XIyE) at the University of Edinburgh. 2014.
* Bjarne Stroustrup: [The Evolution of C++ Past, Present and Future](https://www.youtube.com/watch?v=_wzc7a3McOs). CppCon 2016 keynote.
* Bjarne Stroustrup: [Make Simple Tasks Simple!](https://www.youtube.com/watch?v=nesCaocNjtQ). CppCon 2014 keynote.
* Bjarne Stroustrup: [Writing Good C++14](https://www.youtube.com/watch?v=1OEu9C51K2A). CppCon 2015 keynote about the Core Guidelines.
* Herb Sutter: [Writing Good C++14... By Default](https://www.youtube.com/watch?v=hEx5DNLWGgA). CppCon 2015 keynote about the Core Guidelines.
* CppCon 15
* ??? C++ Next
* ??? Meting C++
* ??? more ???

## <a name="SS-man"></a>RF.man: Manuals

* ISO C++ Standard C++11.
* ISO C++ Standard C++14.
* [ISO C++ Standard C++17](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf). Committee Draft.
* [Palo Alto "Concepts" TR](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf).
* [ISO C++ Concepts TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf).
* [WG21 Ranges report](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf). Draft.


## <a name="SS-core"></a>RF.core: Core Guidelines materials

This section contains materials that has been useful for presenting the core guidelines and the ideas behind them:

* [Our documents directory](https://github.com/isocpp/CppCoreGuidelines/tree/master/docs)
* Stroustrup, Sutter, and Dos Reis: [A brief introduction to C++'s model for type- and resource-safety](http://www.stroustrup.com/resource-model.pdf). A paper with lots of examples.
* Sergey Zubkov: [a Core Guidelines talk](https://www.youtube.com/watch?v=DyLwdl_6vmU)
and here are the [slides](http://2017.cppconf.ru/talks/sergey-zubkov). In Russian. 2017.
* Neil MacIntosh: [The Guideline Support Library: One Year Later](https://www.youtube.com/watch?v=_GhNnCuaEjo). CppCon 2016.
* Bjarne Stroustrup: [Writing Good C++14](https://www.youtube.com/watch?v=1OEu9C51K2A). CppCon 2015 keynote.
* Herb Sutter: [Writing Good C++14... By Default](https://www.youtube.com/watch?v=hEx5DNLWGgA). CppCon 2015 keynote.
* Peter Sommerlad: [C++ Core Guidelines - Modernize your C++ Code Base](https://www.youtube.com/watch?v=fQ926v4ZzAM). ACCU 2017.
* Bjarne Stroustrup: [No Littering!](https://www.youtube.com/watch?v=01zI9kV4h8c). Bay Area ACCU 2016.
It gives some idea of the ambition level for the Core Guidelines.

Note that slides for CppCon presentations are available (links with the posted videos).

Contributions to this list would be most welcome.

## <a name="SS-ack"></a>Acknowledgements

Thanks to the many people who contributed rules, suggestions, supporting information, references, etc.:

* Peter Juhl
* Neil MacIntosh
* Axel Naumann
* Andrew Pardoe
* Gabriel Dos Reis
* Zhuang, Jiangang (Jeff)
* Sergey Zubkov

and see the contributor list on the github.

# <a name="S-profile"></a>Pro: Profiles

Ideally, we would follow all of the guidelines.
That would give the cleanest, most regular, least error-prone, and often the fastest code.
Unfortunately, that is usually impossible because we have to fit our code into large code bases and use existing libraries.
Often, such code has been written over decades and does not follow these guidelines.
We must aim for [gradual adoption](#S-modernizing).

Whatever strategy for gradual adoption we adopt, we need to be able to apply sets of related guidelines to address some set
of problems first and leave the rest until later.
A similar idea of "related guidelines" becomes important when some, but not all, guidelines are considered relevant to a code base
or if a set of specialized guidelines is to be applied for a specialized application area.
We call such a set of related guidelines a "profile".
We aim for such a set of guidelines to be coherent so that they together help us reach a specific goal, such as "absence of range errors"
or "static type safety."
Each profile is designed to eliminate a class of errors.
Enforcement of "random" rules in isolation is more likely to be disruptive to a code base than delivering a definite improvement.

A "profile" is a set of deterministic and portably enforceable subset rules (i.e., restrictions) that are designed to achieve a specific guarantee.
"Deterministic" means they require only local analysis and could be implemented in a compiler (though they don't need to be).
"Portably enforceable" means they are like language rules, so programmers can count on different enforcement tools giving the same answer for the same code.

Code written to be warning-free using such a language profile is considered to conform to the profile.
Conforming code is considered to be safe by construction with regard to the safety properties targeted by that profile.
Conforming code will not be the root cause of errors for that property,
although such errors may be introduced into a program by other code, libraries or the external environment.
A profile may also introduce additional library types to ease conformance and encourage correct code.

Profiles summary:

* [Pro.type: Type safety](#SS-type)
* [Pro.bounds: Bounds safety](#SS-bounds)
* [Pro.lifetime: Lifetime safety](#SS-lifetime)

In the future, we expect to define many more profiles and add more checks to existing profiles.
Candidates include:

* narrowing arithmetic promotions/conversions (likely part of a separate safe-arithmetic profile)
* arithmetic cast from negative floating point to unsigned integral type (ditto)
* selected undefined behavior: Start with Gabriel Dos Reis's UB list developed for the WG21 study group
* selected unspecified behavior: Addressing portability concerns.
* `const` violations: Mostly done by compilers already, but we can catch inappropriate casting and underuse of `const`.

Enabling a profile is implementation defined; typically, it is set in the analysis tool used.

To suppress enforcement of a profile check, place a `suppress` annotation on a language contract. For example:

    [[suppress(bounds)]] char* raw_find(char* p, int n, char x)    // find x in p[0]..p[n - 1]
    {
        // ...
    }

Now `raw_find()` can scramble memory to its heart's content.
Obviously, suppression should be very rare.

## <a name="SS-type"></a>Pro.safety: Type-safety profile

This profile makes it easier to construct code that uses types correctly and avoids inadvertent type punning.
It does so by focusing on removing the primary sources of type violations, including unsafe uses of casts and unions.

For the purposes of this section,
type-safety is defined to be the property that a variable is not used in a way that doesn't obey the rules for the type of its definition.
Memory accessed as a type `T` should not be valid memory that actually contains an object of an unrelated type `U`.
Note that the safety is intended to be complete when combined also with [Bounds safety](#SS-bounds) and [Lifetime safety](#SS-lifetime).

An implementation of this profile shall recognize the following patterns in source code as non-conforming and issue a diagnostic.

Type safety profile summary:

* <a name="Pro-type-avoidcasts"></a>Type.1: [Avoid casts](#Res-casts):
<a name="Pro-type-reinterpretcast">a. </a>Don't use `reinterpret_cast`; A strict version of [Avoid casts](#Res-casts) and [prefer named casts](#Res-casts-named).
<a name="Pro-type-arithmeticcast">b. </a>Don't use `static_cast` for arithmetic types; A strict version of [Avoid casts](#Res-casts) and [prefer named casts](#Res-casts-named).
<a name="Pro-type-identitycast">c. </a>Don't cast between pointer types where the source type and the target type are the same; A strict version of [Avoid casts](#Res-casts).
<a name="Pro-type-implicitpointercast">d. </a>Don't cast between pointer types when the conversion could be implicit; A strict version of [Avoid casts](#Res-casts).
* <a name="Pro-type-downcast"></a>Type.2: Don't use `static_cast` to downcast:
[Use `dynamic_cast` instead](#Rh-dynamic_cast).
* <a name="Pro-type-constcast"></a>Type.3: Don't use `const_cast` to cast away `const` (i.e., at all):
[Don't cast away const](#Res-casts-const).
* <a name="Pro-type-cstylecast"></a>Type.4: Don't use C-style `(T)expression` or functional `T(expression)` casts:
Prefer [construction](#Res-construct) or [named casts](#Res-cast-named).
* <a name="Pro-type-init"></a>Type.5: Don't use a variable before it has been initialized:
[always initialize](#Res-always).
* <a name="Pro-type-memberinit"></a>Type.6: Always initialize a member variable:
[always initialize](#Res-always),
possibly using [default constructors](#Rc-default0) or
[default member initializers](#Rc-in-class-initializers).
* <a name="Pro-type-unon"></a>Type.7: Avoid naked union:
[Use `variant` instead](#Ru-naked).
* <a name="Pro-type-varargs"></a>Type.8: Avoid varargs:
[Don't use `va_arg` arguments](#F-varargs).

##### Impact

With the type-safety profile you can trust that every operation is applied to a valid object.
Exception may be thrown to indicate errors that cannot be detected statically (at compile time).
Note that this type-safety can be complete only if we also have [Bounds safety](#SS-bounds) and [Lifetime safety](#SS-lifetime).
Without those guarantees, a region of memory could be accessed independent of which object, objects, or parts of objects are stored in it.


## <a name="SS-bounds"></a>Pro.bounds: Bounds safety profile

This profile makes it easier to construct code that operates within the bounds of allocated blocks of memory.
It does so by focusing on removing the primary sources of bounds violations: pointer arithmetic and array indexing.
One of the core features of this profile is to restrict pointers to only refer to single objects, not arrays.

We define bounds-safety to be the property that a program does not use an object to access memory outside of the range that was allocated for it.
Bounds safety is intended to be complete only when combined with [Type safety](#SS-type) and [Lifetime safety](#SS-lifetime),
which cover other unsafe operations that allow bounds violations.

Bounds safety profile summary:

* <a name="Pro-bounds-arithmetic"></a>Bounds.1: Don't use pointer arithmetic. Use `span` instead:
[Pass pointers to single objects (only)](#Ri-array) and [Keep pointer arithmetic simple](#Res-ptr).
* <a name="Pro-bounds-arrayindex"></a>Bounds.2: Only index into arrays using constant expressions:
[Pass pointers to single objects (only)](#Ri-array) and [Keep pointer arithmetic simple](#Res-ptr).
* <a name="Pro-bounds-decay"></a>Bounds.3: No array-to-pointer decay:
[Pass pointers to single objects (only)](#Ri-array) and [Keep pointer arithmetic simple](#Res-ptr).
* <a name="Pro-bounds-stdlib"></a>Bounds.4: Don't use standard-library functions and types that are not bounds-checked:
[Use the standard library in a type-safe manner](#Rsl-bounds).

##### Impact

Bounds safety implies that access to an object - notably arrays - does not access beyond the object's memory allocation.
This eliminates a large class of insidious and hard-to-find errors, including the (in)famous "buffer overflow" errors.
This closes security loopholes as well as a prominent source of memory corruption (when writing out of bounds).
Even if an out-of-bounds access is "just a read", it can lead to invariant violations (when the accessed isn't of the assumed type)
and "mysterious values."


## <a name="SS-lifetime"></a>Pro.lifetime: Lifetime safety profile

Accessing through a pointer that doesn't point to anything is a major source of errors,
and very hard to avoid in many traditional C or C++ styles of programming.
For example, a pointer may be uninitialized, the `nullptr`, point beyond the range of an array, or to a deleted object.

[See the current design specification here.](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetime.pdf)

Lifetime safety profile summary:

* <a name="Pro-lifetime-invalid-deref"></a>Lifetime.1: Don't dereference a possibly invalid pointer:
[detect or avoid](#Res-deref).

##### Impact

Once completely enforced through a combination of style rules, static analysis, and library support, this profile

* eliminates one of the major sources of nasty errors in C++
* eliminates a major source of potential security violations
* improves performance by eliminating redundant "paranoia" checks
* increases confidence in correctness of code
* avoids undefined behavior by enforcing a key C++ language rule


# <a name="S-gsl"></a>GSL: Guidelines support library

The GSL is a small library of facilities designed to support this set of guidelines.
Without these facilities, the guidelines would have to be far more restrictive on language details.

The Core Guidelines support library is defined in namespace `gsl` and the names may be aliases for standard library or other well-known library names. Using the (compile-time) indirection through the `gsl` namespace allows for experimentation and for local variants of the support facilities.

The GSL is header only, and can be found at [GSL: Guidelines support library](https://github.com/Microsoft/GSL).
The support library facilities are designed to be extremely lightweight (zero-overhead) so that they impose no overhead compared to using conventional alternatives.
Where desirable, they can be "instrumented" with additional functionality (e.g., checks) for tasks such as debugging.

These Guidelines use types from the standard (e.g., C++17) in addition to ones from the GSL.
For example, we assume a `variant` type, but this is not currently in GSL.
Eventually, use [the one voted into C++17](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0088r3.html).

Some of the GSL types listed below may not be supported in the library you use due to technical reasons such as limitations in the current versions of C++.
Therefore, please consult your GSL documentation to find out more.

Summary of GSL components:

* [GSL.view: Views](#SS-views)
* [GSL.owner](#SS-ownership)
* [GSL.assert: Assertions](#SS-assertions)
* [GSL.util: Utilities](#SS-utilities)
* [GSL.concept: Concepts](#SS-gsl-concepts)

We plan for a "ISO C++ standard style" semi-formal specification of the GSL.

We rely on the ISO C++ Standard Library and hope for parts of the GSL to be absorbed into the standard library.

## <a name="SS-views"></a>GSL.view: Views

These types allow the user to distinguish between owning and non-owning pointers and between pointers to a single object and pointers to the first element of a sequence.

These "views" are never owners.

References are never owners (see [R.4](#Rr-ref). Note: References have many opportunities to outlive the objects they refer to (returning a local variable by reference, holding a reference to an element of a vector and doing `push_back`, binding to `std::max(x, y + 1)`, etc. The Lifetime safety profile aims to address those things, but even so `owner<T&>` does not make sense and is discouraged.

The names are mostly ISO standard-library style (lower case and underscore):

* `T*`      // The `T*` is not an owner, may be null; assumed to be pointing to a single element.
* `T&`      // The `T&` is not an owner and can never be a "null reference"; references are always bound to objects.

The "raw-pointer" notation (e.g. `int*`) is assumed to have its most common meaning; that is, a pointer points to an object, but does not own it.
Owners should be converted to resource handles (e.g., `unique_ptr` or `vector<T>`) or marked `owner<T*>`.

* `owner<T*>`   // a `T*` that owns the object pointed/referred to; may be `nullptr`.

`owner` is used to mark owning pointers in code that cannot be upgraded to use proper resource handles.
Reasons for that include:

* Cost of conversion.
* The pointer is used with an ABI.
* The pointer is part of the implementation of a resource handle.

An `owner<T>` differs from a resource handle for a `T` by still requiring an explicit `delete`.

An `owner<T>` is assumed to refer to an object on the free store (heap).

If something is not supposed to be `nullptr`, say so:

* `not_null<T>`   // `T` is usually a pointer type (e.g., `not_null<int*>` and `not_null<owner<Foo*>>`) that may not be `nullptr`.
  `T` can be any type for which `==nullptr` is meaningful.

* `span<T>`       // `[p:p+n)`, constructor from `{p, q}` and `{p, n}`; `T` is the pointer type
* `span_p<T>`     // `{p, predicate}` `[p:q)` where `q` is the first element for which `predicate(*p)` is true
* `string_span`   // `span<char>`
* `cstring_span`  // `span<const char>`

A `span<T>` refers to zero or more mutable `T`s unless `T` is a `const` type.

"Pointer arithmetic" is best done within `span`s.
A `char*` that points to more than one `char` but is not a C-style string (e.g., a pointer into an input buffer) should be represented by a `span`.

* `zstring`    // a `char*` supposed to be a C-style string; that is, a zero-terminated sequence of `char` or `nullptr`
* `czstring`   // a `const char*` supposed to be a C-style string; that is, a zero-terminated sequence of `const` `char` or `nullptr`

Logically, those last two aliases are not needed, but we are not always logical, and they make the distinction between a pointer to one `char` and a pointer to a C-style string explicit.
A sequence of characters that is not assumed to be zero-terminated should be a `char*`, rather than a `zstring`.
French accent optional.

Use `not_null<zstring>` for C-style strings that cannot be `nullptr`. ??? Do we need a name for `not_null<zstring>`? or is its ugliness a feature?

## <a name="SS-ownership"></a>GSL.owner: Ownership pointers

* `unique_ptr<T>`     // unique ownership: `std::unique_ptr<T>`
* `shared_ptr<T>`     // shared ownership: `std::shared_ptr<T>` (a counted pointer)
* `stack_array<T>`    // A stack-allocated array. The number of elements are determined at construction and fixed thereafter. The elements are mutable unless `T` is a `const` type.
* `dyn_array<T>`      // ??? needed ??? A heap-allocated array. The number of elements are determined at construction and fixed thereafter.
  The elements are mutable unless `T` is a `const` type. Basically a `span` that allocates and owns its elements.

## <a name="SS-assertions"></a>GSL.assert: Assertions

* `Expects`     // precondition assertion. Currently placed in function bodies. Later, should be moved to declarations.
                // `Expects(p)` terminates the program unless `p == true`
                // `Expect` in under control of some options (enforcement, error message, alternatives to terminate)
* `Ensures`     // postcondition assertion. Currently placed in function bodies. Later, should be moved to declarations.

These assertions are currently macros (yuck!) and must appear in function definitions (only)
pending standard committee decisions on contracts and assertion syntax.
See [the contract proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf); using the attribute syntax,
for example, `Expects(p)` will become `[[expects: p]]`.

## <a name="SS-utilities"></a>GSL.util: Utilities

* `finally`        // `finally(f)` makes a `final_action{f}` with a destructor that invokes `f`
* `narrow_cast`    // `narrow_cast<T>(x)` is `static_cast<T>(x)`
* `narrow`         // `narrow<T>(x)` is `static_cast<T>(x)` if `static_cast<T>(x) == x` or it throws `narrowing_error`
* `[[implicit]]`   // "Marker" to put on single-argument constructors to explicitly make them non-explicit.
* `move_owner`     // `p = move_owner(q)` means `p = q` but ???
* `joining_thread` // a RAII style version of `std::thread` that joins.
* `index`          // a type to use for all container and array indexing (currently an alias for `ptrdiff_t`)

## <a name="SS-gsl-concepts"></a>GSL.concept: Concepts

These concepts (type predicates) are borrowed from
Andrew Sutton's Origin library,
the Range proposal,
and the ISO WG21 Palo Alto TR.
They are likely to be very similar to what will become part of the ISO C++ standard.
The notation is that of the ISO WG21 [Concepts TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4553.pdf).
Most of the concepts below are defined in [the Ranges TS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4569.pdf).

* `Range`
* `String`   // ???
* `Number`   // ???
* `Sortable`
* `EqualityComparable`   // ???Must we suffer CaMelcAse???
* `Convertible`
* `Common`
* `Boolean`
* `Integral`
* `SignedIntegral`
* `SemiRegular` // ??? Copyable?
* `Regular`
* `TotallyOrdered`
* `Function`
* `RegularFunction`
* `Predicate`
* `Relation`
* ...

### <a name="SS-gsl-smartptrconcepts"></a>GSL.ptr: Smart pointer concepts

* `Pointer`  // A type with `*`, `->`, `==`, and default construction (default construction is assumed to set the singular "null" value)
* `Unique_pointer`  // A type that matches `Pointer`, is movable, and is not copyable
* `Shared_pointer`   // A type that matches `Pointer`, and is copyable

# <a name="S-naming"></a>NL: Naming and layout rules

Consistent naming and layout are helpful.
If for no other reason because it minimizes "my style is better than your style" arguments.
However, there are many, many, different styles around and people are passionate about them (pro and con).
Also, most real-world projects includes code from many sources, so standardizing on a single style for all code is often impossible.
After many requests for guidance from users, we present a set of rules that you might use if you have no better ideas, but the real aim is consistency, rather than any particular rule set.
IDEs and tools can help (as well as hinder).

Naming and layout rules:

* [NL.1: Don't say in comments what can be clearly stated in code](#Rl-comments)
* [NL.2: State intent in comments](#Rl-comments-intent)
* [NL.3: Keep comments crisp](#Rl-comments-crisp)
* [NL.4: Maintain a consistent indentation style](#Rl-indent)
* [NL.5: Avoid encoding type information in names](#Rl-name-type)
* [NL.7: Make the length of a name roughly proportional to the length of its scope](#Rl-name-length)
* [NL.8: Use a consistent naming style](#Rl-name)
* [NL.9: Use `ALL_CAPS` for macro names only](#Rl-all-caps)
* [NL.10: Prefer `underscore_style` names](#Rl-camel)
* [NL.11: Make literals readable](#Rl-literals)
* [NL.15: Use spaces sparingly](#Rl-space)
* [NL.16: Use a conventional class member declaration order](#Rl-order)
* [NL.17: Use K&R-derived layout](#Rl-knr)
* [NL.18: Use C++-style declarator layout](#Rl-ptr)
* [NL.19: Avoid names that are easily misread](#Rl-misread)
* [NL.20: Don't place two statements on the same line](#Rl-stmt)
* [NL.21: Declare one name (only) per declaration](#Rl-dcl)
* [NL.25: Don't use `void` as an argument type](#Rl-void)
* [NL.26: Use conventional `const` notation](#Rl-const)

Most of these rules are aesthetic and programmers hold strong opinions.
IDEs also tend to have defaults and a range of alternatives.
These rules are suggested defaults to follow unless you have reasons not to.

We have had comments to the effect that naming and layout are so personal and/or arbitrary that we should not try to "legislate" them.
We are not "legislating" (see the previous paragraph).
However, we have had many requests for a set of naming and layout conventions to use when there are no external constraints.

More specific and detailed rules are easier to enforce.

These rules bear a strong resemblance to the recommendations in the [PPP Style Guide](http://www.stroustrup.com/Programming/PPP-style.pdf)
written in support of Stroustrup's [Programming: Principles and Practice using C++](http://www.stroustrup.com/programming.html).

### <a name="Rl-comments"></a>NL.1: Don't say in comments what can be clearly stated in code

##### Reason

Compilers do not read comments.
Comments are less precise than code.
Comments are not updated as consistently as code.

##### Example, bad

    auto x = m * v1 + vv;   // multiply m with v1 and add the result to vv

##### Enforcement

Build an AI program that interprets colloquial English text and see if what is said could be better expressed in C++.

### <a name="Rl-comments-intent"></a>NL.2: State intent in comments

##### Reason

Code says what is done, not what is supposed to be done. Often intent can be stated more clearly and concisely than the implementation.

##### Example

    void stable_sort(Sortable& c)
        // sort c in the order determined by <, keep equal elements (as defined by ==) in
        // their original relative order
    {
        // ... quite a few lines of non-trivial code ...
    }

##### Note

If the comment and the code disagree, both are likely to be wrong.

### <a name="Rl-comments-crisp"></a>NL.3: Keep comments crisp

##### Reason

Verbosity slows down understanding and makes the code harder to read by spreading it around in the source file.

##### Note

Use intelligible English.
I may be fluent in Danish, but most programmers are not; the maintainers of my code may not be.
Avoid SMS lingo and watch your grammar, punctuation, and capitalization.
Aim for professionalism, not "cool."

##### Enforcement

not possible.

### <a name="Rl-indent"></a>NL.4: Maintain a consistent indentation style

##### Reason

Readability. Avoidance of "silly mistakes."

##### Example, bad

    int i;
    for (i = 0; i < max; ++i); // bug waiting to happen
    if (i == j)
        return i;

##### Note

Always indenting the statement after `if (...)`, `for (...)`, and `while (...)` is usually a good idea:

    if (i < 0) error("negative argument");

    if (i < 0)
        error("negative argument");

##### Enforcement

Use a tool.

### <a name="Rl-name-type"></a>NL.5: Avoid encoding type information in names

##### Rationale

If names reflect types rather than functionality, it becomes hard to change the types used to provide that functionality.
Also, if the type of a variable is changed, code using it will have to be modified.
Minimize unintentional conversions.

##### Example, bad

    void print_int(int i);
    void print_string(const char*);

    print_int(1);          // repetitive, manual type matching
    print_string("xyzzy"); // repetitive, manual type matching

##### Example, good

    void print(int i);
    void print(string_view);    // also works on any string-like sequence

    print(1);              // clear, automatic type matching
    print("xyzzy");        // clear, automatic type matching

##### Note

Names with types encoded are either verbose or cryptic.

    printS  // print a std::string
    prints  // print a C-style string
    printi  // print an int

Requiring techniques like Hungarian notation to encode a type has been used in untyped languages, but is generally unnecessary and actively harmful in a strongly statically-typed language like C++, because the annotations get out of date (the warts are just like comments and rot just like them) and they interfere with good use of the language (use the same name and overload resolution instead).

##### Note

Some styles use very general (not type-specific) prefixes to denote the general use of a variable.

    auto p = new User();
    auto p = make_unique<User>();
    // note: "p" is not being used to say "raw pointer to type User,"
    //       just generally to say "this is an indirection"

    auto cntHits = calc_total_of_hits(/*...*/);
    // note: "cnt" is not being used to encode a type,
    //       just generally to say "this is a count of something"

This is not harmful and does not fall under this guideline because it does not encode type information.

##### Note

Some styles distinguish members from local variable, and/or from global variable.

    struct S {
        int m_;
        S(int m) :m_{abs(m)} { }
    };

This is not harmful and does not fall under this guideline because it does not encode type information.

##### Note

Like C++, some styles distinguish types from non-types.
For example, by capitalizing type names, but not the names of functions and variables.

    typename<typename T>
    class HashTable {   // maps string to T
        // ...
    };

    HashTable<int> index;

This is not harmful and does not fall under this guideline because it does not encode type information.

### <a name="Rl-name-length"></a>NL.7: Make the length of a name roughly proportional to the length of its scope

**Rationale**: The larger the scope the greater the chance of confusion and of an unintended name clash.

##### Example

    double sqrt(double x);   // return the square root of x; x must be non-negative

    int length(const char* p);  // return the number of characters in a zero-terminated C-style string

    int length_of_string(const char zero_terminated_array_of_char[])    // bad: verbose

    int g;      // bad: global variable with a cryptic name

    int open;   // bad: global variable with a short, popular name

The use of `p` for pointer and `x` for a floating-point variable is conventional and non-confusing in a restricted scope.

##### Enforcement

???

### <a name="Rl-name"></a>NL.8: Use a consistent naming style

**Rationale**: Consistence in naming and naming style increases readability.

##### Note

There are many styles and when you use multiple libraries, you can't follow all their different conventions.
Choose a "house style", but leave "imported" libraries with their original style.

##### Example

ISO Standard, use lower case only and digits, separate words with underscores:

* `int`
* `vector`
* `my_map`

Avoid double underscores `__`.

##### Example

[Stroustrup](http://www.stroustrup.com/Programming/PPP-style.pdf):
ISO Standard, but with upper case used for your own types and concepts:

* `int`
* `vector`
* `My_map`

##### Example

CamelCase: capitalize each word in a multi-word identifier:

* `int`
* `vector`
* `MyMap`
* `myMap`

Some conventions capitalize the first letter, some don't.

##### Note

Try to be consistent in your use of acronyms and lengths of identifiers:

    int mtbf {12};
    int mean_time_between_failures {12}; // make up your mind

##### Enforcement

Would be possible except for the use of libraries with varying conventions.

### <a name="Rl-all-caps"></a>NL.9: Use `ALL_CAPS` for macro names only

##### Reason

To avoid confusing macros with names that obey scope and type rules.

##### Example

    void f()
    {
        const int SIZE{1000};  // Bad, use 'size' instead
        int v[SIZE];
    }

##### Note

This rule applies to non-macro symbolic constants:

    enum bad { BAD, WORSE, HORRIBLE }; // BAD

##### Enforcement

* Flag macros with lower-case letters
* Flag `ALL_CAPS` non-macro names

### <a name="Rl-camel"></a>NL.10: Prefer `underscore_style` names

##### Reason

The use of underscores to separate parts of a name is the original C and C++ style and used in the C++ Standard Library.

##### Note

This rule is a default to use only if you have a choice.
Often, you don't have a choice and must follow an established style for [consistency](#Rl-name).
The need for consistency beats personal taste.

This is a recommendation for [when you have no constraints or better ideas](#S-naming).
This rule was added after many requests for guidance.

##### Example

[Stroustrup](http://www.stroustrup.com/Programming/PPP-style.pdf):
ISO Standard, but with upper case used for your own types and concepts:

* `int`
* `vector`
* `My_map`

##### Enforcement

Impossible.

### <a name="Rl-space"></a>NL.15: Use spaces sparingly

##### Reason

Too much space makes the text larger and distracts.

##### Example, bad

    #include < map >

    int main(int argc, char * argv [ ])
    {
        // ...
    }

##### Example

    #include <map>

    int main(int argc, char* argv[])
    {
        // ...
    }

##### Note

Some IDEs have their own opinions and add distracting space.

This is a recommendation for [when you have no constraints or better ideas](#S-naming).
This rule was added after many requests for guidance.

##### Note

We value well-placed whitespace as a significant help for readability. Just don't overdo it.

### <a name="Rl-literals"></a>NL.11: Make literals readable

##### Reason

Readability.

##### Example

Use digit separators to avoid long strings of digits

    auto c = 299'792'458; // m/s2
    auto q2 = 0b0000'1111'0000'0000;
    auto ss_number = 123'456'7890;

##### Example

Use literal suffixes where clarification is needed

    auto hello = "Hello!"s; // a std::string
    auto world = "world";   // a C-style string
    auto interval = 100ms;  // using <chrono>

##### Note

Literals should not be sprinkled all over the code as ["magic constants"](#Res-magic),
but it is still a good idea to make them readable where they are defined.
It is easy to make a typo in a long string of integers.

##### Enforcement

Flag long digit sequences. The trouble is to define "long"; maybe 7.

### <a name="Rl-order"></a>NL.16: Use a conventional class member declaration order

##### Reason

A conventional order of members improves readability.

When declaring a class use the following order

* types: classes, enums, and aliases (`using`)
* constructors, assignments, destructor
* functions
* data

Use the `public` before `protected` before `private` order.

This is a recommendation for [when you have no constraints or better ideas](#S-naming).
This rule was added after many requests for guidance.

##### Example

    class X {
    public:
        // interface
    protected:
        // unchecked function for use by derived class implementations
    private:
        // implementation details
    };

##### Example

Sometimes, the default order of members conflicts with a desire to separate the public interface from implementation details.
In such cases, private types and functions can be placed with private data.

    class X {
    public:
        // interface
    protected:
        // unchecked function for use by derived class implementations
    private:
        // implementation details (types, functions, and data)
    };

##### Example, bad

Avoid multiple blocks of declarations of one access (e.g., `public`) dispersed among blocks of declarations with different access (e.g. `private`).

    class X {   // bad
    public:
        void f();
    public:
        int g();
        // ...
    };

The use of macros to declare groups of members often leads to violation of any ordering rules.
However, macros obscures what is being expressed anyway.

##### Enforcement

Flag departures from the suggested order. There will be a lot of old code that doesn't follow this rule.

### <a name="Rl-knr"></a>NL.17: Use K&R-derived layout

##### Reason

This is the original C and C++ layout. It preserves vertical space well. It distinguishes different language constructs (such as functions and classes) well.

##### Note

In the context of C++, this style is often called "Stroustrup".

This is a recommendation for [when you have no constraints or better ideas](#S-naming).
This rule was added after many requests for guidance.

##### Example

    struct Cable {
        int x;
        // ...
    };

    double foo(int x)
    {
        if (0 < x) {
            // ...
        }

        switch (x) {
        case 0:
            // ...
            break;
        case amazing:
            // ...
            break;
        default:
            // ...
            break;
        }

        if (0 < x)
            ++x;

        if (x < 0)
            something();
        else
            something_else();

        return some_value;
    }

Note the space between `if` and `(`

##### Note

Use separate lines for each statement, the branches of an `if`, and the body of a `for`.

##### Note

The `{` for a `class` and a `struct` is *not* on a separate line, but the `{` for a function is.

##### Note

Capitalize the names of your user-defined types to distinguish them from standards-library types.

##### Note

Do not capitalize function names.

##### Enforcement

If you want enforcement, use an IDE to reformat.

### <a name="Rl-ptr"></a>NL.18: Use C++-style declarator layout

##### Reason

The C-style layout emphasizes use in expressions and grammar, whereas the C++-style emphasizes types.
The use in expressions argument doesn't hold for references.

##### Example

    T& operator[](size_t);   // OK
    T &operator[](size_t);   // just strange
    T & operator[](size_t);   // undecided

##### Note

This is a recommendation for [when you have no constraints or better ideas](#S-naming).
This rule was added after many requests for guidance.

##### Enforcement

Impossible in the face of history.


### <a name="Rl-misread"></a>NL.19: Avoid names that are easily misread

##### Reason

Readability.
Not everyone has screens and printers that make it easy to distinguish all characters.
We easily confuse similarly spelled and slightly misspelled words.

##### Example

    int oO01lL = 6; // bad

    int splunk = 7;
    int splonk = 8; // bad: splunk and splonk are easily confused

##### Enforcement

???

### <a name="Rl-stmt"></a>NL.20: Don't place two statements on the same line

##### Reason

Readability.
It is really easy to overlook a statement when there is more on a line.

##### Example

    int x = 7; char* p = 29;    // don't
    int x = 7; f(x);  ++x;      // don't

##### Enforcement

Easy.

### <a name="Rl-dcl"></a>NL.21: Declare one name (only) per declaration

##### Reason

Readability.
Minimizing confusion with the declarator syntax.

##### Note

For details, see [ES.10](#Res-name-one).


### <a name="Rl-void"></a>NL.25: Don't use `void` as an argument type

##### Reason

It's verbose and only needed where C compatibility matters.

##### Example

    void f(void);   // bad

    void g();       // better

##### Note

Even Dennis Ritchie deemed `void f(void)` an abomination.
You can make an argument for that abomination in C when function prototypes were rare so that banning:

    int f();
    f(1, 2, "weird but valid C89");   // hope that f() is defined int f(a, b, c) char* c; { /* ... */ }

would have caused major problems, but not in the 21st century and in C++.

### <a name="Rl-const"></a>NL.26: Use conventional `const` notation

##### Reason

Conventional notation is more familiar to more programmers.
Consistency in large code bases.

##### Example

    const int x = 7;    // OK
    int const y = 9;    // bad

    const int *const p = nullptr;   // OK, constant pointer to constant int
    int const *const p = nullptr;   // bad, constant pointer to constant int

##### Note

We are well aware that you could claim the "bad" examples more logical than the ones marked "OK",
but they also confuse more people, especially novices relying on teaching material using the far more common, conventional OK style.

As ever, remember that the aim of these naming and layout rules is consistency and that aesthetics vary immensely.

This is a recommendation for [when you have no constraints or better ideas](#S-naming).
This rule was added after many requests for guidance.

##### Enforcement

Flag `const` used as a suffix for a type.

# <a name="S-faq"></a>FAQ: Answers to frequently asked questions

This section covers answers to frequently asked questions about these guidelines.

### <a name="Faq-aims"></a>FAQ.1: What do these guidelines aim to achieve?

See the <a href="#S-abstract">top of this page</a>. This is an open-source project to maintain modern authoritative guidelines for writing C++ code using the current C++ Standard (as of this writing, C++14). The guidelines are designed to be modern, machine-enforceable wherever possible, and open to contributions and forking so that organizations can easily incorporate them into their own corporate coding guidelines.

### <a name="Faq-announced"></a>FAQ.2: When and where was this work first announced?

It was announced by [Bjarne Stroustrup in his CppCon 2015 opening keynote, "Writing Good C++14"](https://isocpp.org/blog/2015/09/stroustrup-cppcon15-keynote). See also the [accompanying isocpp.org blog post](https://isocpp.org/blog/2015/09/bjarne-stroustrup-announces-cpp-core-guidelines), and for the rationale of the type and memory safety guidelines see [Herb Sutter's follow-up CppCon 2015 talk, "Writing Good C++14 ... By Default"](https://isocpp.org/blog/2015/09/sutter-cppcon15-day2plenary).

### <a name="Faq-maintainers"></a>FAQ.3: Who are the authors and maintainers of these guidelines?

The initial primary authors and maintainers are Bjarne Stroustrup and Herb Sutter, and the guidelines so far were developed with contributions from experts at CERN, Microsoft, Morgan Stanley, and several other organizations. At the time of their release, the guidelines are in a "0.6" state, and contributions are welcome. As Stroustrup said in his announcement: "We need help!"

### <a name="Faq-contribute"></a>FAQ.4: How can I contribute?

See [CONTRIBUTING.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md). We appreciate volunteer help!

### <a name="Faq-maintainer"></a>FAQ.5: How can I become an editor/maintainer?

By contributing a lot first and having the consistent quality of your contributions recognized. See [CONTRIBUTING.md](https://github.com/isocpp/CppCoreGuidelines/blob/master/CONTRIBUTING.md). We appreciate volunteer help!

### <a name="Faq-iso"></a>FAQ.6: Have these guidelines been approved by the ISO C++ standards committee? Do they represent the consensus of the committee?

No. These guidelines are outside the standard. They are intended to serve the standard, and be maintained as current guidelines about how to use the current Standard C++ effectively. We aim to keep them in sync with the standard as that is evolved by the committee.

### <a name="Faq-isocpp"></a>FAQ.7: If these guidelines are not approved by the committee, why are they under `github.com/isocpp`?

Because `isocpp` is the Standard C++ Foundation; the committee's repositories are under [github.com/*cplusplus*](https://github.com/cplusplus). Some neutral organization has to own the copyright and license to make it clear this is not being dominated by any one person or vendor. The natural entity is the Foundation, which exists to promote the use and up-to-date understanding of modern Standard C++ and the work of the committee. This follows the same pattern that isocpp.org did for the [C++ FAQ](https://isocpp.org/faq), which was initially the work of Bjarne Stroustrup, Marshall Cline, and Herb Sutter and contributed to the open project in the same way.

### <a name="Faq-cpp98"></a>FAQ.8: Will there be a C++98 version of these Guidelines? a C++11 version?

No. These guidelines are about how to best use Standard C++14 (and, if you have an implementation available, the Concepts Technical Specification) and write code assuming you have a modern conforming compiler.

### <a name="Faq-language-extensions"></a>FAQ.9: Do these guidelines propose new language features?

No. These guidelines are about how to best use Standard C++14 + the Concepts Technical Specification, and they limit themselves to recommending only those features.

### <a name="Faq-markdown"></a>FAQ.10: What version of Markdown do these guidelines use?

These coding standards are written using [CommonMark](http://commonmark.org), and `<a>` HTML anchors.

We are considering the following extensions from [GitHub Flavored Markdown (GFM)](https://help.github.com/articles/github-flavored-markdown/):

* fenced code blocks (consistently using indented vs. fenced is under discussion)
* tables (none yet but we'll likely need them, and this is a GFM extension)

Avoid other HTML tags and other extensions.

Note: We are not yet consistent with this style.

### <a name="Faq-gsl"></a>FAQ.50: What is the GSL (guidelines support library)?

The GSL is the small set of types and aliases specified in these guidelines. As of this writing, their specification herein is too sparse; we plan to add a WG21-style interface specification to ensure that different implementations agree, and to propose as a contribution for possible standardization, subject as usual to whatever the committee decides to accept/improve/alter/reject.

### <a name="Faq-msgsl"></a>FAQ.51: Is [github.com/Microsoft/GSL](https://github.com/Microsoft/GSL) the GSL?

No. That is just a first implementation contributed by Microsoft. Other implementations by other vendors are encouraged, as are forks of and contributions to that implementation. As of this writing one week into the public project, at least one GPLv3 open-source implementation already exists. We plan to produce a WG21-style interface specification to ensure that different implementations agree.

### <a name="Faq-gsl-implementation"></a>FAQ.52: Why not supply an actual GSL implementation in/with these guidelines?

We are reluctant to bless one particular implementation because we do not want to make people think there is only one, and inadvertently stifle parallel implementations. And if these guidelines included an actual implementation, then whoever contributed it could be mistakenly seen as too influential. We prefer to follow the long-standing approach of the committee, namely to specify interfaces, not implementations. But at the same time we want at least one implementation available; we hope for many.

### <a name="Faq-boost"></a>FAQ.53: Why weren't the GSL types proposed through Boost?

Because we want to use them immediately, and because they are temporary in that we want to retire them as soon as types that fill the same needs exist in the standard library.

### <a name="Faq-gsl-iso"></a>FAQ.54: Has the GSL (guidelines support library) been approved by the ISO C++ standards committee?

No. The GSL exists only to supply a few types and aliases that are not currently in the standard library. If the committee decides on standardized versions (of these or other types that fill the same need) then they can be removed from the GSL.

### <a name="Faq-gsl-string-view"></a>FAQ.55: If you're using the standard types where available, why is the GSL `string_span` different from the `string_view` in the Library Fundamentals 1 Technical Specification and C++17 Working Paper? Why not just use the committee-approved `string_view`?

The consensus on the taxonomy of views for the C++ Standard Library was that "view" means "read-only", and "span" means "read/write". The read-only `string_view` was the first such component to complete the standardization process, while `span` and `string_span` are currently being considered for standardization.

### <a name="Faq-gsl-owner"></a>FAQ.56: Is `owner` the same as the proposed `observer_ptr`?

No. `owner` owns, is an alias, and can be applied to any indirection type. The main intent of `observer_ptr` is to signify a *non*-owning pointer.

### <a name="Faq-gsl-stack-array"></a>FAQ.57: Is `stack_array` the same as the standard `array`?

No. `stack_array` is guaranteed to be allocated on the stack. Although a `std::array` contains its storage directly inside itself, the `array` object can be put anywhere, including the heap.

### <a name="Faq-gsl-dyn-array"></a>FAQ.58: Is `dyn_array` the same as `vector` or the proposed `dynarray`?

No. `dyn_array` is not resizable, and is a safe way to refer to a heap-allocated fixed-size array. Unlike `vector`, it is intended to replace array-`new[]`. Unlike the `dynarray` that has been proposed in the committee, this does not anticipate compiler/language magic to somehow allocate it on the stack when it is a member of an object that is allocated on the stack; it simply refers to a "dynamic" or heap-based array.

### <a name="Faq-gsl-expects"></a>FAQ.59: Is `Expects` the same as `assert`?

No. It is a placeholder for language support for contract preconditions.

### <a name="Faq-gsl-ensures"></a>FAQ.60: Is `Ensures` the same as `assert`?

No. It is a placeholder for language support for contract postconditions.

# <a name="S-libraries"></a>Appendix A: Libraries

This section lists recommended libraries, and explicitly recommends a few.

??? Suitable for the general guide? I think not ???

# <a name="S-modernizing"></a>Appendix B: Modernizing code

Ideally, we follow all rules in all code.
Realistically, we have to deal with a lot of old code:

* application code written before the guidelines were formulated or known
* libraries written to older/different standards
* code written under "unusual" constraints
* code that we just haven't gotten around to modernizing

If we have a million lines of new code, the idea of "just changing it all at once" is typically unrealistic.
Thus, we need a way of gradually modernizing a code base.

Upgrading older code to modern style can be a daunting task.
Often, the old code is both a mess (hard to understand) and working correctly (for the current range of uses).
Typically, the original programmer is not around and the test cases incomplete.
The fact that the code is a mess dramatically increases the effort needed to make any change and the risk of introducing errors.
Often, messy old code runs unnecessarily slowly because it requires outdated compilers and cannot take advantage of modern hardware.
In many cases, automated "modernizer"-style tool support would be required for major upgrade efforts.

The purpose of modernizing code is to simplify adding new functionality, to ease maintenance, and to increase performance (throughput or latency), and to better utilize modern hardware.
Making code "look pretty" or "follow modern style" are not by themselves reasons for change.
There are risks implied by every change and costs (including the cost of lost opportunities) implied by having an outdated code base.
The cost reductions must outweigh the risks.

But how?

There is no one approach to modernizing code.
How best to do it depends on the code, the pressure for updates, the backgrounds of the developers, and the available tool.
Here are some (very general) ideas:

* The ideal is "just upgrade everything." That gives the most benefits for the shortest total time.
  In most circumstances, it is also impossible.
* We could convert a code base module for module, but any rules that affects interfaces (especially ABIs), such as [use `span`](#SS-views), cannot be done on a per-module basis.
* We could convert code "bottom up" starting with the rules we estimate will give the greatest benefits and/or the least trouble in a given code base.
* We could start by focusing on the interfaces, e.g., make sure that no resources are lost and no pointer is misused.
  This would be a set of changes across the whole code base, but would most likely have huge benefits.
  Afterwards, code hidden behind those interfaces can be gradually modernized without affecting other code.

Whichever way you choose, please note that the most advantages come with the highest conformance to the guidelines.
The guidelines are not a random set of unrelated rules where you can randomly pick and choose with an expectation of success.

We would dearly love to hear about experience and about tools used.
Modernization can be much faster, simpler, and safer when supported with analysis tools and even code transformation tools.

# <a name="S-discussion"></a>Appendix C: Discussion

This section contains follow-up material on rules and sets of rules.
In particular, here we present further rationale, longer examples, and discussions of alternatives.

### <a name="Sd-order"></a>Discussion: Define and initialize member variables in the order of member declaration

Member variables are always initialized in the order they are declared in the class definition, so write them in that order in the constructor initialization list. Writing them in a different order just makes the code confusing because it won't run in the order you see, and that can make it hard to see order-dependent bugs.

    class Employee {
        string email, first, last;
    public:
        Employee(const char* firstName, const char* lastName);
        // ...
    };

    Employee::Employee(const char* firstName, const char* lastName)
      : first(firstName),
        last(lastName),
        // BAD: first and last not yet constructed
        email(first + "." + last + "@acme.com")
    {}

In this example, `email` will be constructed before `first` and `last` because it is declared first. That means its constructor will attempt to use `first` and `last` too soon -- not just before they are set to the desired values, but before they are constructed at all.

If the class definition and the constructor body are in separate files, the long-distance influence that the order of member variable declarations has over the constructor's correctness will be even harder to spot.

**References**:

[\[Cline99\]](#Cline99) §22.03-11, [\[Dewhurst03\]](#Dewhurst03) §52-53, [\[Koenig97\]](#Koenig97) §4, [\[Lakos96\]](#Lakos96) §10.3.5, [\[Meyers97\]](#Meyers97) §13, [\[Murray93\]](#Murray93) §2.1.3, [\[Sutter00\]](#Sutter00) §47

### <a name="Sd-init"></a>Discussion: Use of `=`, `{}`, and `()` as initializers

???

### <a name="Sd-factory"></a>Discussion: Use a factory function if you need "virtual behavior" during initialization

If your design wants virtual dispatch into a derived class from a base class constructor or destructor for functions like `f` and `g`, you need other techniques, such as a post-constructor -- a separate member function the caller must invoke to complete initialization, which can safely call `f` and `g` because in member functions virtual calls behave normally. Some techniques for this are shown in the References. Here's a non-exhaustive list of options:

* *Pass the buck:* Just document that user code must call the post-initialization function right after constructing an object.
* *Post-initialize lazily:* Do it during the first call of a member function. A Boolean flag in the base class tells whether or not post-construction has taken place yet.
* *Use virtual base class semantics:* Language rules dictate that the constructor most-derived class decides which base constructor will be invoked; you can use that to your advantage. (See [\[Taligent94\]](#Taligent94).)
* *Use a factory function:* This way, you can easily force a mandatory invocation of a post-constructor function.

Here is an example of the last option:

    class B {
    public:
        B() {
            /* ... */
            f(); // BAD: C.82: Don't call virtual functions in constructors and destructors
            /* ... */
        }

        virtual void f() = 0;
    };

    class B {
    protected:
        class Token {};

    public:
        // constructor needs to be public so that make_shared can access it.
        // protected access level is gained by requiring a Token.
        explicit B(Token) { /* ... */ }  // create an imperfectly initialized object
        virtual void f() = 0;

        template<class T>
        static shared_ptr<T> create()    // interface for creating shared objects
        {
            auto p = make_shared<T>(typename T::Token{});
            p->post_initialize();
            return p;
        }

    protected:
        virtual void post_initialize()   // called right after construction
            { /* ... */ f(); /* ... */ } // GOOD: virtual dispatch is safe
        }
    };


    class D : public B {                 // some derived class
    protected:
        class Token {};

    public:
        // constructor needs to be public so that make_shared can access it.
        // protected access level is gained by requiring a Token.
        explicit D(Token) : B{ B::Token{} } {}
        void f() override { /* ...  */ };

    protected:
        template<class T>
        friend shared_ptr<T> B::create();
    };

    shared_ptr<D> p = D::create<D>();    // creating a D object

This design requires the following discipline:

* Derived classes such as `D` must not expose a publicly callable constructor. Otherwise, `D`'s users could create `D` objects that don't invoke `post_initialize`.
* Allocation is limited to `operator new`. `B` can, however, override `new` (see Items 45 and 46 in [SuttAlex05](#SuttAlex05)).
* `D` must define a constructor with the same parameters that `B` selected. Defining several overloads of `create` can assuage this problem, however; and the overloads can even be templated on the argument types.

If the requirements above are met, the design guarantees that `post_initialize` has been called for any fully constructed `B`-derived object. `post_initialize` doesn't need to be virtual; it can, however, invoke virtual functions freely.

In summary, no post-construction technique is perfect. The worst techniques dodge the whole issue by simply asking the caller to invoke the post-constructor manually. Even the best require a different syntax for constructing objects (easy to check at compile time) and/or cooperation from derived class authors (impossible to check at compile time).

**References**: [\[Alexandrescu01\]](#Alexandrescu01) §3, [\[Boost\]](#Boost), [\[Dewhurst03\]](#Dewhurst03) §75, [\[Meyers97\]](#Meyers97) §46, [\[Stroustrup00\]](#Stroustrup00) §15.4.3, [\[Taligent94\]](#Taligent94)

### <a name="Sd-dtor"></a>Discussion: Make base class destructors public and virtual, or protected and nonvirtual

Should destruction behave virtually? That is, should destruction through a pointer to a `base` class be allowed? If yes, then `base`'s destructor must be public in order to be callable, and virtual otherwise calling it results in undefined behavior. Otherwise, it should be protected so that only derived classes can invoke it in their own destructors, and nonvirtual since it doesn't need to behave virtually.

##### Example

The common case for a base class is that it's intended to have publicly derived classes, and so calling code is just about sure to use something like a `shared_ptr<base>`:

    class Base {
    public:
        ~Base();                   // BAD, not virtual
        virtual ~Base();           // GOOD
        // ...
    };

    class Derived : public Base { /* ... */ };

    {
        unique_ptr<Base> pb = make_unique<Derived>();
        // ...
    } // ~pb invokes correct destructor only when ~Base is virtual

In rarer cases, such as policy classes, the class is used as a base class for convenience, not for polymorphic behavior. It is recommended to make those destructors protected and nonvirtual:

    class My_policy {
    public:
        virtual ~My_policy();      // BAD, public and virtual
    protected:
        ~My_policy();              // GOOD
        // ...
    };

    template<class Policy>
    class customizable : Policy { /* ... */ }; // note: private inheritance

##### Note

This simple guideline illustrates a subtle issue and reflects modern uses of inheritance and object-oriented design principles.

For a base class `Base`, calling code might try to destroy derived objects through pointers to `Base`, such as when using a `unique_ptr<Base>`. If `Base`'s destructor is public and nonvirtual (the default), it can be accidentally called on a pointer that actually points to a derived object, in which case the behavior of the attempted deletion is undefined. This state of affairs has led older coding standards to impose a blanket requirement that all base class destructors must be virtual. This is overkill (even if it is the common case); instead, the rule should be to make base class destructors virtual if and only if they are public.

To write a base class is to define an abstraction (see Items 35 through 37). Recall that for each member function participating in that abstraction, you need to decide:

* Whether it should behave virtually or not.
* Whether it should be publicly available to all callers using a pointer to `Base` or else be a hidden internal implementation detail.

As described in Item 39, for a normal member function, the choice is between allowing it to be called via a pointer to `Base` nonvirtually (but possibly with virtual behavior if it invokes virtual functions, such as in the NVI or Template Method patterns), virtually, or not at all. The NVI pattern is a technique to avoid public virtual functions.

Destruction can be viewed as just another operation, albeit with special semantics that make nonvirtual calls dangerous or wrong. For a base class destructor, therefore, the choice is between allowing it to be called via a pointer to `Base` virtually or not at all; "nonvirtually" is not an option. Hence, a base class destructor is virtual if it can be called (i.e., is public), and nonvirtual otherwise.

Note that the NVI pattern cannot be applied to the destructor because constructors and destructors cannot make deep virtual calls. (See Items 39 and 55.)

Corollary: When writing a base class, always write a destructor explicitly, because the implicitly generated one is public and nonvirtual. You can always `=default` the implementation if the default body is fine and you're just writing the function to give it the proper visibility and virtuality.

##### Exception

Some component architectures (e.g., COM and CORBA) don't use a standard deletion mechanism, and foster different protocols for object disposal. Follow the local patterns and idioms, and adapt this guideline as appropriate.

Consider also this rare case:

* `B` is both a base class and a concrete class that can be instantiated by itself, and so the destructor must be public for `B` objects to be created and destroyed.
* Yet `B` also has no virtual functions and is not meant to be used polymorphically, and so although the destructor is public it does not need to be virtual.

Then, even though the destructor has to be public, there can be great pressure to not make it virtual because as the first virtual function it would incur all the run-time type overhead when the added functionality should never be needed.

In this rare case, you could make the destructor public and nonvirtual but clearly document that further-derived objects must not be used polymorphically as `B`'s. This is what was done with `std::unary_function`.

In general, however, avoid concrete base classes (see Item 35). For example, `unary_function` is a bundle-of-typedefs that was never intended to be instantiated standalone. It really makes no sense to give it a public destructor; a better design would be to follow this Item's advice and give it a protected nonvirtual destructor.

**References**: [\[C++CS\]](#CplusplusCS) Item 50, [\[Cargill92\]](#Cargill92) pp. 77-79, 207, [\[Cline99\]](#Cline99) §21.06, 21.12-13, [\[Henricson97\]](#Henricson97) pp. 110-114, [\[Koenig97\]](#Koenig97) Chapters 4, 11, [\[Meyers97\]](#Meyers97) §14, [\[Stroustrup00\]](#Stroustrup00) §12.4.2, [\[Sutter02\]](#Sutter02) §27, [\[Sutter04\]](#Sutter04) §18

### <a name="Sd-noexcept"></a>Discussion: Usage of noexcept

???

### <a name="Sd-never-fail"></a>Discussion: Destructors, deallocation, and swap must never fail

Never allow an error to be reported from a destructor, a resource deallocation function (e.g., `operator delete`), or a `swap` function using `throw`. It is nearly impossible to write useful code if these operations can fail, and even if something does go wrong it nearly never makes any sense to retry. Specifically, types whose destructors may throw an exception are flatly forbidden from use with the C++ Standard Library. Most destructors are now implicitly `noexcept` by default.

##### Example

    class Nefarious {
    public:
        Nefarious()  { /* code that could throw */ }   // ok
        ~Nefarious() { /* code that could throw */ }   // BAD, should not throw
        // ...
    };

1. `Nefarious` objects are hard to use safely even as local variables:


        void test(string& s)
        {
            Nefarious n;          // trouble brewing
            string copy = s;      // copy the string
        } // destroy copy and then n

    Here, copying `s` could throw, and if that throws and if `n`'s destructor then also throws, the program will exit via `std::terminate` because two exceptions can't be propagated simultaneously.

2. Classes with `Nefarious` members or bases are also hard to use safely, because their destructors must invoke `Nefarious`' destructor, and are similarly poisoned by its poor behavior:


        class Innocent_bystander {
            Nefarious member;     // oops, poisons the enclosing class's destructor
            // ...
        };

        void test(string& s)
        {
            Innocent_bystander i; // more trouble brewing
            string copy2 = s;      // copy the string
        } // destroy copy and then i

    Here, if constructing `copy2` throws, we have the same problem because `i`'s destructor now also can throw, and if so we'll invoke `std::terminate`.

3. You can't reliably create global or static `Nefarious` objects either:


        static Nefarious n;       // oops, any destructor exception can't be caught

4. You can't reliably create arrays of `Nefarious`:


        void test()
        {
            std::array<Nefarious, 10> arr; // this line can std::terminate(!)
        }

    The behavior of arrays is undefined in the presence of destructors that throw because there is no reasonable rollback behavior that could ever be devised. Just think: What code can the compiler generate for constructing an `arr` where, if the fourth object's constructor throws, the code has to give up and in its cleanup mode tries to call the destructors of the already-constructed objects ... and one or more of those destructors throws? There is no satisfactory answer.

5. You can't use `Nefarious` objects in standard containers:


        std::vector<Nefarious> vec(10);   // this line can std::terminate()

    The standard library forbids all destructors used with it from throwing. You can't store `Nefarious` objects in standard containers or use them with any other part of the standard library.

##### Note

These are key functions that must not fail because they are necessary for the two key operations in transactional programming: to back out work if problems are encountered during processing, and to commit work if no problems occur. If there's no way to safely back out using no-fail operations, then no-fail rollback is impossible to implement. If there's no way to safely commit state changes using a no-fail operation (notably, but not limited to, `swap`), then no-fail commit is impossible to implement.

Consider the following advice and requirements found in the C++ Standard:

> If a destructor called during stack unwinding exits with an exception, terminate is called (15.5.1). So destructors should generally catch exceptions and not let them propagate out of the destructor. --[\[C++03\]](#Cplusplus03) §15.2(3)
>
> No destructor operation defined in the C++ Standard Library (including the destructor of any type that is used to instantiate a standard-library template) will throw an exception. --[\[C++03\]](#Cplusplus03) §17.4.4.8(3)

Deallocation functions, including specifically overloaded `operator delete` and `operator delete[]`, fall into the same category, because they too are used during cleanup in general, and during exception handling in particular, to back out of partial work that needs to be undone.
Besides destructors and deallocation functions, common error-safety techniques rely also on `swap` operations never failing -- in this case, not because they are used to implement a guaranteed rollback, but because they are used to implement a guaranteed commit. For example, here is an idiomatic implementation of `operator=` for a type `T` that performs copy construction followed by a call to a no-fail `swap`:

    T& T::operator=(const T& other) {
        auto temp = other;
        swap(temp);
        return *this;
    }

(See also Item 56. ???)

Fortunately, when releasing a resource, the scope for failure is definitely smaller. If using exceptions as the error reporting mechanism, make sure such functions handle all exceptions and other errors that their internal processing might generate. (For exceptions, simply wrap everything sensitive that your destructor does in a `try/catch(...)` block.) This is particularly important because a destructor might be called in a crisis situation, such as failure to allocate a system resource (e.g., memory, files, locks, ports, windows, or other system objects).

When using exceptions as your error handling mechanism, always document this behavior by declaring these functions `noexcept`. (See Item 75.)

**References**: [\[C++CS\]](#CplusplusCS) Item 51; [\[C++03\]](#Cplusplus03) §15.2(3), §17.4.4.8(3), [\[Meyers96\]](#Meyers96) §11, [\[Stroustrup00\]](#Stroustrup00) §14.4.7, §E.2-4, [\[Sutter00\]](#Sutter00) §8, §16, [\[Sutter02\]](#Sutter02) §18-19

## <a name="Sd-consistent"></a>Define Copy, move, and destroy consistently

##### Reason

 ???

##### Note

If you define a copy constructor, you must also define a copy assignment operator.

##### Note

If you define a move constructor, you must also define a move assignment operator.

##### Example

    class X {
    public:
        X(const X&) { /* stuff */ }

        // BAD: failed to also define a copy assignment operator

        X(x&&) noexcept { /* stuff */ }

        // BAD: failed to also define a move assignment operator

        // ...
    };

    X x1;
    X x2 = x1; // ok
    x2 = x1;   // pitfall: either fails to compile, or does something suspicious

If you define a destructor, you should not use the compiler-generated copy or move operation; you probably need to define or suppress copy and/or move.

    class X {
        HANDLE hnd;
        // ...
    public:
        ~X() { /* custom stuff, such as closing hnd */ }
        // suspicious: no mention of copying or moving -- what happens to hnd?
    };

    X x1;
    X x2 = x1; // pitfall: either fails to compile, or does something suspicious
    x2 = x1;   // pitfall: either fails to compile, or does something suspicious

If you define copying, and any base or member has a type that defines a move operation, you should also define a move operation.

    class X {
        string s; // defines more efficient move operations
        // ... other data members ...
    public:
        X(const X&) { /* stuff */ }
        X& operator=(const X&) { /* stuff */ }

        // BAD: failed to also define a move construction and move assignment
        // (why wasn't the custom "stuff" repeated here?)
    };

    X test()
    {
        X local;
        // ...
        return local;  // pitfall: will be inefficient and/or do the wrong thing
    }

If you define any of the copy constructor, copy assignment operator, or destructor, you probably should define the others.

##### Note

If you need to define any of these five functions, it means you need it to do more than its default behavior -- and the five are asymmetrically interrelated. Here's how:

* If you write/disable either of the copy constructor or the copy assignment operator, you probably need to do the same for the other: If one does "special" work, probably so should the other because the two functions should have similar effects. (See Item 53, which expands on this point in isolation.)
* If you explicitly write the copying functions, you probably need to write the destructor: If the "special" work in the copy constructor is to allocate or duplicate some resource (e.g., memory, file, socket), you need to deallocate it in the destructor.
* If you explicitly write the destructor, you probably need to explicitly write or disable copying: If you have to write a non-trivial destructor, it's often because you need to manually release a resource that the object held. If so, it is likely that those resources require careful duplication, and then you need to pay attention to the way objects are copied and assigned, or disable copying completely.

In many cases, holding properly encapsulated resources using RAII "owning" objects can eliminate the need to write these operations yourself. (See Item 13.)

Prefer compiler-generated (including `=default`) special members; only these can be classified as "trivial", and at least one major standard library vendor heavily optimizes for classes having trivial special members. This is likely to become common practice.

**Exceptions**: When any of the special functions are declared only to make them nonpublic or virtual, but without special semantics, it doesn't imply that the others are needed.
In rare cases, classes that have members of strange types (such as reference members) are an exception because they have peculiar copy semantics.
In a class holding a reference, you likely need to write the copy constructor and the assignment operator, but the default destructor already does the right thing. (Note that using a reference member is almost always wrong.)

**References**: [\[C++CS\]](#CplusplusCS) Item 52; [\[Cline99\]](#Cline99) §30.01-14, [\[Koenig97\]](#Koenig97) §4, [\[Stroustrup00\]](#Stroustrup00) §5.5, §10.4, [\[SuttHysl04b\]](#SuttHysl04b)

Resource management rule summary:

* [Provide strong resource safety; that is, never leak anything that you think of as a resource](#Cr-safety)
* [Never throw while holding a resource not owned by a handle](#Cr-never)
* [A "raw" pointer or reference is never a resource handle](#Cr-raw)
* [Never let a pointer outlive the object it points to](#Cr-outlive)
* [Use templates to express containers (and other resource handles)](#Cr-templates)
* [Return containers by value (relying on move or copy elision for efficiency)](#Cr-value-return)
* [If a class is a resource handle, it needs a constructor, a destructor, and copy and/or move operations](#Cr-handle)
* [If a class is a container, give it an initializer-list constructor](#Cr-list)

### <a name="Cr-safety"></a>Discussion: Provide strong resource safety; that is, never leak anything that you think of as a resource

##### Reason

Prevent leaks. Leaks can lead to performance degradation, mysterious error, system crashes, and security violations.

**Alternative formulation**: Have every resource represented as an object of some class managing its lifetime.

##### Example

    template<class T>
    class Vector {
    private:
        T* elem;   // sz elements on the free store, owned by the class object
        int sz;
        // ...
    };

This class is a resource handle. It manages the lifetime of the `T`s. To do so, `Vector` must define or delete [the set of special operations](???) (constructors, a destructor, etc.).

##### Example

    ??? "odd" non-memory resource ???

##### Enforcement

The basic technique for preventing leaks is to have every resource owned by a resource handle with a suitable destructor. A checker can find "naked `new`s". Given a list of C-style allocation functions (e.g., `fopen()`), a checker can also find uses that are not managed by a resource handle. In general, "naked pointers" can be viewed with suspicion, flagged, and/or analyzed. A complete list of resources cannot be generated without human input (the definition of "a resource" is necessarily too general), but a tool can be "parameterized" with a resource list.

### <a name="Cr-never"></a>Discussion: Never throw while holding a resource not owned by a handle

##### Reason

That would be a leak.

##### Example

    void f(int i)
    {
        FILE* f = fopen("a file", "r");
        ifstream is { "another file" };
        // ...
        if (i == 0) return;
        // ...
        fclose(f);
    }

If `i == 0` the file handle for `a file` is leaked. On the other hand, the `ifstream` for `another file` will correctly close its file (upon destruction). If you must use an explicit pointer, rather than a resource handle with specific semantics, use a `unique_ptr` or a `shared_ptr` with a custom deleter:

    void f(int i)
    {
        unique_ptr<FILE, int(*)(FILE*)> f(fopen("a file", "r"), fclose);
        // ...
        if (i == 0) return;
        // ...
    }

Better:

    void f(int i)
    {
        ifstream input {"a file"};
        // ...
        if (i == 0) return;
        // ...
    }

##### Enforcement

A checker must consider all "naked pointers" suspicious.
A checker probably must rely on a human-provided list of resources.
For starters, we know about the standard-library containers, `string`, and smart pointers.
The use of `span` and `string_span` should help a lot (they are not resource handles).

### <a name="Cr-raw"></a>Discussion: A "raw" pointer or reference is never a resource handle

##### Reason

To be able to distinguish owners from views.

##### Note

This is independent of how you "spell" pointer: `T*`, `T&`, `Ptr<T>` and `Range<T>` are not owners.

### <a name="Cr-outlive"></a>Discussion: Never let a pointer outlive the object it points to

##### Reason

To avoid extremely hard-to-find errors. Dereferencing such a pointer is undefined behavior and could lead to violations of the type system.

##### Example

    string* bad()   // really bad
    {
        vector<string> v = { "This", "will", "cause", "trouble", "!" };
        // leaking a pointer into a destroyed member of a destroyed object (v)
        return &v[0];
    }

    void use()
    {
        string* p = bad();
        vector<int> xx = {7, 8, 9};
        // undefined behavior: x may not be the string "This"
        string x = *p;
        // undefined behavior: we don't know what (if anything) is allocated a location p
        *p = "Evil!";
    }

The `string`s of `v` are destroyed upon exit from `bad()` and so is `v` itself. The returned pointer points to unallocated memory on the free store. This memory (pointed into by `p`) may have been reallocated by the time `*p` is executed. There may be no `string` to read and a write through `p` could easily corrupt objects of unrelated types.

##### Enforcement

Most compilers already warn about simple cases and have the information to do more. Consider any pointer returned from a function suspect. Use containers, resource handles, and views (e.g., `span` known not to be resource handles) to lower the number of cases to be examined. For starters, consider every class with a destructor as resource handle.

### <a name="Cr-templates"></a>Discussion: Use templates to express containers (and other resource handles)

##### Reason

To provide statically type-safe manipulation of elements.

##### Example

    template<typename T> class Vector {
        // ...
        T* elem;   // point to sz elements of type T
        int sz;
    };

### <a name="Cr-value-return"></a>Discussion: Return containers by value (relying on move or copy elision for efficiency)

##### Reason

To simplify code and eliminate a need for explicit memory management. To bring an object into a surrounding scope, thereby extending its lifetime.

**See also**: [F.20, the general item about "out" output values](#Rf-out)

##### Example

    vector<int> get_large_vector()
    {
        return ...;
    }

    auto v = get_large_vector(); //  return by value is ok, most modern compilers will do copy elision

##### Exception

See the Exceptions in [F.20](#Rf-out).

##### Enforcement

Check for pointers and references returned from functions and see if they are assigned to resource handles (e.g., to a `unique_ptr`).

### <a name="Cr-handle"></a>Discussion: If a class is a resource handle, it needs a constructor, a destructor, and copy and/or move operations

##### Reason

To provide complete control of the lifetime of the resource. To provide a coherent set of operations on the resource.

##### Example

    ??? Messing with pointers

##### Note

If all members are resource handles, rely on the default special operations where possible.

    template<typename T> struct Named {
        string name;
        T value;
    };

Now `Named` has a default constructor, a destructor, and efficient copy and move operations, provided `T` has.

##### Enforcement

In general, a tool cannot know if a class is a resource handle. However, if a class has some of [the default operations](#SS-ctor), it should have all, and if a class has a member that is a resource handle, it should be considered as resource handle.

### <a name="Cr-list"></a>Discussion: If a class is a container, give it an initializer-list constructor

##### Reason

It is common to need an initial set of elements.

##### Example

    template<typename T> class Vector {
    public:
        Vector(std::initializer_list<T>);
        // ...
    };

    Vector<string> vs { "Nygaard", "Ritchie" };

##### Enforcement

When is a class a container? ???

# <a name="S-tools"></a>Appendix D: Supporting tools

This section contains a list of tools that directly support adoption of the C++ Core Guidelines. This list is not intended to be an exhaustive list of tools
that are helpful in writing good C++ code. If a tool is designed specifically to support and links to the C++ Core Guidelines it is a candidate for inclusion.

### <a name="St-clangtidy"></a>Tools: [Clang-tidy](http://clang.llvm.org/extra/clang-tidy/checks/list.html)

Clang-tidy has a set of rules that specifically enforce the C++ Core Guidelines. These rules are named in the pattern `cppcoreguidelines-*`.

### <a name="St-cppcorecheck"></a>Tools: [CppCoreCheck](https://docs.microsoft.com/en-us/visualstudio/code-quality/using-the-cpp-core-guidelines-checkers)

The Microsoft compiler's C++ code analysis contains a set of rules specifically aimed at enforcement of the C++ Core Guidelines.

# <a name="S-glossary"></a>Glossary

A relatively informal definition of terms used in the guidelines
(based off the glossary in [Programming: Principles and Practice using C++](http://www.stroustrup.com/programming.html))

More information on many topics about C++ can be found on the [Standard C++ Foundation](https://isocpp.org)'s site.

* *ABI*: Application Binary Interface, a specification for a specific hardware platform combined with the operating system. Contrast with API.
* *abstract class*: a class that cannot be directly used to create objects; often used to define an interface to derived classes.
  A class is made abstract by having a pure virtual function or only protected constructors.
* *abstraction*: a description of something that selectively and deliberately ignores (hides) details (e.g., implementation details); selective ignorance.
* *address*: a value that allows us to find an object in a computer's memory.
* *algorithm*: a procedure or formula for solving a problem; a finite series of computational steps to produce a result.
* *alias*: an alternative way of referring to an object; often a name, pointer, or reference.
* *API*: Application Programming Interface, a set of functions that form the communication between various software components. Contrast with ABI.
* *application*: a program or a collection of programs that is considered an entity by its users.
* *approximation*: something (e.g., a value or a design) that is close to the perfect or ideal (value or design).
  Often an approximation is a result of trade-offs among ideals.
* *argument*: a value passed to a function or a template, in which it is accessed through a parameter.
* *array*: a homogeneous sequence of elements, usually numbered, e.g., `[0:max)`.
* *assertion*: a statement inserted into a program to state (assert) that something must always be true at this point in the program.
* *base class*: a class used as the base of a class hierarchy. Typically a base class has one or more virtual functions.
* *bit*: the basic unit of information in a computer. A bit can have the value 0 or the value 1.
* *bug*: an error in a program.
* *byte*: the basic unit of addressing in most computers. Typically, a byte holds 8 bits.
* *class*: a user-defined type that may contain data members, function members, and member types.
* *code*: a program or a part of a program; ambiguously used for both source code and object code.
* *compiler*: a program that turns source code into object code.
* *complexity*: a hard-to-precisely-define notion or measure of the difficulty of constructing a solution to a problem or of the solution itself.
  Sometimes complexity is used to (simply) mean an estimate of the number of operations needed to execute an algorithm.
* *computation*: the execution of some code, usually taking some input and producing some output.
* *concept*: (1) a notion, and idea; (2) a set of requirements, usually for a template argument.
* *concrete class*: class for which objects can be created using usual construction syntax (e.g., on the stack) and the resulting object behaves much like an `int` as it comes to copying, comparison, and such
(as opposed to a base class in a hierarchy).
* *constant*: a value that cannot be changed (in a given scope); not mutable.
* *constructor*: an operation that initializes ("constructs") an object.
  Typically a constructor establishes an invariant and often acquires resources needed for an object to be used (which are then typically released by a destructor).
* *container*: an object that holds elements (other objects).
* *copy*: an operation that makes two object have values that compare equal. See also move.
* *correctness*: a program or a piece of a program is correct if it meets its specification.
  Unfortunately, a specification can be incomplete or inconsistent, or can fail to meet users' reasonable expectations.
  Thus, to produce acceptable code, we sometimes have to do more than just follow the formal specification.
* *cost*: the expense (e.g., in programmer time, run time, or space) of producing a program or of executing it.
  Ideally, cost should be a function of complexity.
* *customization point*: ???
* *data*: values used in a computation.
* *debugging*: the act of searching for and removing errors from a program; usually far less systematic than testing.
* *declaration*: the specification of a name with its type in a program.
* *definition*: a declaration of an entity that supplies all information necessary to complete a program using the entity.
  Simplified definition: a declaration that allocates memory.
* *derived class*: a class derived from one or more base classes.
* *design*: an overall description of how a piece of software should operate to meet its specification.
* *destructor*: an operation that is implicitly invoked (called) when an object is destroyed (e.g., at the end of a scope). Often, it releases resources.
* *encapsulation*: protecting something meant to be private (e.g., implementation details) from unauthorized access.
* *error*: a mismatch between reasonable expectations of program behavior (often expressed as a requirement or a users' guide) and what a program actually does.
* *executable*: a program ready to be run (executed) on a computer.
* *feature creep*: a tendency to add excess functionality to a program "just in case."
* *file*: a container of permanent information in a computer.
* *floating-point number*: a computer's approximation of a real number, such as 7.93 and 10.78e-3.
* *function*: a named unit of code that can be invoked (called) from different parts of a program; a logical unit of computation.
* *generic programming*: a style of programming focused on the design and efficient implementation of algorithms.
  A generic algorithm will work for all argument types that meet its requirements. In C++, generic programming typically uses templates.
* *global variable*: technically, a named object in namespace scope.
* *handle*: a class that allows access to another through a member pointer or reference. See also resource, copy, move.
* *header*: a file containing declarations used to share interfaces between parts of a program.
* *hiding*: the act of preventing a piece of information from being directly seen or accessed.
  For example, a name from a nested (inner) scope can prevent that same name from an outer (enclosing) scope from being directly used.
* *ideal*: the perfect version of something we are striving for. Usually we have to make trade-offs and settle for an approximation.
* *implementation*: (1) the act of writing and testing code; (2) the code that implements a program.
* *infinite loop*: a loop where the termination condition never becomes true. See iteration.
* *infinite recursion*: a recursion that doesn't end until the machine runs out of memory to hold the calls.
  In reality, such recursion is never infinite but is terminated by some hardware error.
* *information hiding*: the act of separating interface and implementation, thus hiding implementation details not meant for the user's attention and providing an abstraction.
* *initialize*: giving an object its first (initial) value.
* *input*: values used by a computation (e.g., function arguments and characters typed on a keyboard).
* *integer*: a whole number, such as 42 and -99.
* *interface*: a declaration or a set of declarations specifying how a piece of code (such as a function or a class) can be called.
* *invariant*: something that must be always true at a given point (or points) of a program; typically used to describe the state (set of values) of an object or the state of a loop before entry into the repeated statement.
* *iteration*: the act of repeatedly executing a piece of code; see recursion.
* *iterator*: an object that identifies an element of a sequence.
* *ISO*: International Organization for Standardization. The C++ language is an ISO standard, ISO/IEC 14882. More information at [iso.org](http://iso.org).
* *library*: a collection of types, functions, classes, etc. implementing a set of facilities (abstractions) meant to be potentially used as part of more that one program.
* *lifetime*: the time from the initialization of an object until it becomes unusable (goes out of scope, is deleted, or the program terminates).
* *linker*: a program that combines object code files and libraries into an executable program.
* *literal*: a notation that directly specifies a value, such as 12 specifying the integer value "twelve."
* *loop*: a piece of code executed repeatedly; in C++, typically a for-statement or a `while`-statement.
* *move*: an operation that transfers a value from one object to another leaving behind a value representing "empty." See also copy.
* *mutable*: changeable; the opposite of immutable, constant, and invariable.
* *object*: (1) an initialized region of memory of a known type which holds a value of that type; (2) a region of memory.
* *object code*: output from a compiler intended as input for a linker (for the linker to produce executable code).
* *object file*: a file containing object code.
* *object-oriented programming*: (OOP) a style of programming focused on the design and use of classes and class hierarchies.
* *operation*: something that can perform some action, such as a function and an operator.
* *output*: values produced by a computation (e.g., a function result or lines of characters written on a screen).
* *overflow*: producing a value that cannot be stored in its intended target.
* *overload*: defining two functions or operators with the same name but different argument (operand) types.
* *override*: defining a function in a derived class with the same name and argument types as a virtual function in the base class, thus making the function callable through the interface defined by the base class.
* *owner*: an object responsible for releasing a resource.
* *paradigm*: a somewhat pretentious term for design or programming style; often used with the (erroneous) implication that there exists a paradigm that is superior to all others.
* *parameter*: a declaration of an explicit input to a function or a template. When called, a function can access the arguments passed through the names of its parameters.
* *pointer*: (1) a value used to identify a typed object in memory; (2) a variable holding such a value.
* *post-condition*: a condition that must hold upon exit from a piece of code, such as a function or a loop.
* *pre-condition*: a condition that must hold upon entry into a piece of code, such as a function or a loop.
* *program*: code (possibly with associated data) that is sufficiently complete to be executed by a computer.
* *programming*: the art of expressing solutions to problems as code.
* *programming language*: a language for expressing programs.
* *pseudo code*: a description of a computation written in an informal notation rather than a programming language.
* *pure virtual function*: a virtual function that must be overridden in a derived class.
* *RAII*: ("Resource Acquisition Is Initialization") a basic technique for resource management based on scopes.
* *range*: a sequence of values that can be described by a start point and an end point. For example, `[0:5)` means the values 0, 1, 2, 3, and 4.
* *recursion*: the act of a function calling itself; see also iteration.
* *reference*: (1) a value describing the location of a typed value in memory; (2) a variable holding such a value.
* *regular expression*: a notation for patterns in character strings.
* *regular*: a type that behaves similarly to built-in types like `int` and can be compared with `==`.
In particular, an object of a regular type can be copied and the result of a copy is a separate object that compares equal to the original. See also *semiregular type*.
* *requirement*: (1) a description of the desired behavior of a program or part of a program; (2) a description of the assumptions a function or template makes of its arguments.
* *resource*: something that is acquired and must later be released, such as a file handle, a lock, or memory. See also handle, owner.
* *rounding*: conversion of a value to the mathematically nearest value of a less precise type.
* *RTTI*: Run-Time Type Information. ???
* *scope*: the region of program text (source code) in which a name can be referred to.
* *semiregular*: a type that behaves roughly like an built-in type like `int`, but possibly without a `==` operator. See also *regular type*.
* *sequence*: elements that can be visited in a linear order.
* *software*: a collection of pieces of code and associated data; often used interchangeably with program.
* *source code*: code as produced by a programmer and (in principle) readable by other programmers.
* *source file*: a file containing source code.
* *specification*: a description of what a piece of code should do.
* *standard*: an officially agreed upon definition of something, such as a programming language.
* *state*: a set of values.
* *STL*: the containers, iterators, and algorithms part of the standard library.
* *string*: a sequence of characters.
* *style*: a set of techniques for programming leading to a consistent use of language features; sometimes used in a very restricted sense to refer just to low-level rules for naming and appearance of code.
* *subtype*: derived type; a type that has all the properties of a type and possibly more.
* *supertype*: base type; a type that has a subset of the properties of a type.
* *system*: (1) a program or a set of programs for performing a task on a computer; (2) a shorthand for "operating system", that is, the fundamental execution environment and tools for a computer.
* *TS*: [Technical Specification](https://www.iso.org/deliverables-all.html?type=ts), A Technical Specification addresses work still under technical development, or where it is believed that there will be a future, but not immediate, possibility of agreement on an International Standard. A Technical Specification is published for immediate use, but it also provides a means to obtain feedback. The aim is that it will eventually be transformed and republished as an International Standard.
* *template*: a class or a function parameterized by one or more types or (compile-time) values; the basic C++ language construct supporting generic programming.
* *testing*: a systematic search for errors in a program.
* *trade-off*: the result of balancing several design and implementation criteria.
* *truncation*: loss of information in a conversion from a type into another that cannot exactly represent the value to be converted.
* *type*: something that defines a set of possible values and a set of operations for an object.
* *uninitialized*: the (undefined) state of an object before it is initialized.
* *unit*: (1) a standard measure that gives meaning to a value (e.g., km for a distance); (2) a distinguished (e.g., named) part of a larger whole.
* *use case*: a specific (typically simple) use of a program meant to test its functionality and demonstrate its purpose.
* *value*: a set of bits in memory interpreted according to a type.
* *variable*: a named object of a given type; contains a value unless uninitialized.
* *virtual function*: a member function that can be overridden in a derived class.
* *word*: a basic unit of memory in a computer, often the unit used to hold an integer.

# <a name="S-unclassified"></a>To-do: Unclassified proto-rules

This is our to-do list.
Eventually, the entries will become rules or parts of rules.
Alternatively, we will decide that no change is needed and delete the entry.

* No long-distance friendship
* Should physical design (what's in a file) and large-scale design (libraries, groups of libraries) be addressed?
* Namespaces
* Avoid using directives in the global scope (except for std, and other "fundamental" namespaces (e.g. experimental))
* How granular should namespaces be? All classes/functions designed to work together and released together (as defined in Sutter/Alexandrescu) or something narrower or wider?
* Should there be inline namespaces (a la `std::literals::*_literals`)?
* Avoid implicit conversions
* Const member functions should be thread safe ... aka, but I don't really change the variable, just assign it a value the first time it's called ... argh
* Always initialize variables, use initialization lists for member variables.
* Anyone writing a public interface which takes or returns `void*` should have their toes set on fire. That one has been a personal favorite of mine for a number of years. :)
* Use `const`-ness wherever possible: member functions, variables and (yippee) `const_iterators`
* Use `auto`
* `(size)` vs. `{initializers}` vs. `{Extent{size}}`
* Don't overabstract
* Never pass a pointer down the call stack
* falling through a function bottom
* Should there be guidelines to choose between polymorphisms? YES. classic (virtual functions, reference semantics) vs. Sean Parent style (value semantics, type-erased, kind of like `std::function`)  vs. CRTP/static? YES Perhaps even vs. tag dispatch?
* should virtual calls be banned from ctors/dtors in your guidelines? YES. A lot of people ban them, even though I think it's a big strength of C++ that they are ??? -preserving (D disappointed me so much when it went the Java way). WHAT WOULD BE A GOOD EXAMPLE?
* Speaking of lambdas, what would weigh in on the decision between lambdas and (local?) classes in algorithm calls and other callback scenarios?
* And speaking of `std::bind`, Stephen T. Lavavej criticizes it so much I'm starting to wonder if it is indeed going to fade away in future. Should lambdas be recommended instead?
* What to do with leaks out of temporaries? : `p = (s1 + s2).c_str();`
* pointer/iterator invalidation leading to dangling pointers:

        void bad()
        {
            int* p = new int[700];
            int* q = &p[7];
            delete p;

            vector<int> v(700);
            int* q2 = &v[7];
            v.resize(900);

            // ... use q and q2 ...
        }

* LSP
* private inheritance vs/and membership
* avoid static class members variables (race conditions, almost-global variables)

* Use RAII lock guards (`lock_guard`, `unique_lock`, `shared_lock`), never call `mutex.lock` and `mutex.unlock` directly (RAII)
* Prefer non-recursive locks (often used to work around bad reasoning, overhead)
* Join your threads! (because of `std::terminate` in destructor if not joined or detached ... is there a good reason to detach threads?) -- ??? could support library provide a RAII wrapper for `std::thread`?
* If two or more mutexes must be acquired at the same time, use `std::lock` (or another deadlock avoidance algorithm?)
* When using a `condition_variable`, always protect the condition by a mutex (atomic bool whose value is set outside of the mutex is wrong!), and use the same mutex for the condition variable itself.
* Never use `atomic_compare_exchange_strong` with `std::atomic<user-defined-struct>` (differences in padding matter, while `compare_exchange_weak` in a loop converges to stable padding)
* individual `shared_future` objects are not thread-safe: two threads cannot wait on the same `shared_future` object (they can wait on copies of a `shared_future` that refer to the same shared state)
* individual `shared_ptr` objects are not thread-safe: different threads can call non-`const` member functions on *different* `shared_ptr`s that refer to the same shared object, but one thread cannot call a non-`const` member function of a `shared_ptr` object while another thread accesses that same `shared_ptr` object (if you need that, consider `atomic_shared_ptr` instead)

* rules for arithmetic

# Bibliography

* <a name="Abrahams01"></a>
  \[Abrahams01]:  D. Abrahams. [Exception-Safety in Generic Components](http://www.boost.org/community/exception_safety.html).
* <a name="Alexandrescu01"></a>
  \[Alexandrescu01]:  A. Alexandrescu. Modern C++ Design (Addison-Wesley, 2001).
* <a name="Cplusplus03"></a>
  \[C++03]:           ISO/IEC 14882:2003(E), Programming Languages — C++ (updated ISO and ANSI C++ Standard including the contents of (C++98) plus errata corrections).
* <a name="CplusplusCS"></a>
  \[C++CS]:           ???
* <a name="Cargill92"></a>
  \[Cargill92]:       T. Cargill. C++ Programming Style (Addison-Wesley, 1992).
* <a name="Cline99"></a>
  \[Cline99]:         M. Cline, G. Lomow, and M. Girou. C++ FAQs (2ndEdition) (Addison-Wesley, 1999).
* <a name="Dewhurst03"></a>
  \[Dewhurst03]:      S. Dewhurst. C++ Gotchas (Addison-Wesley, 2003).
* <a name="Henricson97"></a>
  \[Henricson97]:     M. Henricson and E. Nyquist. Industrial Strength C++ (Prentice Hall, 1997).
* <a name="Koenig97"></a>
  \[Koenig97]:        A. Koenig and B. Moo. Ruminations on C++ (Addison-Wesley, 1997).
* <a name="Lakos96"></a>
  \[Lakos96]:         J. Lakos. Large-Scale C++ Software Design (Addison-Wesley, 1996).
* <a name="Meyers96"></a>
  \[Meyers96]:        S. Meyers. More Effective C++ (Addison-Wesley, 1996).
* <a name="Meyers97"></a>
  \[Meyers97]:        S. Meyers. Effective C++ (2nd Edition) (Addison-Wesley, 1997).
* <a name="Meyers15"></a>
  \[Meyers15]:        S. Meyers. Effective Modern C++ (O'Reilly, 2015).
* <a name="Murray93"></a>
  \[Murray93]:        R. Murray. C++ Strategies and Tactics (Addison-Wesley, 1993).
* <a name="Stroustrup94"></a>
  \[Stroustrup94]:    B. Stroustrup. The Design and Evolution of C++ (Addison-Wesley, 1994).
* <a name="Stroustrup00"></a>
  \[Stroustrup00]:    B. Stroustrup. The C++ Programming Language (Special 3rdEdition) (Addison-Wesley, 2000).
* <a name="Stroustrup05"></a>
  \[Stroustrup05]:    B. Stroustrup. [A rationale for semantically enhanced library languages](http://www.stroustrup.com/SELLrationale.pdf).
* <a name="Stroustrup13"></a>
  \[Stroustrup13]:    B. Stroustrup. [The C++ Programming Language (4th Edition)](http://www.stroustrup.com/4th.html). Addison Wesley 2013.
* <a name="Stroustrup14"></a>
  \[Stroustrup14]:    B. Stroustrup. [A Tour of C++](http://www.stroustrup.com/Tour.html).
  Addison Wesley 2014.
* <a name="Stroustrup15"></a>
  \[Stroustrup15]:    B. Stroustrup, Herb Sutter, and G. Dos Reis: [A brief introduction to C++'s model for type- and resource-safety](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Introduction%20to%20type%20and%20resource%20safety.pdf).
* <a name="SuttHysl04b"></a>
  \[SuttHysl04b]:     H. Sutter and J. Hyslop. [Collecting Shared Objects](https://web.archive.org/web/20120926011837/http://www.drdobbs.com/collecting-shared-objects/184401839) (C/C++ Users Journal, 22(8), August 2004).
* <a name="SuttAlex05"></a>
  \[SuttAlex05]:      H. Sutter and  A. Alexandrescu. C++ Coding Standards. Addison-Wesley 2005.
* <a name="Sutter00"></a>
  \[Sutter00]:        H. Sutter. Exceptional C++ (Addison-Wesley, 2000).
* <a name="Sutter02"></a>
  \[Sutter02]:        H. Sutter. More Exceptional C++ (Addison-Wesley, 2002).
* <a name="Sutter04"></a>
  \[Sutter04]:        H. Sutter. Exceptional C++ Style (Addison-Wesley, 2004).
* <a name="Taligent94"></a>
  \[Taligent94]: Taligent's Guide to Designing Programs (Addison-Wesley, 1994).

